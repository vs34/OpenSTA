/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */


#define SWIG_VERSION 0x040200
#define SWIGTCL
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

#if __cplusplus >=201103L
# define SWIG_NULLPTR nullptr
#else
# define SWIG_NULLPTR NULL
#endif 


#include <stdio.h>
#include <tcl.h>
#include <errno.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4
#define SWIG_POINTER_CLEAR         0x8
#define SWIG_POINTER_RELEASE       (SWIG_POINTER_CLEAR | SWIG_POINTER_DISOWN)

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows returning the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
/* Runtime errors are < 0 */
#define SWIG_ERROR                 (-1)
/* Errors in range -1 to -99 are in swigerrors.swg (errors for all languages including those not using the runtime) */
/* Errors in range -100 to -199 are language specific errors defined in *errors.swg */
/* Errors < -200 are generic runtime specific errors */
#define SWIG_ERROR_RELEASE_NOT_OWNED (-200)

#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporary objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del object mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif

/* C99 and C++11 should provide snprintf, but define SWIG_NO_SNPRINTF
 * if you're missing it.
 */
#if ((defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L) || \
     (defined __cplusplus && __cplusplus >= 201103L) || \
     defined SWIG_HAVE_SNPRINTF) && \
    !defined SWIG_NO_SNPRINTF
# define SWIG_snprintf(O,S,F,A) snprintf(O,S,F,A)
# define SWIG_snprintf2(O,S,F,A,B) snprintf(O,S,F,A,B)
#else
/* Fallback versions ignore the buffer size, but most of our uses either have a
 * fixed maximum possible size or dynamically allocate a buffer that's large
 * enough.
 */
# define SWIG_snprintf(O,S,F,A) sprintf(O,F,A)
# define SWIG_snprintf2(O,S,F,A,B) sprintf(O,F,A,B)
#endif

#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  Choose the last
     name. It should be the most specific; a fully resolved name
     but not necessarily with default template parameters expanded. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* SWIG Errors applicable to all language modules, values are reserved from -1 to -99 */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13


/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGINTERN const char*
SWIG_Tcl_ErrorType(int code) {
  const char* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = "MemoryError";
    break;
  case SWIG_IOError:
    type = "IOError";
    break;
  case SWIG_RuntimeError:
    type = "RuntimeError";
    break;
  case SWIG_IndexError:
    type = "IndexError";
    break;
  case SWIG_TypeError:
    type = "TypeError";
    break;
  case SWIG_DivisionByZero:
    type = "ZeroDivisionError";
    break;
  case SWIG_OverflowError:
    type = "OverflowError";
    break;
  case SWIG_SyntaxError:
    type = "SyntaxError";
    break;
  case SWIG_ValueError:
    type = "ValueError";
    break;
  case SWIG_SystemError:
    type = "SystemError";
    break;
  case SWIG_AttributeError:
    type = "AttributeError";
    break;
  default:
    type = "RuntimeError";
  }
  return type;
}


SWIGINTERN void
SWIG_Tcl_SetErrorObj(Tcl_Interp *interp, const char *ctype, Tcl_Obj *obj)
{
  Tcl_ResetResult(interp);
  Tcl_SetObjResult(interp, obj);
  Tcl_SetErrorCode(interp, "SWIG", ctype, (char *)NULL);
}

SWIGINTERN void
SWIG_Tcl_SetErrorMsg(Tcl_Interp *interp, const char *ctype, const char *mesg)
{
  Tcl_ResetResult(interp);
  Tcl_SetErrorCode(interp, "SWIG", ctype, (char *)NULL);
  Tcl_AppendResult(interp, ctype, " ", mesg, (char *)NULL);
  /*
  Tcl_AddErrorInfo(interp, ctype);
  Tcl_AddErrorInfo(interp, " ");
  Tcl_AddErrorInfo(interp, mesg);
  */
}

SWIGINTERNINLINE void
SWIG_Tcl_AddErrorMsg(Tcl_Interp *interp, const char* mesg)
{
  Tcl_AddErrorInfo(interp, mesg);
}



/* -----------------------------------------------------------------------------
 * SWIG API. Portion that goes into the runtime
 * ----------------------------------------------------------------------------- */
#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_TCL_POINTER 4
#define SWIG_TCL_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    const char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *const []);
typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *const []);
typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
typedef void  (*swig_delete_func)(ClientData);

typedef struct swig_method {
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;

typedef struct swig_class {
  const char         *name;
  swig_type_info   **type;
  swig_wrapper       constructor;
  void              (*destructor)(void *);
  swig_method        *methods;
  swig_attribute     *attributes;
  struct swig_class **bases;
  const char              **base_names;
  swig_module_info   *module;
  Tcl_HashTable       hashtable;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
  Tcl_Command    cmdtok;
} swig_instance;

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *const []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;


/* -----------------------------------------------------------------------------*
 *  Install a constant object 
 * -----------------------------------------------------------------------------*/

static Tcl_HashTable   swigconstTable;
static int             swigconstTableinit = 0;

SWIGINTERN void
SWIG_Tcl_SetConstantObj(Tcl_Interp *interp, const char* name, Tcl_Obj *obj) {
  int newobj;
  Tcl_ObjSetVar2(interp,Tcl_NewStringObj(name,-1), NULL, obj, TCL_GLOBAL_ONLY);
  Tcl_SetHashValue(Tcl_CreateHashEntry(&swigconstTable, name, &newobj), (ClientData) obj);
}

SWIGINTERN Tcl_Obj *
SWIG_Tcl_GetConstantObj(const char *key) {
  Tcl_HashEntry *entryPtr;
  if (!swigconstTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
  if (entryPtr) {
    return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
  }
  return 0;
}

#ifdef __cplusplus
}
#endif



/* -----------------------------------------------------------------------------
 * tclrun.swg
 *
 * This file contains the runtime support for Tcl modules and includes
 * code for managing global variables and pointer type checking.
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_ConvertPtr(oc, ptr, ty, flags)             SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Tcl_NewPointerObj(ptr, type, flags)

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, flags)
#define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Tcl_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp,obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Tcl_GetModule((Tcl_Interp *) (clientdata))	     
#define SWIG_SetModule(clientdata, pointer)          	SWIG_Tcl_SetModule((Tcl_Interp *) (clientdata), pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Tcl_ErrorType(code)                                      
#define SWIG_Error(code, msg)            		SWIG_Tcl_SetErrorMsg(interp, SWIG_Tcl_ErrorType(code), msg)
#define SWIG_fail                        		goto fail						    


/* Tcl-specific SWIG API */

#define SWIG_Acquire(ptr)                               SWIG_Tcl_Acquire(ptr)                                     
#define SWIG_MethodCommand                           	SWIG_Tcl_MethodCommand				       
#define SWIG_Disown(ptr)                             	SWIG_Tcl_Disown(ptr)				       
#define SWIG_ConvertPtrFromString(c, ptr, ty, flags) 	SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)  
#define SWIG_MakePtr(c, ptr, ty, flags)              	SWIG_Tcl_MakePtr(c, ptr, ty, flags)		       
#define SWIG_PointerTypeFromString(c)                	SWIG_Tcl_PointerTypeFromString(c)			       
#define SWIG_GetArgs                                 	SWIG_Tcl_GetArgs					       
#define SWIG_GetConstantObj(key)                     	SWIG_Tcl_GetConstantObj(key)			       
#define SWIG_ObjectConstructor                       	SWIG_Tcl_ObjectConstructor				       
#define SWIG_Thisown(ptr)                            	SWIG_Tcl_Thisown(ptr)				       
#define SWIG_ObjectDelete                            	SWIG_Tcl_ObjectDelete				       


#define SWIG_TCL_DECL_ARGS_2(arg1, arg2)                (Tcl_Interp *interp SWIGUNUSED, arg1, arg2)
#define SWIG_TCL_CALL_ARGS_2(arg1, arg2)                (interp, arg1, arg2)
/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_GetConstant        SWIG_GetConstantObj
#define SWIG_Tcl_GetConstant    SWIG_Tcl_GetConstantObj

#if TCL_MAJOR_VERSION > 8 || (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION >= 5)
#define SWIG_TCL_HASHTABLE_INIT {0, {0, 0, 0, 0}, 0, 0, 0, 0, 0, 0, 0, 0, 0}
#else
#define SWIG_TCL_HASHTABLE_INIT {0}
#endif

#include "assert.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Object support */

SWIGRUNTIME Tcl_HashTable*
SWIG_Tcl_ObjectTable(void) {
  static Tcl_HashTable  swigobjectTable;
  static int            swigobjectTableinit = 0;
  if (!swigobjectTableinit) {
    Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
    swigobjectTableinit = 1;
  }
  return &swigobjectTable;
}

/* Acquire ownership of a pointer */
SWIGRUNTIME void
SWIG_Tcl_Acquire(void *ptr) {
  int newobj;
  Tcl_CreateHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr, &newobj);
}

SWIGRUNTIME int
SWIG_Tcl_Thisown(void *ptr) {
  if (Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr)) {
    return 1;
  }
  return 0;
}

/* Disown a pointer.  Returns 1 if we owned it to begin with */
SWIGRUNTIME int
SWIG_Tcl_Disown(void *ptr) {
  Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr);
  if (entryPtr) {
    Tcl_DeleteHashEntry(entryPtr);
    return 1;
  }
  return 0;
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
  swig_cast_info *tc;
  const char *cmd_name;
  /* Pointer values must start with leading underscore */
  while (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0)
      return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;

    /* Empty string: not a pointer */
    if (*c == 0) return SWIG_ERROR; 

    /* Hmmm. It could be an object name. */

    /* Check if this is a command at all. Prevents <c> cget -this         */
    /* from being called when c is not a command, firing the unknown proc */
    if (Tcl_VarEval(interp,"info commands ", c, (char *) NULL) == TCL_OK) {
      Tcl_Obj *result = Tcl_GetObjResult(interp);
      if (*(Tcl_GetString(result)) == 0) {
        /* It's not a command, so it can't be a pointer */
        Tcl_ResetResult(interp);
        return SWIG_ERROR;
      }
    } else {
      /* This will only fail if the argument is multiple words. */
      /* Multiple words are also not commands.                  */
      Tcl_ResetResult(interp);
      return SWIG_ERROR;
    }

    /* Check if this is really a SWIG pointer */
    if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) != TCL_OK) {
      Tcl_ResetResult(interp);
      return SWIG_ERROR;
    }

    c = Tcl_GetString(Tcl_GetObjResult(interp));
  }
  cmd_name = c;

  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));

  if (ty) {
    tc = c ? SWIG_TypeCheck(c,ty) : 0;
    if (tc) {
      Tcl_CmdInfo info;
      if (Tcl_GetCommandInfo(interp, cmd_name, &info)) {
        swig_instance *inst = (swig_instance *)info.objClientData;
        if (!inst->thisvalue) {
          *ptr = 0;
        }
        assert(inst->thisvalue == *ptr);
        if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && !SWIG_Thisown(inst->thisvalue)) {
          return SWIG_ERROR_RELEASE_NOT_OWNED;
        } else {
          if (flags & SWIG_POINTER_DISOWN) {
            SWIG_Disown((void *) *ptr);
          }
          if (flags & SWIG_POINTER_CLEAR) {
            inst->thisvalue = 0;
          }
          {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,(void *) *ptr,&newmemory);
            assert(!newmemory); /* newmemory handling not yet implemented */
          }
        }
      }
    } else {
      return SWIG_ERROR;
    }
  }

  return SWIG_OK;
}

/* Convert a pointer value */
SWIGRUNTIMEINLINE int
SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
  return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetString(oc), ptr, ty, flags);
}

/* Convert a pointer value */
SWIGRUNTIME char *
SWIG_Tcl_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore. NULL has no type */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Convert a packed pointer value */
SWIGRUNTIME int
SWIG_Tcl_ConvertPacked(Tcl_Interp *SWIGUNUSEDPARM(interp) , Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (!obj) goto type_error;
  c = Tcl_GetString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:

  return SWIG_ERROR;
}


/* Take a pointer and convert it to a string */
SWIGRUNTIME void
SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int SWIGUNUSEDPARM(flags)) {
  if (ptr) {
    *(c++) = '_';
    c = SWIG_PackData(c,&ptr,sizeof(void *));
    strcpy(c,ty->name);
  } else {
    strcpy(c,"NULL");
  }
}

/* Create a new pointer object */
SWIGRUNTIMEINLINE Tcl_Obj *
SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  Tcl_Obj *robj;
  char result[SWIG_BUFFER_SIZE];
  SWIG_MakePtr(result,ptr,type,flags);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

SWIGRUNTIME Tcl_Obj *
SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return Tcl_NewStringObj(result,-1);
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

SWIGRUNTIME swig_module_info * 
SWIG_Tcl_GetModule(Tcl_Interp *interp) {
  const char *data;
  swig_module_info *ret = 0;
  
  /* first check if pointer already created */
  data = Tcl_GetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
  if (data) {
    SWIG_UnpackData(data, &ret, sizeof(swig_type_info **));
  }

  return ret;
}

SWIGRUNTIME void
SWIG_Tcl_SetModule(Tcl_Interp *interp, swig_module_info *module) {
  char buf[SWIG_BUFFER_SIZE];
  char *data;

  /* create a new pointer */
  data = SWIG_PackData(buf, &module, sizeof(swig_type_info **));
  *data = 0;
  Tcl_SetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, TCL_GLOBAL_ONLY);
}

/* -----------------------------------------------------------------------------*
 *  Object auxiliaries
 * -----------------------------------------------------------------------------*/


SWIGRUNTIME void
SWIG_Tcl_ObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if (!si) return;
  if (si->destroy && SWIG_Disown(si->thisvalue)) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
SWIGRUNTIME int
SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const _objv[]) {
  char *method,   *attrname;
  swig_instance   *inst = (swig_instance *) clientData;
  swig_method     *meth;
  swig_attribute  *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;
  swig_class      *cls;
  swig_class      *cls_stack[64];
  int              cls_stack_bi[64];
  int              cls_stack_top = 0;
  int              numconf = 2;
  int              bi;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  method = Tcl_GetString(objv[1]);
  if (strcmp(method,"-acquire") == 0) {
    inst->destroy = 1;
    SWIG_Acquire(inst->thisvalue);
    return TCL_OK;
  }
  if (strcmp(method,"-disown") == 0) {
    if (inst->destroy) {
      SWIG_Disown(inst->thisvalue);
    }
    inst->destroy = 0;
    return TCL_OK;
  }
  if (strcmp(method,"-delete") == 0) {
    Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
    return TCL_OK;
  }
  cls_stack[cls_stack_top] = inst->classptr;
  cls_stack_bi[cls_stack_top] = -1;
  while (1) {
    Tcl_HashEntry* hashentry;
    bi = cls_stack_bi[cls_stack_top];
    cls = cls_stack[cls_stack_top];
    if (bi != -1) {
      if (!cls->bases[bi] && cls->base_names[bi]) {
        /* lookup and cache the base class */
	swig_type_info *info = SWIG_TypeQueryModule(cls->module, cls->module, cls->base_names[bi]);
	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
      }
      cls = cls->bases[bi];
      if (cls) {
        cls_stack_bi[cls_stack_top]++;
        cls_stack_top++;
        cls_stack[cls_stack_top] = cls;
        cls_stack_bi[cls_stack_top] = -1;
        continue;
      }
    }
    if (!cls) {
      cls_stack_top--;
      if (cls_stack_top < 0) break;
      else continue;
    }
    cls_stack_bi[cls_stack_top]++;

    hashentry = Tcl_FindHashEntry(&(cls->hashtable), method);
    if (hashentry) {
        ClientData cd = Tcl_GetHashValue(hashentry);
        swig_wrapper method_wrapper = (swig_wrapper)cd;
        oldarg = objv[1];
        objv[1] = inst->thisptr;
        Tcl_IncrRefCount(inst->thisptr);
        rcode = (method_wrapper)(clientData,interp,objc,objv);
        objv[1] = oldarg;
        Tcl_DecrRefCount(inst->thisptr);
        return rcode;
    }
    /* Check class methods for a match */
    if (strcmp(method,"cget") == 0) {
      if (objc < 3) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      attrname = Tcl_GetString(objv[2]);
      attr = cls->attributes;
      while (attr && attr->name) {
        if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
          oldarg = objv[1];
          objv[1] = inst->thisptr;
          Tcl_IncrRefCount(inst->thisptr);
          rcode = (*attr->getmethod)(clientData,interp,2, objv);
          objv[1] = oldarg;
          Tcl_DecrRefCount(inst->thisptr);
          return rcode;
        }
        attr++;
      }
      if (strcmp(attrname, "-this") == 0) {
        Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
        return TCL_OK;
      }
      if (strcmp(attrname, "-thisown") == 0) {
        if (SWIG_Thisown(inst->thisvalue)) {
          Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
        } else {
          Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
        }
        return TCL_OK;
      }
    } else if (strcmp(method, "configure") == 0) {
      int i;
      if (objc < 4) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      i = 2;
      while (i < objc) {
        attrname = Tcl_GetString(objv[i]);
        attr = cls->attributes;
        while (attr && attr->name) {
          if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
            oldarg = objv[i];
            objv[i] = inst->thisptr;
            Tcl_IncrRefCount(inst->thisptr);
            rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
            objv[i] = oldarg;
            Tcl_DecrRefCount(inst->thisptr);
            if (rcode != TCL_OK) return rcode;
            numconf += 2;
          }
          attr++;
        }
        i+=2;
      }
    }
  }
  if (strcmp(method,"configure") == 0) {
    if (numconf >= objc) {
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  if (strcmp(method,"cget") == 0) {
    Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
    return TCL_ERROR;
  }
  Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
  cls = inst->classptr;
  bi = 0;
  while (cls) {
    meth = cls->methods;
    while (meth && meth->name) {
      char *cr = (char *) Tcl_GetStringResult(interp);
      size_t meth_len = strlen(meth->name);
      char* where = strchr(cr,':');
      while(where) {
        where = strstr(where, meth->name);
        if(where) {
          if(where[-1] == ' ' && (where[meth_len] == ' ' || where[meth_len]==0)) {
            break;
          } else {
            where++;
          }
        }
      }

      if (!where)
        Tcl_AppendElement(interp, (char *) meth->name);
      meth++;
    }
    cls = inst->classptr->bases[bi++];
  }
  return TCL_ERROR;
}

/* This function takes the current result and turns it into an object command */
SWIGRUNTIME Tcl_Obj *
SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
  Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
  /* Check to see if this pointer belongs to a class or not */
  if (thisvalue && (type->clientdata) && (interp)) {
    Tcl_CmdInfo    ci;
    int has_command;
    char          *name;
    name = Tcl_GetString(robj);
    has_command = Tcl_GetCommandInfo(interp, name, &ci);
    if (!has_command || flags) {
      swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = Tcl_DuplicateObj(robj);
      Tcl_IncrRefCount(newinst->thisptr);
      newinst->thisvalue = thisvalue;
      newinst->classptr = (swig_class *) type->clientdata;
      newinst->destroy = flags;
      newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetString(robj), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
      if (flags) {
        SWIG_Acquire(thisvalue);
      }
    } else {
      swig_instance *inst = (swig_instance *)ci.objClientData;
      /* Restore thisvalue as SWIG_POINTER_CLEAR may have been used to set it to zero.
         Occurs when the C pointer is re-used by the memory allocator and the command has
         been created and not destroyed - bug?? - see cpp11_std_unique_ptr_runme.tcl test. */
      if (inst->thisvalue != thisvalue) {
        assert(inst->thisvalue == 0);
        inst->thisvalue = thisvalue;
      }
    }
  }
  return robj;
}

/* Function to create objects */
SWIGRUNTIME int
SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Tcl_Obj          *newObj = 0;
  void             *thisvalue = 0;
  swig_instance   *newinst = 0;
  swig_class      *classptr = (swig_class *) clientData;
  swig_wrapper     cons = 0;
  char             *name = 0;
  int               firstarg = 0;
  int               thisarg = 0;
  int               destroy = 1;

  if (!classptr) {
    Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
    return TCL_ERROR;
  }
  cons = classptr->constructor;
  if (objc > 1) {
    char *s = Tcl_GetString(objv[1]);
    if (strcmp(s,"-this") == 0) {
      thisarg = 2;
      cons = 0;
    } else if (strcmp(s,"-args") == 0) {
      firstarg = 1;
    } else if (objc == 2) {
      firstarg = 1;
      name = s;
    } else if (objc >= 3) {
      char *s1;
      name = s;
      s1 = Tcl_GetString(objv[2]);
      if (strcmp(s1,"-this") == 0) {
	thisarg = 3;
	cons = 0;
      } else {
	firstarg = 1;
      }
    }
  }
  if (cons) {
    int result;
    result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
    if (result != TCL_OK) {
      return result;
    }
    newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
    if (!name) name = Tcl_GetString(newObj);
  } else if (thisarg > 0) {
    if (thisarg < objc) {
      destroy = 0;
      newObj = Tcl_DuplicateObj(objv[thisarg]);
      if (!name) name = Tcl_GetString(newObj);
    } else {
      Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
  } else {
    Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
    return TCL_ERROR;
  }
  if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), 0) != SWIG_OK) {
    Tcl_DecrRefCount(newObj);
    return TCL_ERROR;
  }
  newinst = (swig_instance *) malloc(sizeof(swig_instance));
  newinst->thisptr = newObj;
  Tcl_IncrRefCount(newObj);
  newinst->thisvalue = thisvalue;
  newinst->classptr = classptr;
  newinst->destroy = destroy;
  if (destroy) {
    SWIG_Acquire(thisvalue);
  }
  newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
  return TCL_OK;
}

/* -----------------------------------------------------------------------------*
 *   Get arguments 
 * -----------------------------------------------------------------------------*/
SWIGRUNTIME int
SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], const char *fmt, ...) {
  int        argno = 0, opt = 0;
  long       tempi;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  Tcl_Obj   *obj = 0;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
        Tcl_SetResult(interp, (char *) "Wrong number of arguments ", TCL_STATIC);
        goto argerror;
      } else {
        va_end(ap);
        return TCL_OK;
      }
    }

    vptr = va_arg(ap,void *);
    if (vptr) {
      if (isupper(*c)) {
        obj = SWIG_Tcl_GetConstantObj(Tcl_GetString(objv[argno+1]));
        if (!obj) obj = objv[argno+1];
      } else {
        obj = objv[argno+1];
      }
      switch(*c) {
      case 'i': case 'I':
      case 'l': case 'L':
      case 'h': case 'H':
      case 'b': case 'B':
        if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
        if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
        else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
        else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
        else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
        break;
      case 'f': case 'F':
      case 'd': case 'D':
        if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
        if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
        else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
        break;
      case 's': case 'S':
        if (*(c+1) == '#') {
          int *vlptr = (int *) va_arg(ap, void *);
          *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
          c++;
        } else {
          *((char **)vptr) = Tcl_GetString(obj);
        }
        break;
      case 'c': case 'C':
        *((char *)vptr) = *(Tcl_GetString(obj));
        break;
      case 'p': case 'P':
        ty = (swig_type_info *) va_arg(ap, void *);
        if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, 0) != SWIG_OK) goto argerror;
        break;
      case 'o': case 'O':
        *((Tcl_Obj **)vptr) = objv[argno+1];
        break;
      default:
        break;
      }
    }
  }

  if ((*c != ';') && ((objc-1) > argno)) {
    Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;

 argerror:
  {
    char temp[32];
    SWIG_snprintf(temp, sizeof(temp), "%d", argno+1);
    c = strchr(fmt,':');
    if (!c) c = strchr(fmt,';');
    if (!c) c = (char *)"";
    Tcl_AppendResult(interp,c," argument ", temp, (char *)NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) do { if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } } while (0) 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Cell swig_types[0]
#define SWIGTYPE_p_CellPortIterator swig_types[1]
#define SWIGTYPE_p_CellSeq swig_types[2]
#define SWIGTYPE_p_CircuitSim swig_types[3]
#define SWIGTYPE_p_Clock swig_types[4]
#define SWIGTYPE_p_ClockEdge swig_types[5]
#define SWIGTYPE_p_ClockGroups swig_types[6]
#define SWIGTYPE_p_ClockSeq swig_types[7]
#define SWIGTYPE_p_ClockSet swig_types[8]
#define SWIGTYPE_p_ConstClockSeq swig_types[9]
#define SWIGTYPE_p_Corner swig_types[10]
#define SWIGTYPE_p_EarlyLate swig_types[11]
#define SWIGTYPE_p_EarlyLateAll swig_types[12]
#define SWIGTYPE_p_Edge swig_types[13]
#define SWIGTYPE_p_EdgeSeq swig_types[14]
#define SWIGTYPE_p_ExceptionFrom swig_types[15]
#define SWIGTYPE_p_ExceptionThru swig_types[16]
#define SWIGTYPE_p_ExceptionThruSeq swig_types[17]
#define SWIGTYPE_p_ExceptionTo swig_types[18]
#define SWIGTYPE_p_FloatSeq swig_types[19]
#define SWIGTYPE_p_Instance swig_types[20]
#define SWIGTYPE_p_InstanceChildIterator swig_types[21]
#define SWIGTYPE_p_InstanceNetIterator swig_types[22]
#define SWIGTYPE_p_InstancePinIterator swig_types[23]
#define SWIGTYPE_p_InstanceSeq swig_types[24]
#define SWIGTYPE_p_InstanceSet swig_types[25]
#define SWIGTYPE_p_IntSeq swig_types[26]
#define SWIGTYPE_p_LeafInstanceIterator swig_types[27]
#define SWIGTYPE_p_LibertyCell swig_types[28]
#define SWIGTYPE_p_LibertyCellPortIterator swig_types[29]
#define SWIGTYPE_p_LibertyCellSeq swig_types[30]
#define SWIGTYPE_p_LibertyLibrary swig_types[31]
#define SWIGTYPE_p_LibertyLibraryIterator swig_types[32]
#define SWIGTYPE_p_LibertyLibrarySeq swig_types[33]
#define SWIGTYPE_p_LibertyPort swig_types[34]
#define SWIGTYPE_p_LibertyPortMemberIterator swig_types[35]
#define SWIGTYPE_p_LibertyPortSeq swig_types[36]
#define SWIGTYPE_p_Library swig_types[37]
#define SWIGTYPE_p_LibraryIterator swig_types[38]
#define SWIGTYPE_p_LogicValue swig_types[39]
#define SWIGTYPE_p_MaxSkewCheck swig_types[40]
#define SWIGTYPE_p_MaxSkewCheckSeq swig_types[41]
#define SWIGTYPE_p_MinMax swig_types[42]
#define SWIGTYPE_p_MinMaxAll swig_types[43]
#define SWIGTYPE_p_MinMaxAllNull swig_types[44]
#define SWIGTYPE_p_MinPeriodCheck swig_types[45]
#define SWIGTYPE_p_MinPeriodCheckSeq swig_types[46]
#define SWIGTYPE_p_MinPulseWidthCheck swig_types[47]
#define SWIGTYPE_p_MinPulseWidthCheckSeq swig_types[48]
#define SWIGTYPE_p_MinPulseWidthCheckSeqIterator swig_types[49]
#define SWIGTYPE_p_Net swig_types[50]
#define SWIGTYPE_p_NetConnectedPinIterator swig_types[51]
#define SWIGTYPE_p_NetPinIterator swig_types[52]
#define SWIGTYPE_p_NetSeq swig_types[53]
#define SWIGTYPE_p_NetSet swig_types[54]
#define SWIGTYPE_p_NetTermIterator swig_types[55]
#define SWIGTYPE_p_OperatingConditions swig_types[56]
#define SWIGTYPE_p_Path swig_types[57]
#define SWIGTYPE_p_PathClkOrData swig_types[58]
#define SWIGTYPE_p_PathEnd swig_types[59]
#define SWIGTYPE_p_PathEndSeq swig_types[60]
#define SWIGTYPE_p_PathGroupNameSet swig_types[61]
#define SWIGTYPE_p_PathRef swig_types[62]
#define SWIGTYPE_p_Pin swig_types[63]
#define SWIGTYPE_p_PinConnectedPinIterator swig_types[64]
#define SWIGTYPE_p_PinSeq swig_types[65]
#define SWIGTYPE_p_PinSet swig_types[66]
#define SWIGTYPE_p_Port swig_types[67]
#define SWIGTYPE_p_PortDirection swig_types[68]
#define SWIGTYPE_p_PortMemberIterator swig_types[69]
#define SWIGTYPE_p_PortSeq swig_types[70]
#define SWIGTYPE_p_PowerResult swig_types[71]
#define SWIGTYPE_p_ReportPathFormat swig_types[72]
#define SWIGTYPE_p_RiseFall swig_types[73]
#define SWIGTYPE_p_RiseFallBoth swig_types[74]
#define SWIGTYPE_p_SetupHold swig_types[75]
#define SWIGTYPE_p_SetupHoldAll swig_types[76]
#define SWIGTYPE_p_StringSeq swig_types[77]
#define SWIGTYPE_p_StringSet swig_types[78]
#define SWIGTYPE_p_Tcl_Interp swig_types[79]
#define SWIGTYPE_p_Term swig_types[80]
#define SWIGTYPE_p_TimingArc swig_types[81]
#define SWIGTYPE_p_TimingArcSet swig_types[82]
#define SWIGTYPE_p_TimingDerateCellType swig_types[83]
#define SWIGTYPE_p_TimingDerateType swig_types[84]
#define SWIGTYPE_p_TimingRole swig_types[85]
#define SWIGTYPE_p_Vertex swig_types[86]
#define SWIGTYPE_p_VertexInEdgeIterator swig_types[87]
#define SWIGTYPE_p_VertexIterator swig_types[88]
#define SWIGTYPE_p_VertexOutEdgeIterator swig_types[89]
#define SWIGTYPE_p_VertexPathIterator swig_types[90]
#define SWIGTYPE_p_Wireload swig_types[91]
#define SWIGTYPE_p_WireloadSelection swig_types[92]
#define SWIGTYPE_p_char swig_types[93]
static swig_type_info *swig_types[95];
static swig_module_info swig_module = {swig_types, 94, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Sta_Init
#define SWIG_name    "sta"
#define SWIG_prefix  "sta::"
#define SWIG_namespace "sta"

#define SWIG_version "0.0"

#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>



#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT int SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif

/* Compatibility version for TCL stubs */
#ifndef SWIG_TCL_STUBS_VERSION
#define SWIG_TCL_STUBS_VERSION "8.4"
#endif




#include "Machine.hh"
#include "StringUtil.hh"
#include "StringSet.hh"
#include "StringSeq.hh"
#include "PatternMatch.hh"
#include "Vector.hh"
#include "Network.hh"
#include "Liberty.hh"
#include "FuncExpr.hh"
#include "TimingArc.hh"
#include "TableModel.hh"
#include "TimingRole.hh"
#include "Graph.hh"
#include "NetworkClass.hh"
#include "Clock.hh"
#include "Corner.hh"
#include "Search.hh"
#include "PathRef.hh"
#include "search/Tag.hh"
#include "PathEnd.hh"
#include "SearchClass.hh"
#include "CircuitSim.hh"
#include "Property.hh"
#include "Sta.hh"
#include "TclTypeHelpers.hh"

namespace sta {

typedef MinPulseWidthCheckSeq::Iterator MinPulseWidthCheckSeqIterator;
typedef MinMaxAll MinMaxAllNull;

#if TCL_MAJOR_VERSION < 9
    typedef int Tcl_Size;
#endif

template <class TYPE>
Vector<TYPE> *
tclListSeqPtr(Tcl_Obj *const source,
              swig_type_info *swig_type,
              Tcl_Interp *interp)
{
  Tcl_Size argc;
  Tcl_Obj **argv;

  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    Vector<TYPE> *seq = new Vector<TYPE>;
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      seq->push_back(reinterpret_cast<TYPE>(obj));
    }
    return seq;
  }
  else
    return nullptr;
}

template <class TYPE>
std::vector<TYPE>
tclListSeq(Tcl_Obj *const source,
           swig_type_info *swig_type,
           Tcl_Interp *interp)
{
  Tcl_Size argc;
  Tcl_Obj **argv;

  std::vector<TYPE> seq;
  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      seq.push_back(reinterpret_cast<TYPE>(obj));
    }
  }
  return seq;
}

template <class SET_TYPE, class OBJECT_TYPE>
SET_TYPE *
tclListSetPtr(Tcl_Obj *const source,
              swig_type_info *swig_type,
              Tcl_Interp *interp)
{
  Tcl_Size argc;
  Tcl_Obj **argv;
  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    SET_TYPE *set = new SET_TYPE;
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      set->insert(reinterpret_cast<OBJECT_TYPE*>(obj));
    }
    return set;
  }
  else
    return nullptr;
}

template <class SET_TYPE, class OBJECT_TYPE>
SET_TYPE
tclListSet(Tcl_Obj *const source,
           swig_type_info *swig_type,
           Tcl_Interp *interp)
{
  Tcl_Size argc;
  Tcl_Obj **argv;
  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    SET_TYPE set;
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      set.insert(reinterpret_cast<OBJECT_TYPE>(obj));
    }
    return set;
  }
  else
    return SET_TYPE();
}

template <class SET_TYPE, class OBJECT_TYPE>
SET_TYPE *
tclListNetworkSet(Tcl_Obj *const source,
                  swig_type_info *swig_type,
                  Tcl_Interp *interp,
                  const Network *network)
{
  Tcl_Size argc;
  Tcl_Obj **argv;
  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    SET_TYPE *set = new SET_TYPE(network);
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      set->insert(reinterpret_cast<OBJECT_TYPE*>(obj));
    }
    return set;
  }
  else
    return nullptr;
}

template <class SET_TYPE, class OBJECT_TYPE>
SET_TYPE
tclListNetworkSet1(Tcl_Obj *const source,
                   swig_type_info *swig_type,
                   Tcl_Interp *interp,
                   const Network *network)
{
  Tcl_Size argc;
  Tcl_Obj **argv;
  SET_TYPE set(network);
  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      set.insert(reinterpret_cast<OBJECT_TYPE*>(obj));
    }
  }
  return set;
}

////////////////////////////////////////////////////////////////

// Sequence out to tcl list.
template <class SEQ_TYPE, class OBJECT_TYPE>
void
seqPtrTclList(SEQ_TYPE *seq,
              swig_type_info *swig_type,
              Tcl_Interp *interp)
{
  Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
  for (const OBJECT_TYPE *obj : *seq) {
    Tcl_Obj *tcl_obj = SWIG_NewInstanceObj(const_cast<OBJECT_TYPE*>(obj),
                                           swig_type, false);
    Tcl_ListObjAppendElement(interp, list, tcl_obj);
  }
  Tcl_SetObjResult(interp, list);
}

template <class SEQ_TYPE, class OBJECT_TYPE>
void
seqTclList(SEQ_TYPE &seq,
           swig_type_info *swig_type,
           Tcl_Interp *interp)
{
  Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
  for (const OBJECT_TYPE *obj : seq) {
    Tcl_Obj *tcl_obj = SWIG_NewInstanceObj(const_cast<OBJECT_TYPE*>(obj),
                                           swig_type, false);
    Tcl_ListObjAppendElement(interp, list, tcl_obj);
  }
  Tcl_SetObjResult(interp, list);
}

template <class SET_TYPE, class OBJECT_TYPE>
void
setTclList(SET_TYPE set,
           swig_type_info *swig_type,
           Tcl_Interp *interp)
{
  Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
  for (const OBJECT_TYPE *obj : set) {
    Tcl_Obj *tcl_obj = SWIG_NewInstanceObj(const_cast<OBJECT_TYPE*>(obj),
                                           swig_type, false);
    Tcl_ListObjAppendElement(interp, list, tcl_obj);
  }
  Tcl_SetObjResult(interp, list);
}

template <class SET_TYPE, class OBJECT_TYPE>
void
setPtrTclList(SET_TYPE *set,
              swig_type_info *swig_type,
              Tcl_Interp *interp)
{
  Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
  for (const OBJECT_TYPE *obj : *set) {
    Tcl_Obj *tcl_obj = SWIG_NewInstanceObj(const_cast<OBJECT_TYPE*>(obj),
                                           swig_type, false);
    Tcl_ListObjAppendElement(interp, list, tcl_obj);
  }
  Tcl_SetObjResult(interp, list);
}

////////////////////////////////////////////////////////////////

} // namespace

using namespace sta;




#include "DelayCalc.hh"
#include "ArcDelayCalc.hh"
#include "dcalc/ArcDcalcWaveforms.hh"
#include "dcalc/PrimaDelayCalc.hh"
#include "Sta.hh"




StringSeq
delay_calc_names()
{
  return sta::delayCalcNames();
}

bool
is_delay_calc_name(const char *alg)
{
  return sta::isDelayCalcName(alg);
}

void
set_delay_calculator_cmd(const char *alg)
{
  sta::Sta::sta()->setArcDelayCalc(alg);
}

void
set_delay_calc_incremental_tolerance(float tol)
{
  Sta::sta()->setIncrementalDelayTolerance(tol);
}

string
report_delay_calc_cmd(Edge *edge,
		      TimingArc *arc,
		      const Corner *corner,
		      const MinMax *min_max,
		      int digits)
{
  Sta *sta = Sta::sta();
  return sta->reportDelayCalc(edge, arc, corner, min_max, digits);
}

void
set_prima_reduce_order(size_t order)
{
  Sta *sta = Sta::sta();
  PrimaDelayCalc *dcalc = dynamic_cast<PrimaDelayCalc*>(sta->arcDelayCalc());
  if (dcalc) {
    dcalc->setPrimaReduceOrder(order);
    sta->delaysInvalid();
  }
}

void
find_delays()
{
  Sta::sta()->findDelays();
}

void
delays_invalid()
{
  Sta *sta = Sta::sta();
  sta->delaysInvalid();
}



SWIGINTERN int
SWIG_AsCharPtrAndSize(Tcl_Obj *obj, char** cptr, size_t* psize, int *alloc)
{ 
  int len = 0;
  char *cstr = Tcl_GetStringFromObj(obj, &len);
  if (cstr) {
    if (cptr)  *cptr = cstr;
    if (psize) *psize = len + 1;
    if (alloc) *alloc = SWIG_OLDOBJ;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}





  #define SWIG_From_bool   Tcl_NewBooleanObj 


#include <float.h>


#include <math.h>


/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined(__cplusplus) && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2))
#  define SWIG_isfinite(X) (__builtin_isfinite(X))
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_double SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, double *val)
{
  double v;
  if (Tcl_GetDoubleFromObj(0, obj, &v) == TCL_OK) {
    if (val) *val = v;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_float SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< float >(v);
    }
  }  
  return res;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, long* val)
{
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (val) *val = (long) v;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, unsigned long *val) {
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (v >= 0) {
      if (val) *val = (unsigned long) v;
      return SWIG_OK;
    }
    /* If v is negative, then this could be a negative number, or an
       unsigned value which doesn't fit in a signed long, so try to
       get it as a string so we can distinguish these cases. */
  }
  {
    int len = 0;
    const char *nptr = Tcl_GetStringFromObj(obj, &len);
    if (nptr && len > 0) {
      char *endptr;
      unsigned long v;
      if (*nptr == '-') return SWIG_OverflowError;
      errno = 0;
      v = strtoul(nptr, &endptr,0);
      if (nptr[0] == '\0' || *endptr != '\0')
	return SWIG_TypeError;
      if (v == ULONG_MAX && errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_OK;
	}
      }
    }
  }
  
  return SWIG_TypeError;
}


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, unsigned long long *val)
{
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (val) *val = (unsigned long) v;
    return SWIG_OK;
  } else {
    int len = 0;
    const char *nptr = Tcl_GetStringFromObj(obj, &len);
    if (nptr && len > 0) {
      char *endptr;
      unsigned long long v;
      if (*nptr == '-') return SWIG_OverflowError;
      errno = 0;
      v = strtoull(nptr, &endptr,0);
      if (nptr[0] == '\0' || *endptr != '\0')
	return SWIG_TypeError;
      if (v == ULLONG_MAX && errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_OK;
	}
      }
    }
  }
  return SWIG_TypeError;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long SWIG_TCL_CALL_ARGS_2(obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long SWIG_TCL_CALL_ARGS_2(obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}


#include "Graph.hh"
#include "FuncExpr.hh"
#include "TimingRole.hh"
#include "Liberty.hh"
#include "Network.hh"
#include "Clock.hh"
#include "Corner.hh"
#include "Search.hh"
#include "Sta.hh"

using namespace sta;


SWIGINTERN Pin *Vertex_pin(Vertex *self){ return self->pin(); }
SWIGINTERN bool Vertex_is_bidirect_driver(Vertex *self){ return self->isBidirectDriver(); }
SWIGINTERN int Vertex_level(Vertex *self){ return Sta::sta()->vertexLevel(self); }

SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_long  (long value)
{
  if (((long) INT_MIN <= value) && (value <= (long) INT_MAX)) {
    return Tcl_NewIntObj(static_cast< int >(value));
  } else {
    return Tcl_NewLongObj(value);
  }
}


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}

SWIGINTERN int Vertex_tag_group_index(Vertex *self){ return self->tagGroupIndex(); }
SWIGINTERN Slew Vertex_slew(Vertex *self,RiseFall const *rf,MinMax const *min_max){
  Sta *sta = Sta::sta();
  return sta->vertexSlew(self, rf, min_max);
}
SWIGINTERN Slew Vertex_slew_corner(Vertex *self,RiseFall const *rf,Corner const *corner,MinMax const *min_max){
  Sta *sta = Sta::sta();
  return sta->vertexSlew(self, rf, corner, min_max);
}
SWIGINTERN VertexOutEdgeIterator *Vertex_out_edge_iterator(Vertex *self){
  return new VertexOutEdgeIterator(self, Sta::sta()->graph());
}
SWIGINTERN VertexInEdgeIterator *Vertex_in_edge_iterator(Vertex *self){
  return new VertexInEdgeIterator(self, Sta::sta()->graph());
}
SWIGINTERN FloatSeq Vertex_arrivals_clk(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf){
  Sta *sta = Sta::sta();
  FloatSeq arrivals;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    arrivals.push_back(delayAsFloat(sta->vertexArrival(self, rf, clk_edge,
                                                       path_ap, nullptr)));
  }
  return arrivals;
}
SWIGINTERN StringSeq Vertex_arrivals_clk_delays(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf,int digits){
  Sta *sta = Sta::sta();
  StringSeq arrivals;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    arrivals.push_back(delayAsString(sta->vertexArrival(self, rf, clk_edge,
                                                        path_ap, nullptr),
                                     sta, digits));
  }
  return arrivals;
}
SWIGINTERN FloatSeq Vertex_requireds_clk(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf){
  Sta *sta = Sta::sta();
  FloatSeq reqs;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    reqs.push_back(delayAsFloat(sta->vertexRequired(self, rf, clk_edge,
                                                    path_ap)));
  }
  return reqs;
}
SWIGINTERN StringSeq Vertex_requireds_clk_delays(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf,int digits){
  Sta *sta = Sta::sta();
  StringSeq reqs;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    reqs.push_back(delayAsString(sta->vertexRequired(self, rf, clk_edge, path_ap),
                                 sta, digits));
  }
  return reqs;
}
SWIGINTERN Slack Vertex_slack(Vertex *self,MinMax *min_max){
  Sta *sta = Sta::sta();
  return sta->vertexSlack(self, min_max);
}
SWIGINTERN FloatSeq Vertex_slacks(Vertex *self,RiseFall *rf){
  Sta *sta = Sta::sta();
  FloatSeq slacks;
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    slacks.push_back(delayAsFloat(sta->vertexSlack(self, rf, path_ap)));
  }
  return slacks;
}
SWIGINTERN FloatSeq Vertex_slacks_clk(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf){
  Sta *sta = Sta::sta();
  FloatSeq slacks;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    slacks.push_back(delayAsFloat(sta->vertexSlack(self, rf, clk_edge,
                                                   path_ap)));
  }
  return slacks;
}
SWIGINTERN StringSeq Vertex_slacks_clk_delays(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf,int digits){
  Sta *sta = Sta::sta();
  StringSeq slacks;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    slacks.push_back(delayAsString(sta->vertexSlack(self, rf, clk_edge,
                                                    path_ap),
                                   sta, digits));
  }
  return slacks;
}
SWIGINTERN VertexPathIterator *Vertex_path_iterator(Vertex *self,RiseFall const *rf,MinMax const *min_max){
  return Sta::sta()->vertexPathIterator(self, rf, min_max);
}
SWIGINTERN bool Vertex_has_downstream_clk_pin(Vertex *self){
  return self->hasDownstreamClkPin();
}
SWIGINTERN bool Vertex_is_clock(Vertex *self){
  Sta *sta = Sta::sta();
  Search *search = sta->search();
  return search->isClock(self);
}
SWIGINTERN bool Vertex_is_disabled_constraint(Vertex *self){ return self->isDisabledConstraint(); }
SWIGINTERN Vertex *Edge_from(Edge *self){ return self->from(Sta::sta()->graph()); }
SWIGINTERN Vertex *Edge_to(Edge *self){ return self->to(Sta::sta()->graph()); }
SWIGINTERN Pin *Edge_from_pin(Edge *self){ return self->from(Sta::sta()->graph())->pin(); }
SWIGINTERN Pin *Edge_to_pin(Edge *self){ return self->to(Sta::sta()->graph())->pin(); }
SWIGINTERN TimingRole *Edge_role(Edge *self){ return self->role(); }
SWIGINTERN char const *Edge_sense(Edge *self){ return timingSenseString(self->sense()); }

SWIGINTERNINLINE Tcl_Obj *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  return (size < INT_MAX) ? Tcl_NewStringObj(carray, static_cast< int >(size)) : NULL;
}


SWIGINTERNINLINE Tcl_Obj * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}

SWIGINTERN TimingArcSeq &Edge_timing_arcs(Edge *self){ return self->timingArcSet()->arcs(); }
SWIGINTERN bool Edge_is_disabled_loop(Edge *self){ return Sta::sta()->isDisabledLoop(self); }
SWIGINTERN bool Edge_is_disabled_constraint(Edge *self){ return Sta::sta()->isDisabledConstraint(self);}
SWIGINTERN bool Edge_is_disabled_constant(Edge *self){ return Sta::sta()->isDisabledConstant(self); }
SWIGINTERN bool Edge_is_disabled_cond_default(Edge *self){ return Sta::sta()->isDisabledCondDefault(self); }
SWIGINTERN PinSet Edge_disabled_constant_pins(Edge *self){ return Sta::sta()->disabledConstantPins(self); }
SWIGINTERN bool Edge_is_disabled_bidirect_inst_path(Edge *self){ return Sta::sta()->isDisabledBidirectInstPath(self); }
SWIGINTERN bool Edge_is_disabled_bidirect_net_path(Edge *self){ return Sta::sta()->isDisabledBidirectNetPath(self); }
SWIGINTERN bool Edge_is_disabled_preset_clear(Edge *self){ return Sta::sta()->isDisabledPresetClr(self); }
SWIGINTERN char const *Edge_sim_timing_sense(Edge *self){return timingSenseString(Sta::sta()->simTimingSense(self));}
SWIGINTERN FloatSeq Edge_arc_delays(Edge *self,TimingArc *arc){
  Sta *sta = Sta::sta();
  FloatSeq delays;
  for (auto dcalc_ap : sta->corners()->dcalcAnalysisPts())
    delays.push_back(delayAsFloat(sta->arcDelay(self, arc, dcalc_ap)));
  return delays;
}
SWIGINTERN StringSeq Edge_arc_delay_strings(Edge *self,TimingArc *arc,int digits){
  Sta *sta = Sta::sta();
  StringSeq delays;
  for (auto dcalc_ap : sta->corners()->dcalcAnalysisPts())
    delays.push_back(delayAsString(sta->arcDelay(self, arc, dcalc_ap),
                                   sta, digits));
  return delays;
}
SWIGINTERN bool Edge_delay_annotated(Edge *self,TimingArc *arc,Corner const *corner,MinMax const *min_max){
  DcalcAnalysisPt *dcalc_ap = corner->findDcalcAnalysisPt(min_max);
  return Sta::sta()->arcDelayAnnotated(self, arc, dcalc_ap);
}
SWIGINTERN float Edge_arc_delay(Edge *self,TimingArc *arc,Corner const *corner,MinMax const *min_max){
  DcalcAnalysisPt *dcalc_ap = corner->findDcalcAnalysisPt(min_max);
  return delayAsFloat(Sta::sta()->arcDelay(self, arc, dcalc_ap));
}

  #define SWIG_From_double   Tcl_NewDoubleObj 


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}

SWIGINTERN char const *Edge_cond(Edge *self){
  FuncExpr *cond = self->timingArcSet()->cond();
  if (cond)
    return cond->asString();
  else
    return nullptr;
}
SWIGINTERN char const *Edge_mode_name(Edge *self){
  return self->timingArcSet()->modeName();
}
SWIGINTERN char const *Edge_mode_value(Edge *self){
  return self->timingArcSet()->modeValue();
}
SWIGINTERN char const *Edge_latch_d_to_q_en(Edge *self){
  if (self->role() == TimingRole::latchDtoQ()) {
    Sta *sta = Sta::sta();
    const Network *network = sta->network();
    const Graph *graph = sta->ensureGraph();
    Pin *from_pin = self->from(graph)->pin();
    Instance *inst = network->instance(from_pin);
    LibertyCell *lib_cell = network->libertyCell(inst);
    TimingArcSet *d_q_set = self->timingArcSet();
    const LibertyPort *enable_port;
    const FuncExpr *enable_func;
    const RiseFall *enable_rf;
    lib_cell->latchEnable(d_q_set, enable_port, enable_func, enable_rf);
    if (enable_port)
      return stringPrintTmp("%s %s", enable_port->name(), enable_rf->asString());
  }
  return "";
}
SWIGINTERN bool VertexIterator_has_next(VertexIterator *self){ return self->hasNext(); }
SWIGINTERN Vertex *VertexIterator_next(VertexIterator *self){ return self->next(); }
SWIGINTERN void VertexIterator_finish(VertexIterator *self){ delete self; }
SWIGINTERN bool VertexInEdgeIterator_has_next(VertexInEdgeIterator *self){ return self->hasNext(); }
SWIGINTERN Edge *VertexInEdgeIterator_next(VertexInEdgeIterator *self){ return self->next(); }
SWIGINTERN void VertexInEdgeIterator_finish(VertexInEdgeIterator *self){ delete self; }
SWIGINTERN bool VertexOutEdgeIterator_has_next(VertexOutEdgeIterator *self){ return self->hasNext(); }
SWIGINTERN Edge *VertexOutEdgeIterator_next(VertexOutEdgeIterator *self){ return self->next(); }
SWIGINTERN void VertexOutEdgeIterator_finish(VertexOutEdgeIterator *self){ delete self; }


VertexIterator *
vertex_iterator()
{
  Graph *graph = Sta::sta()->ensureGraph();
  return new VertexIterator(graph);
}

void
set_arc_delay(Edge *edge,
	      TimingArc *arc,
	      const Corner *corner,
	      const MinMaxAll *min_max,
	      float delay)
{
  Sta::sta()->setArcDelay(edge, arc, corner, min_max, delay);
}

void
set_annotated_slew(Vertex *vertex,
		   const Corner *corner,
		   const MinMaxAll *min_max,
		   const RiseFallBoth *rf,
		   float slew)
{
  Sta::sta()->setAnnotatedSlew(vertex, corner, min_max, rf, slew);
}

// Remove all delay and slew annotations.
void
remove_delay_slew_annotations()
{
  Sta::sta()->removeDelaySlewAnnotations();
}



#include "PortDirection.hh"
#include "Liberty.hh"
#include "EquivCells.hh"
#include "LibertyWriter.hh"
#include "Sta.hh"

using namespace sta;


SWIGINTERN char const *LibertyLibrary_name(LibertyLibrary *self){ return self->name(); }
SWIGINTERN LibertyCell *LibertyLibrary_find_liberty_cell(LibertyLibrary *self,char const *name){
  return self->findLibertyCell(name);
}

SWIGINTERN int
SWIG_AsVal_bool SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, bool *val)
{
  int v;
  if (Tcl_GetBooleanFromObj(0, obj, &v) == TCL_OK) {
    if (val) *val = v ? true : false;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}

SWIGINTERN LibertyCellSeq LibertyLibrary_find_liberty_cells_matching(LibertyLibrary *self,char const *pattern,bool regexp,bool nocase){
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  return self->findLibertyCellsMatching(&matcher);
}
SWIGINTERN Wireload *LibertyLibrary_find_wireload(LibertyLibrary *self,char const *model_name){
  return self->findWireload(model_name);
}
SWIGINTERN WireloadSelection *LibertyLibrary_find_wireload_selection(LibertyLibrary *self,char const *selection_name){
  return self->findWireloadSelection(selection_name);
}
SWIGINTERN OperatingConditions *LibertyLibrary_find_operating_conditions(LibertyLibrary *self,char const *op_cond_name){
  return self->findOperatingConditions(op_cond_name);
}
SWIGINTERN OperatingConditions *LibertyLibrary_default_operating_conditions(LibertyLibrary *self){
  return self->defaultOperatingConditions();
}
SWIGINTERN bool LibertyLibraryIterator_has_next(LibertyLibraryIterator *self){ return self->hasNext(); }
SWIGINTERN LibertyLibrary *LibertyLibraryIterator_next(LibertyLibraryIterator *self){ return self->next(); }
SWIGINTERN void LibertyLibraryIterator_finish(LibertyLibraryIterator *self){ delete self; }
SWIGINTERN char const *LibertyCell_name(LibertyCell *self){ return self->name(); }
SWIGINTERN bool LibertyCell_is_leaf(LibertyCell *self){ return self->isLeaf(); }
SWIGINTERN bool LibertyCell_is_buffer(LibertyCell *self){ return self->isBuffer(); }
SWIGINTERN bool LibertyCell_is_inverter(LibertyCell *self){ return self->isInverter(); }
SWIGINTERN LibertyLibrary *LibertyCell_liberty_library(LibertyCell *self){ return self->libertyLibrary(); }
SWIGINTERN Cell *LibertyCell_cell(LibertyCell *self){ return reinterpret_cast<Cell*>(self); }
SWIGINTERN LibertyPort *LibertyCell_find_liberty_port(LibertyCell *self,char const *name){
  return self->findLibertyPort(name);
}
SWIGINTERN LibertyPortSeq LibertyCell_find_liberty_ports_matching(LibertyCell *self,char const *pattern,bool regexp,bool nocase){
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  return self->findLibertyPortsMatching(&matcher);
}
SWIGINTERN LibertyCellPortIterator *LibertyCell_liberty_port_iterator(LibertyCell *self){ return new LibertyCellPortIterator(self); }
SWIGINTERN TimingArcSetSeq const &LibertyCell_timing_arc_sets(LibertyCell *self){
  return self->timingArcSets();
}
SWIGINTERN void LibertyCell_ensure_voltage_waveforms(LibertyCell *self){
  Corners *corners = Sta::sta()->corners();
  const DcalcAnalysisPtSeq &dcalc_aps = corners->dcalcAnalysisPts();
  self->ensureVoltageWaveforms(dcalc_aps);
}
SWIGINTERN LibertyCell *LibertyCell_test_cell(LibertyCell *self){ return self->testCell(); }
SWIGINTERN char const *LibertyPort_bus_name(LibertyPort *self){ return self->busName(); }
SWIGINTERN Cell *LibertyPort_cell(LibertyPort *self){ return self->cell(); }
SWIGINTERN bool LibertyPort_is_bus(LibertyPort *self){ return self->isBus(); }
SWIGINTERN LibertyPortMemberIterator *LibertyPort_member_iterator(LibertyPort *self){ return new LibertyPortMemberIterator(self); }
SWIGINTERN char const *LibertyPort_function(LibertyPort *self){
  FuncExpr *func = self->function();
  if (func)
    return func->asString();
  else
    return nullptr;
}
SWIGINTERN char const *LibertyPort_tristate_enable(LibertyPort *self){
  FuncExpr *enable = self->tristateEnable();
  if (enable)
    return enable->asString();
  else
    return nullptr;
}
SWIGINTERN float LibertyPort_capacitance(LibertyPort *self,Corner *corner,MinMax const *min_max){
  Sta *sta = Sta::sta();
  return sta->capacitance(self, corner, min_max);
}
SWIGINTERN void LibertyPort_set_direction(LibertyPort *self,char const *dir){
  self->setDirection(PortDirection::find(dir));
}
SWIGINTERN char const *LibertyPort_scan_signal_type(LibertyPort *self){
  return scanSignalTypeName(self->scanSignalType());
}
SWIGINTERN bool LibertyCellPortIterator_has_next(LibertyCellPortIterator *self){ return self->hasNext(); }
SWIGINTERN LibertyPort *LibertyCellPortIterator_next(LibertyCellPortIterator *self){ return self->next(); }
SWIGINTERN void LibertyCellPortIterator_finish(LibertyCellPortIterator *self){ delete self; }
SWIGINTERN bool LibertyPortMemberIterator_has_next(LibertyPortMemberIterator *self){ return self->hasNext(); }
SWIGINTERN LibertyPort *LibertyPortMemberIterator_next(LibertyPortMemberIterator *self){ return self->next(); }
SWIGINTERN void LibertyPortMemberIterator_finish(LibertyPortMemberIterator *self){ delete self; }
SWIGINTERN LibertyPort *TimingArcSet_from(TimingArcSet *self){ return self->from(); }
SWIGINTERN LibertyPort *TimingArcSet_to(TimingArcSet *self){ return self->to(); }
SWIGINTERN TimingRole *TimingArcSet_role(TimingArcSet *self){ return self->role(); }
SWIGINTERN char const *TimingArcSet_sdf_cond(TimingArcSet *self){ return self->sdfCond(); }
SWIGINTERN char const *TimingArcSet_full_name(TimingArcSet *self){
  const char *from = self->from()->name();
  const char *to = self->to()->name();
  const char *cell_name = self->libertyCell()->name();
  return stringPrintTmp("%s %s -> %s",
			cell_name,
			from,
			to);
}
SWIGINTERN TimingArcSeq &TimingArcSet_timing_arcs(TimingArcSet *self){ return self->arcs(); }
SWIGINTERN LibertyPort *TimingArc_from(TimingArc *self){ return self->from(); }
SWIGINTERN LibertyPort *TimingArc_to(TimingArc *self){ return self->to(); }
SWIGINTERN Transition *TimingArc_from_edge(TimingArc *self){ return self->fromEdge(); }
SWIGINTERN char const *TimingArc_from_edge_name(TimingArc *self){ return self->fromEdge()->asRiseFall()->name(); }
SWIGINTERN Transition *TimingArc_to_edge(TimingArc *self){ return self->toEdge(); }
SWIGINTERN char const *TimingArc_to_edge_name(TimingArc *self){ return self->toEdge()->asRiseFall()->name(); }
SWIGINTERN TimingRole *TimingArc_role(TimingArc *self){ return self->role(); }
SWIGINTERN float TimingArc_time_voltage(TimingArc *self,float in_slew,float load_cap,float time){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms)
      return waveforms->timeVoltage(in_slew, load_cap, time);
  }
  return 0.0;
}
SWIGINTERN float TimingArc_time_current(TimingArc *self,float in_slew,float load_cap,float time){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms)
      return waveforms->timeCurrent(in_slew, load_cap, time);
  }
  return 0.0;
}
SWIGINTERN float TimingArc_voltage_current(TimingArc *self,float in_slew,float load_cap,float voltage){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms)
      return waveforms->voltageCurrent(in_slew, load_cap, voltage);
  }
  return 0.0;
}
SWIGINTERN float TimingArc_voltage_time(TimingArc *self,float in_slew,float load_cap,float voltage){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms)
      return waveforms->voltageTime(in_slew, load_cap, voltage);
  }
  return 0.0;
}
SWIGINTERN Table1 TimingArc_voltage_waveform(TimingArc *self,float in_slew,float load_cap){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms) {
      Table1 waveform = waveforms->voltageWaveform(in_slew, load_cap);
      return waveform;
    }
  }
  return Table1();
}
SWIGINTERN Table1 const *TimingArc_voltage_waveform_raw(TimingArc *self,float in_slew,float load_cap){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms) {
      const Table1 *waveform = waveforms->voltageWaveformRaw(in_slew, load_cap);
      return waveform;
    }
  }
  return nullptr;
}
SWIGINTERN Table1 TimingArc_current_waveform(TimingArc *self,float in_slew,float load_cap){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms) {
      Table1 waveform = waveforms->currentWaveform(in_slew, load_cap);
      return waveform;
    }
  }
  return Table1();
}
SWIGINTERN Table1 const *TimingArc_current_waveform_raw(TimingArc *self,float in_slew,float load_cap){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms) {
      const Table1 *waveform = waveforms->currentWaveformRaw(in_slew, load_cap);
      return waveform;
    }
  }
  return nullptr;
}
SWIGINTERN Table1 TimingArc_voltage_current_waveform(TimingArc *self,float in_slew,float load_cap){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms) {
      Table1 waveform = waveforms->voltageCurrentWaveform(in_slew, load_cap);
      return waveform;
    }
  }
  return Table1();
}
SWIGINTERN float TimingArc_final_resistance(TimingArc *self){
  GateTableModel *gate_model = self->gateTableModel();
  if (gate_model) {
    OutputWaveforms *waveforms = gate_model->outputWaveforms();
    if (waveforms) {
      return waveforms->finalResistance();
    }
  }
  return 0.0;
}


bool
read_liberty_cmd(char *filename,
		 Corner *corner,
		 const MinMaxAll *min_max,
		 bool infer_latches)
{
  Sta *sta = Sta::sta();
  LibertyLibrary *lib = sta->readLiberty(filename, corner, min_max, infer_latches);
  return (lib != nullptr);
}

void
write_liberty_cmd(LibertyLibrary *library,
                  char *filename)
{
  writeLiberty(library, filename, Sta::sta());
}

void
make_equiv_cells(LibertyLibrary *lib)
{
  LibertyLibrarySeq libs;
  libs.push_back(lib);
  Sta::sta()->makeEquivCells(&libs, nullptr);
}

LibertyCellSeq *
find_equiv_cells(LibertyCell *cell)
{
  return Sta::sta()->equivCells(cell);
}

bool
equiv_cells(LibertyCell *cell1,
	    LibertyCell *cell2)
{
  return sta::equivCells(cell1, cell2);
}

bool
equiv_cell_ports(LibertyCell *cell1,
		 LibertyCell *cell2)
{
  return equivCellPorts(cell1, cell2);
}

bool
equiv_cell_timing_arcs(LibertyCell *cell1,
		       LibertyCell *cell2)
{
  return equivCellTimingArcSets(cell1, cell2);
}

LibertyCellSeq *
find_library_buffers(LibertyLibrary *library)
{
  return library->buffers();
}

const char *
liberty_port_direction(const LibertyPort *port)
{
  return port->direction()->name();
}
	     
bool
liberty_supply_exists(const char *supply_name)
{
  auto network = Sta::sta()->network();
  auto lib = network->defaultLibertyLibrary();
  return lib && lib->supplyExists(supply_name);
}

LibertyLibraryIterator *
liberty_library_iterator()
{
  return Sta::sta()->network()->libertyLibraryIterator();
}

LibertyLibrary *
find_liberty(const char *name)
{
  return Sta::sta()->network()->findLiberty(name);
}

LibertyCell *
find_liberty_cell(const char *name)
{
  return Sta::sta()->network()->findLibertyCell(name);
}

bool
timing_role_is_check(TimingRole *role)
{
  return role->isTimingCheck();
}



#include "Network.hh"

SWIGINTERN char const *Library_name(Library *self){
  return Sta::sta()->ensureLinked()->name(self);
}
SWIGINTERN Cell *Library_find_cell(Library *self,char const *name){
  return Sta::sta()->ensureLinked()->findCell(self, name);
}
SWIGINTERN CellSeq Library_find_cells_matching(Library *self,char const *pattern,bool regexp,bool nocase){
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  CellSeq matches = network->findCellsMatching(self, &matcher);
  return matches;
}
SWIGINTERN bool LibraryIterator_has_next(LibraryIterator *self){ return self->hasNext(); }
SWIGINTERN Library *LibraryIterator_next(LibraryIterator *self){ return self->next(); }
SWIGINTERN void LibraryIterator_finish(LibraryIterator *self){ delete self; }
SWIGINTERN char const *Cell_name(Cell *self){ return Sta::sta()->cmdNetwork()->name(self); }
SWIGINTERN Library *Cell_library(Cell *self){ return Sta::sta()->cmdNetwork()->library(self); }
SWIGINTERN LibertyCell *Cell_liberty_cell(Cell *self){ return Sta::sta()->cmdNetwork()->libertyCell(self); }
SWIGINTERN bool Cell_is_leaf(Cell *self){ return Sta::sta()->cmdNetwork()->isLeaf(self); }
SWIGINTERN CellPortIterator *Cell_port_iterator(Cell *self){ return Sta::sta()->cmdNetwork()->portIterator(self); }
SWIGINTERN string Cell_get_attribute(Cell *self,char const *key){
  return Sta::sta()->cmdNetwork()->getAttribute(self, key);
}
SWIGINTERN Port *Cell_find_port(Cell *self,char const *name){
  return Sta::sta()->ensureLinked()->findPort(self, name);
}
SWIGINTERN PortSeq Cell_find_ports_matching(Cell *self,char const *pattern,bool regexp,bool nocase){
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  return network->findPortsMatching(self, &matcher);
}
SWIGINTERN bool CellPortIterator_has_next(CellPortIterator *self){ return self->hasNext(); }
SWIGINTERN Port *CellPortIterator_next(CellPortIterator *self){ return self->next(); }
SWIGINTERN void CellPortIterator_finish(CellPortIterator *self){ delete self; }
SWIGINTERN char const *Port_bus_name(Port *self){ return Sta::sta()->ensureLinked()->busName(self); }
SWIGINTERN Cell *Port_cell(Port *self){ return Sta::sta()->ensureLinked()->cell(self); }
SWIGINTERN LibertyPort *Port_liberty_port(Port *self){ return Sta::sta()->ensureLibLinked()->libertyPort(self); }
SWIGINTERN bool Port_is_bus(Port *self){ return Sta::sta()->ensureLinked()->isBus(self); }
SWIGINTERN PortMemberIterator *Port_member_iterator(Port *self){ return Sta::sta()->ensureLinked()->memberIterator(self); }
SWIGINTERN bool PortMemberIterator_has_next(PortMemberIterator *self){ return self->hasNext(); }
SWIGINTERN Port *PortMemberIterator_next(PortMemberIterator *self){ return self->next(); }
SWIGINTERN void PortMemberIterator_finish(PortMemberIterator *self){ delete self; }
SWIGINTERN Instance *Instance_parent(Instance *self){ return Sta::sta()->ensureLinked()->parent(self); }
SWIGINTERN Cell *Instance_cell(Instance *self){ return Sta::sta()->ensureLinked()->cell(self); }
SWIGINTERN LibertyCell *Instance_liberty_cell(Instance *self){ return Sta::sta()->ensureLibLinked()->libertyCell(self); }
SWIGINTERN bool Instance_is_leaf(Instance *self){ return Sta::sta()->ensureLinked()->isLeaf(self); }
SWIGINTERN InstanceChildIterator *Instance_child_iterator(Instance *self){ return Sta::sta()->ensureLinked()->childIterator(self); }
SWIGINTERN InstancePinIterator *Instance_pin_iterator(Instance *self){ return Sta::sta()->ensureLinked()->pinIterator(self); }
SWIGINTERN InstanceNetIterator *Instance_net_iterator(Instance *self){ return Sta::sta()->ensureLinked()->netIterator(self); }
SWIGINTERN Pin *Instance_find_pin(Instance *self,char const *name){
  return Sta::sta()->ensureLinked()->findPin(self, name);
}
SWIGINTERN string Instance_get_attribute(Instance *self,char const *key){
  return Sta::sta()->ensureLinked()->getAttribute(self, key);
}
SWIGINTERN char const *Pin_port_name(Pin *self){ return Sta::sta()->ensureLinked()->portName(self); }
SWIGINTERN Instance *Pin_instance(Pin *self){ return Sta::sta()->ensureLinked()->instance(self); }
SWIGINTERN Net *Pin_net(Pin *self){ return Sta::sta()->ensureLinked()->net(self); }
SWIGINTERN Port *Pin_port(Pin *self){ return Sta::sta()->ensureLinked()->port(self); }
SWIGINTERN Term *Pin_term(Pin *self){ return Sta::sta()->ensureLinked()->term(self); }
SWIGINTERN LibertyPort *Pin_liberty_port(Pin *self){ return Sta::sta()->ensureLibLinked()->libertyPort(self); }
SWIGINTERN bool Pin_is_driver(Pin *self){ return Sta::sta()->ensureLinked()->isDriver(self); }
SWIGINTERN bool Pin_is_load(Pin *self){ return Sta::sta()->ensureLinked()->isLoad(self); }
SWIGINTERN bool Pin_is_leaf(Pin *self){ return Sta::sta()->ensureLinked()->isLeaf(self); }
SWIGINTERN bool Pin_is_hierarchical(Pin *self){ return Sta::sta()->ensureLinked()->isHierarchical(self); }
SWIGINTERN bool Pin_is_top_level_port(Pin *self){ return Sta::sta()->ensureLinked()->isTopLevelPort(self); }
SWIGINTERN PinConnectedPinIterator *Pin_connected_pin_iterator(Pin *self){ return Sta::sta()->ensureLinked()->connectedPinIterator(self); }
SWIGINTERN Vertex **Pin_vertices(Pin *self){
  Vertex *vertex, *vertex_bidirect_drvr;
  static Vertex *vertices[3];

  Graph *graph = Sta::sta()->ensureGraph();
  graph->pinVertices(self, vertex, vertex_bidirect_drvr);
  vertices[0] = vertex;
  vertices[1] = vertex_bidirect_drvr;
  vertices[2] = nullptr;
  return vertices;
}
SWIGINTERN Net *Term_net(Term *self){ return Sta::sta()->ensureLinked()->net(self); }
SWIGINTERN Pin *Term_pin(Term *self){ return Sta::sta()->ensureLinked()->pin(self); }
SWIGINTERN bool InstanceChildIterator_has_next(InstanceChildIterator *self){ return self->hasNext(); }
SWIGINTERN Instance *InstanceChildIterator_next(InstanceChildIterator *self){ return self->next(); }
SWIGINTERN void InstanceChildIterator_finish(InstanceChildIterator *self){ delete self; }
SWIGINTERN bool InstancePinIterator_has_next(InstancePinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin *InstancePinIterator_next(InstancePinIterator *self){ return self->next(); }
SWIGINTERN void InstancePinIterator_finish(InstancePinIterator *self){ delete self; }
SWIGINTERN bool InstanceNetIterator_has_next(InstanceNetIterator *self){ return self->hasNext(); }
SWIGINTERN Net *InstanceNetIterator_next(InstanceNetIterator *self){ return self->next(); }
SWIGINTERN void InstanceNetIterator_finish(InstanceNetIterator *self){ delete self; }
SWIGINTERN bool LeafInstanceIterator_has_next(LeafInstanceIterator *self){ return self->hasNext(); }
SWIGINTERN Instance *LeafInstanceIterator_next(LeafInstanceIterator *self){ return self->next(); }
SWIGINTERN void LeafInstanceIterator_finish(LeafInstanceIterator *self){ delete self; }
SWIGINTERN Instance *Net_instance(Net *self){ return Sta::sta()->ensureLinked()->instance(self); }
SWIGINTERN Net const *Net_highest_connected_net(Net *self){ return Sta::sta()->ensureLinked()->highestConnectedNet(self); }
SWIGINTERN NetPinIterator *Net_pin_iterator(Net *self){ return Sta::sta()->ensureLinked()->pinIterator(self);}
SWIGINTERN NetTermIterator *Net_term_iterator(Net *self){return Sta::sta()->ensureLinked()->termIterator(self);}
SWIGINTERN NetConnectedPinIterator *Net_connected_pin_iterator(Net *self){ return Sta::sta()->ensureLinked()->connectedPinIterator(self); }
SWIGINTERN bool Net_is_power(Net *self){ return Sta::sta()->ensureLinked()->isPower(self);}
SWIGINTERN bool Net_is_ground(Net *self){ return Sta::sta()->ensureLinked()->isGround(self);}
SWIGINTERN float Net_capacitance(Net *self,Corner *corner,MinMax const *min_max){
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  float pin_cap, wire_cap;
  sta->connectedCap(self, corner, min_max, pin_cap, wire_cap);
  return pin_cap + wire_cap;
}
SWIGINTERN float Net_pin_capacitance(Net *self,Corner *corner,MinMax const *min_max){
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  float pin_cap, wire_cap;
  sta->connectedCap(self, corner, min_max, pin_cap, wire_cap);
  return pin_cap;
}
SWIGINTERN float Net_wire_capacitance(Net *self,Corner *corner,MinMax const *min_max){
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  float pin_cap, wire_cap;
  sta->connectedCap(self, corner, min_max, pin_cap, wire_cap);
  return wire_cap;
}
SWIGINTERN PortSeq Net_ports(Net *self){
  Network *network = Sta::sta()->ensureLinked();
  PortSeq ports;
  if (network->isTopInstance(network->instance(self))) {
    NetTermIterator *term_iter = network->termIterator(self);
    while (term_iter->hasNext()) {
      Term *term = term_iter->next();
      Port *port = network->port(network->pin(term));
      ports.push_back(port);
    }
    delete term_iter;
  }
  return ports;
}
SWIGINTERN bool NetPinIterator_has_next(NetPinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin const *NetPinIterator_next(NetPinIterator *self){ return self->next(); }
SWIGINTERN void NetPinIterator_finish(NetPinIterator *self){ delete self; }
SWIGINTERN bool NetTermIterator_has_next(NetTermIterator *self){ return self->hasNext(); }
SWIGINTERN Term const *NetTermIterator_next(NetTermIterator *self){ return self->next(); }
SWIGINTERN void NetTermIterator_finish(NetTermIterator *self){ delete self; }
SWIGINTERN bool NetConnectedPinIterator_has_next(NetConnectedPinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin const *NetConnectedPinIterator_next(NetConnectedPinIterator *self){ return self->next(); }
SWIGINTERN void NetConnectedPinIterator_finish(NetConnectedPinIterator *self){ delete self; }
SWIGINTERN bool PinConnectedPinIterator_has_next(PinConnectedPinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin const *PinConnectedPinIterator_next(PinConnectedPinIterator *self){ return self->next(); }
SWIGINTERN void PinConnectedPinIterator_finish(PinConnectedPinIterator *self){ delete self; }


bool
network_is_linked()
{
  return Sta::sta()->network()->isLinked();
}

void
set_path_divider(char divider)
{
  Network *network = Sta::sta()->network();
  network->setPathDivider(divider);
}

void
set_current_instance(Instance *inst)
{
  Sta::sta()->setCurrentInstance(inst);
}

// Includes top instance.
int
network_instance_count()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->instanceCount();
}

int
network_pin_count()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->pinCount();
}

int
network_net_count()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->netCount();
}

int
network_leaf_instance_count()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->leafInstanceCount();
}

int
network_leaf_pin_count()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->leafPinCount();
}

Library *
find_library(const char *name)
{
  Network *network = Sta::sta()->ensureLinked();
  return network->findLibrary(name);
}

LibraryIterator *
library_iterator()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->libraryIterator();
}

CellSeq
find_cells_matching(const char *pattern,
		    bool regexp,
		    bool nocase)
{
  Network *network = Sta::sta()->ensureLinked();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  CellSeq matches;
  LibraryIterator *lib_iter = network->libraryIterator();
  while (lib_iter->hasNext()) {
    Library *lib = lib_iter->next();
    CellSeq lib_matches = network->findCellsMatching(lib, &matcher);
    for (Cell *match : lib_matches)
      matches.push_back(match);
  }
  delete lib_iter;
  return matches;
}

void
set_cmd_namespace_cmd(const char *namespc)
{
  Sta *sta = Sta::sta();
  if (stringEq(namespc, "sdc"))
    sta->setCmdNamespace(CmdNamespace::sdc);
  else if (stringEq(namespc, "sta"))
    sta->setCmdNamespace(CmdNamespace::sta);
  else
    sta->report()->warn(2120, "unknown namespace");
}

bool
link_design_cmd(const char *top_cell_name,
                bool make_black_boxes)
{
  return Sta::sta()->linkDesign(top_cell_name, make_black_boxes);
}

Instance *
top_instance()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->topInstance();
}

LeafInstanceIterator *
leaf_instance_iterator()
{
  Network *network = Sta::sta()->ensureLinked();
  return network->leafInstanceIterator();
}

const char *
port_direction(const Port *port)
{
  return Sta::sta()->ensureLinked()->direction(port)->name();
}
	     
const char *
pin_direction(const Pin *pin)
{
  return Sta::sta()->ensureLinked()->direction(pin)->name();
}

PortSeq
find_ports_matching(const char *pattern,
		    bool regexp,
		    bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  Cell *top_cell = network->cell(network->topInstance());
  PortSeq matches1 = network->findPortsMatching(top_cell, &matcher);
  // Expand bus/bundle ports.
  PortSeq matches;
  for (const Port *port : matches1) {
    if (network->isBus(port)
	|| network->isBundle(port)) {
      PortMemberIterator *member_iter = network->memberIterator(port);
      while (member_iter->hasNext()) {
	Port *member = member_iter->next();
	matches.push_back(member);
      }
      delete member_iter;
    }
    else
      matches.push_back(port);
  }
  return matches;
}

PinSeq
find_port_pins_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  Instance *top_inst = network->topInstance();
  Cell *top_cell = network->cell(top_inst);
  PortSeq ports = network->findPortsMatching(top_cell, &matcher);
  PinSeq pins;
  for (const Port *port : ports) {
    if (network->isBus(port)
	|| network->isBundle(port)) {
      PortMemberIterator *member_iter = network->memberIterator(port);
      while (member_iter->hasNext()) {
	Port *member = member_iter->next();
	Pin *pin = network->findPin(top_inst, member);
	if (pin)
	  pins.push_back(pin);
      }
      delete member_iter;
    }
    else {
      Pin *pin = network->findPin(top_inst, port);
      if (pin)
	pins.push_back(pin);
    }
  }
  return pins;
}

Pin *
find_pin(const char *path_name)
{
  Network *network = Sta::sta()->ensureLinked();
  return network->findPin(path_name);
}

Pin *
get_port_pin(const Port *port)
{
  Network *network = Sta::sta()->ensureLinked();
  return network->findPin(network->topInstance(), port);
}

PinSeq
find_pins_matching(const char *pattern,
		   bool regexp,
		   bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  Instance *current_instance = sta->currentInstance();
  PinSeq matches = network->findPinsMatching(current_instance, &matcher);
  return matches;
}

PinSeq
find_pins_hier_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  PinSeq matches = network->findPinsHierMatching(current_instance, &matcher);
  return matches;
}

Instance *
find_instance(char *path_name)
{
  return Sta::sta()->ensureLinked()->findInstance(path_name);
}

InstanceSeq
network_leaf_instances()
{
  return Sta::sta()->ensureLinked()->leafInstances();
}

InstanceSeq
find_instances_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  InstanceSeq matches = network->findInstancesMatching(current_instance, &matcher);
  return matches;
}

InstanceSeq
find_instances_hier_matching(const char *pattern,
			     bool regexp,
			     bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  InstanceSeq matches = network->findInstancesHierMatching(current_instance, &matcher);
  return matches;
}

InstanceSet
find_register_instances(ClockSet *clks,
			const RiseFallBoth *clk_tr,
			bool edge_triggered,
			bool latches)
{
  Sta *sta = Sta::sta();
  InstanceSet insts = sta->findRegisterInstances(clks, clk_tr,
                                                 edge_triggered,
                                                 latches);
  delete clks;
  return insts;
}

PinSet
find_register_data_pins(ClockSet *clks,
			const RiseFallBoth *clk_tr,
			bool edge_triggered,
			bool latches)
{
  Sta *sta = Sta::sta();
  PinSet pins = sta->findRegisterDataPins(clks, clk_tr,
                                          edge_triggered, latches);
  delete clks;
  return pins;
}

PinSet
find_register_clk_pins(ClockSet *clks,
		       const RiseFallBoth *clk_tr,
		       bool edge_triggered,
		       bool latches)
{
  Sta *sta = Sta::sta();
  PinSet pins = sta->findRegisterClkPins(clks, clk_tr,
                                         edge_triggered, latches);
  delete clks;
  return pins;
}

PinSet
find_register_async_pins(ClockSet *clks,
			 const RiseFallBoth *clk_tr,
			 bool edge_triggered,
			 bool latches)
{
  Sta *sta = Sta::sta();
  PinSet pins = sta->findRegisterAsyncPins(clks, clk_tr,
                                           edge_triggered, latches);
  delete clks;
  return pins;
}

PinSet
find_register_output_pins(ClockSet *clks,
			  const RiseFallBoth *clk_tr,
			  bool edge_triggered,
			  bool latches)
{
  Sta *sta = Sta::sta();
  PinSet pins = sta->findRegisterOutputPins(clks, clk_tr,
                                            edge_triggered, latches);
  delete clks;
  return pins;
}

Net *
find_net(char *path_name)
{
  return Sta::sta()->ensureLinked()->findNet(path_name);
}

NetSeq
find_nets_matching(const char *pattern,
		   bool regexp,
		   bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  NetSeq matches = network->findNetsMatching(current_instance, &matcher);
  return matches;
}

NetSeq
find_nets_hier_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = sta->ensureLinked();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  NetSeq matches = network->findNetsHierMatching(current_instance, &matcher);
  return matches;
}

PinSet
net_driver_pins(Net *net)
{
  Network *network = Sta::sta()->ensureLinked();
  PinSet pins(network);
  NetConnectedPinIterator *pin_iter = network->connectedPinIterator(net);
  while (pin_iter->hasNext()) {
    const Pin *pin = pin_iter->next();
    if (network->isDriver(pin))
      pins.insert(pin);
  }
  delete pin_iter;
  return pins;
}

PinSet
net_load_pins(Net *net)
{
  Network *network = Sta::sta()->ensureLinked();
  PinSet pins(network);
  NetConnectedPinIterator *pin_iter = network->connectedPinIterator(net);
  while (pin_iter->hasNext()) {
    const Pin *pin = pin_iter->next();
    if (network->isLoad(pin))
      pins.insert(pin);
  }
  delete pin_iter;
  return pins;
}

const char *
pin_location(const Pin *pin)
{
  Network *network = Sta::sta()->ensureLinked();
  double x, y;
  bool exists;
  network->location(pin, x, y, exists);
  // return x/y as tcl list
  if (exists)
    return sta::stringPrintTmp("%f %f", x, y);
  else
    return "";
}

const char *
port_location(const Port *port)
{
  Network *network = Sta::sta()->ensureLinked();
  const Pin *pin = network->findPin(network->topInstance(), port);
  return pin_location(pin);
}



SWIGINTERN int
SWIG_AsCharArray(Tcl_Obj * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


using sta::Cell;
using sta::Instance;
using sta::Net;
using sta::Port;
using sta::Pin;
using sta::NetworkEdit;




Instance *
make_instance_cmd(const char *name,
		  LibertyCell *cell,
		  Instance *parent)
{
  return Sta::sta()->makeInstance(name, cell, parent);
}

void
delete_instance_cmd(Instance *inst)
{
  Sta::sta()->deleteInstance(inst);
}

void
replace_cell_cmd(Instance *inst,
		 LibertyCell *to_cell)
{
  Sta::sta()->replaceCell(inst, to_cell);
}

Net *
make_net_cmd(const char *name,
	     Instance *parent)
{
  return Sta::sta()->makeNet(name, parent);
}

void
make_port_pin_cmd(const char *port_name,
                  PortDirection *dir)
{
  Sta::sta()->makePortPin(port_name, dir);
}

void
delete_net_cmd(Net *net)
{
  Sta::sta()->deleteNet(net);
}

void
connect_pin_cmd(Instance *inst,
		Port *port,
		Net *net)
{
  Sta::sta()->connectPin(inst, port, net);
}

void
disconnect_pin_cmd(Pin *pin)
{
  Sta::sta()->disconnectPin(pin);
}

// Notify STA of network change.
void
network_changed()
{
  Sta::sta()->networkChanged();
}



#include "Sta.hh"

using sta::Sta;
using sta::Instance;
using sta::MinMaxAll;
using sta::RiseFall;
using sta::Pin;




bool
read_spef_cmd(const char *filename,
	      Instance *instance,
	      const Corner *corner,
              const MinMaxAll *min_max,
	      bool pin_cap_included,
	      bool keep_coupling_caps,
	      float coupling_cap_factor,
	      bool reduce)
{
  return Sta::sta()->readSpef(filename, instance, corner, min_max,
			      pin_cap_included, keep_coupling_caps,
                              coupling_cap_factor, reduce);
}

void
report_parasitic_annotation_cmd(bool report_unannotated,
                                const Corner *corner)
{
  Sta::sta()->reportParasiticAnnotation(report_unannotated, corner);
}

FloatSeq
find_pi_elmore(Pin *drvr_pin,
	       RiseFall *rf,
	       MinMax *min_max)
{
  float c2, rpi, c1;
  bool exists;
  Sta::sta()->findPiElmore(drvr_pin, rf, min_max, c2, rpi, c1, exists);
  FloatSeq pi_elmore;
  if (exists) {
    pi_elmore.push_back(c2);
    pi_elmore.push_back(rpi);
    pi_elmore.push_back(c1);
  }
  return pi_elmore;
}

float
find_elmore(Pin *drvr_pin,
	    Pin *load_pin,
	    RiseFall *rf,
	    MinMax *min_max)
{
  float elmore = 0.0;
  bool exists;
  Sta::sta()->findElmore(drvr_pin, load_pin, rf, min_max, elmore, exists);
  return elmore;
}

void
set_pi_model_cmd(Pin *drvr_pin,
		 RiseFall *rf,
		 MinMaxAll *min_max,
		 float c2,
		 float rpi,
		 float c1)
{
  Sta::sta()->makePiElmore(drvr_pin, rf, min_max, c2, rpi, c1);
}

void
set_elmore_cmd(Pin *drvr_pin,
	       Pin *load_pin,
	       RiseFall *rf,
	       MinMaxAll *min_max,
	       float elmore)
{
  Sta::sta()->setElmore(drvr_pin, load_pin, rf, min_max, elmore);
}



#include "Sta.hh"
#include "Sdc.hh"
#include "power/Power.hh"
#include "power/VcdReader.hh"
#include "power/SaifReader.hh"

using namespace sta;




static void
pushPowerResultFloats(PowerResult &power,
		      FloatSeq &powers)
{
  powers.push_back(power.internal());
  powers.push_back(power.switching());
  powers.push_back(power.leakage());
  powers.push_back(power.total());
}

FloatSeq
design_power(const Corner *corner)
{
  PowerResult total, sequential, combinational, clock, macro, pad;
  Sta::sta()->power(corner, total, sequential, combinational, clock, macro, pad);
  FloatSeq powers;
  pushPowerResultFloats(total, powers);
  pushPowerResultFloats(sequential, powers);
  pushPowerResultFloats(combinational, powers);
  pushPowerResultFloats(clock, powers);
  pushPowerResultFloats(macro, powers);
  pushPowerResultFloats(pad, powers);
  return powers;
}

FloatSeq
instance_power(Instance *inst,
	       const Corner *corner)
{
  Sta *sta = Sta::sta();
  PowerResult power = sta->power(inst, corner);
  FloatSeq powers;
  powers.push_back(power.internal());
  powers.push_back(power.switching());
  powers.push_back(power.leakage());
  powers.push_back(power.total());
  return powers;
}

void
set_power_global_activity(float activity,
			  float duty)
{
  Power *power = Sta::sta()->power();
  power->setGlobalActivity(activity, duty);
}

void
set_power_input_activity(float activity,
			 float duty)
{
  Power *power = Sta::sta()->power();
  return power->setInputActivity(activity, duty);
}

void
set_power_input_port_activity(const Port *input_port,
			      float activity,
			      float duty)
{
  Power *power = Sta::sta()->power();
  return power->setInputPortActivity(input_port, activity, duty);
}

void
set_power_pin_activity(const Pin *pin,
		       float activity,
		       float duty)
{
  Power *power = Sta::sta()->power();
  return power->setUserActivity(pin, activity, duty, PwrActivityOrigin::user);
}

float
clock_min_period()
{
  Power *power = Sta::sta()->power();
  return power->clockMinPeriod();
}

InstanceSeq
highest_power_instances(size_t count,
                        const Corner *corner)
{
  Power *power = Sta::sta()->power();
  return power->highestPowerInstances(count, corner);
}

////////////////////////////////////////////////////////////////

void
read_vcd_file(const char *filename,
              const char *scope)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  readVcdActivities(filename, scope, sta);
}

////////////////////////////////////////////////////////////////

bool
read_saif_file(const char *filename,
               const char *scope)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  return readSaif(filename, scope, sta);
}

void
report_activity_annotation_cmd(bool report_unannotated,
                               bool report_annotated)
{
  Power *power = Sta::sta()->power();
  power->reportActivityAnnotation(report_unannotated,
                                  report_annotated);
}



#include "Sdc.hh"
#include "Wireload.hh"
#include "Clock.hh"
#include "PortDelay.hh"
#include "Property.hh"
#include "Sta.hh"

using namespace sta;


SWIGINTERN float Clock_period(Clock *self){ return self->period(); }
SWIGINTERN FloatSeq *Clock_waveform(Clock *self){ return self->waveform(); }
SWIGINTERN float Clock_time(Clock *self,RiseFall *rf){ return self->edge(rf)->time(); }
SWIGINTERN bool Clock_is_generated(Clock *self){ return self->isGenerated(); }
SWIGINTERN bool Clock_waveform_valid(Clock *self){ return self->waveformValid(); }
SWIGINTERN bool Clock_is_virtual(Clock *self){ return self->isVirtual(); }
SWIGINTERN bool Clock_is_propagated(Clock *self){ return self->isPropagated(); }
SWIGINTERN PinSet const &Clock_sources(Clock *self){ return self->pins(); }
SWIGINTERN float Clock_slew(Clock *self,RiseFall const *rf,MinMax const *min_max){
  return self->slew(rf, min_max);
}
SWIGINTERN Clock *ClockEdge_clock(ClockEdge *self){ return self->clock(); }
SWIGINTERN RiseFall *ClockEdge_transition(ClockEdge *self){ return self->transition(); }
SWIGINTERN float ClockEdge_time(ClockEdge *self){ return self->time(); }
SWIGINTERN float OperatingConditions_process(OperatingConditions *self){ return self->process(); }
SWIGINTERN float OperatingConditions_voltage(OperatingConditions *self){ return self->voltage(); }
SWIGINTERN float OperatingConditions_temperature(OperatingConditions *self){ return self->temperature(); }


void
write_sdc_cmd(const char *filename,
	      bool leaf,
	      bool compatible,
	      int digits,
              bool gzip,
	      bool no_timestamp)
{
  Sta::sta()->writeSdc(filename, leaf, compatible, digits, gzip, no_timestamp);
}

void
set_analysis_type_cmd(const char *analysis_type)
{
  AnalysisType type;
  if (stringEq(analysis_type, "single"))
    type = AnalysisType::single;
  else if (stringEq(analysis_type, "bc_wc"))
    type = AnalysisType::bc_wc;
  else if (stringEq(analysis_type, "on_chip_variation"))
    type = AnalysisType::ocv;
  else {
    Sta::sta()->report()->warn(2121, "unknown analysis type");
    type = AnalysisType::single;
  }
  Sta::sta()->setAnalysisType(type);
}

OperatingConditions *
operating_conditions(const MinMax *min_max)
{
  return Sta::sta()->operatingConditions(min_max);
}

void
set_operating_conditions_cmd(OperatingConditions *op_cond,
			     const MinMaxAll *min_max)
{
  Sta::sta()->setOperatingConditions(op_cond, min_max);
}

const char *
operating_condition_analysis_type()
{
  switch (Sta::sta()->sdc()->analysisType()){
  case AnalysisType::single:
    return "single";
  case AnalysisType::bc_wc:
    return "bc_wc";
  case AnalysisType::ocv:
    return "on_chip_variation";
  }
  // Prevent warnings from lame compilers.
  return "?";
}

void
set_instance_pvt(Instance *inst,
		 const MinMaxAll *min_max,
		 float process,
		 float voltage,
		 float temperature)
{
  Pvt pvt(process, voltage, temperature);
  Sta::sta()->setPvt(inst, min_max, pvt);
}

float
port_ext_pin_cap(const Port *port,
                 const Corner *corner,
		 const MinMax *min_max)
{
  float pin_cap, wire_cap;
  int fanout;
  Sta::sta()->portExtCaps(port, corner, min_max, pin_cap, wire_cap, fanout);
  return pin_cap;
}

void
set_port_ext_pin_cap(const Port *port,
                     const RiseFallBoth *rf,
                     const Corner *corner,
                     const MinMaxAll *min_max,
                     float cap)
{
  Sta::sta()->setPortExtPinCap(port, rf, corner, min_max, cap);
}

float
port_ext_wire_cap(const Port *port,
                  const Corner *corner,
                  const MinMax *min_max)
{
  float pin_cap, wire_cap;
  int fanout;
  Sta::sta()->portExtCaps(port, corner, min_max, pin_cap, wire_cap, fanout);
  return wire_cap;
}

void
set_port_ext_wire_cap(const Port *port,
                      bool subtract_pin_cap,
                      const RiseFallBoth *rf,
                      const Corner *corner,
                      const MinMaxAll *min_max,
                      float cap)
{
  Sta::sta()->setPortExtWireCap(port, subtract_pin_cap, rf, corner, min_max, cap);
}

void
set_port_ext_fanout_cmd(const Port *port,
			int fanout,
                        const Corner *corner,
			const MinMaxAll *min_max)
{
  Sta::sta()->setPortExtFanout(port, fanout, corner, min_max);
}

float
port_ext_fanout(const Port *port,
                const Corner *corner,
                const MinMax *min_max)
{
  float pin_cap, wire_cap;
  int fanout;
  Sta::sta()->portExtCaps(port, corner, min_max, pin_cap, wire_cap, fanout);
  return fanout;
}

void
set_net_wire_cap(const Net *net,
		 bool subtract_pin_cap,
		 const Corner *corner,
		 const MinMaxAll *min_max,
		 float cap)
{
  Sta::sta()->setNetWireCap(net, subtract_pin_cap, corner, min_max, cap);
}

void
set_wire_load_mode_cmd(const char *mode_name)
{
  WireloadMode mode = stringWireloadMode(mode_name);
  if (mode == WireloadMode::unknown)
    Sta::sta()->report()->warn(2122, "unknown wire load mode");
  else
    Sta::sta()->setWireloadMode(mode);
}

void
set_net_resistance(Net *net,
		   const MinMaxAll *min_max,
		   float res)
{
  Sta::sta()->setResistance(net, min_max, res);
}

void
set_wire_load_cmd(Wireload *wireload,
		  const MinMaxAll *min_max)
{
  Sta::sta()->setWireload(wireload, min_max);
}

void
set_wire_load_selection_group_cmd(WireloadSelection *selection,
				  const MinMaxAll *min_max)
{
  Sta::sta()->setWireloadSelection(selection, min_max);
}

void
make_clock(const char *name,
	   PinSet *pins,
	   bool add_to_pins,
	   float period,
	   FloatSeq *waveform,
	   char *comment)
{
  Sta::sta()->makeClock(name, pins, add_to_pins, period, waveform, comment);
}

void
make_generated_clock(const char *name,
		     PinSet *pins,
		     bool add_to_pins,
		     Pin *src_pin,
		     Clock *master_clk,
		     int divide_by,
		     int multiply_by,
		     float duty_cycle,
		     bool invert,
		     bool combinational,
		     IntSeq *edges,
		     FloatSeq *edge_shifts,
		     char *comment)
{
  Sta::sta()->makeGeneratedClock(name, pins, add_to_pins,
				 src_pin, master_clk,
				 divide_by, multiply_by, duty_cycle, invert,
				 combinational, edges, edge_shifts,
				 comment);
}

void
remove_clock_cmd(Clock *clk)
{
  Sta::sta()->removeClock(clk);
}

void
set_propagated_clock_cmd(Clock *clk)
{
  Sta::sta()->setPropagatedClock(clk);
}

void
set_propagated_clock_pin_cmd(Pin *pin)
{
  Sta::sta()->setPropagatedClock(pin);
}

void
unset_propagated_clock_cmd(Clock *clk)
{
  Sta::sta()->removePropagatedClock(clk);
}

void
unset_propagated_clock_pin_cmd(Pin *pin)
{
  Sta::sta()->removePropagatedClock(pin);
}

void
set_clock_slew_cmd(Clock *clk,
		   const RiseFallBoth *rf,
		   const MinMaxAll *min_max,
		   float slew)
{
  Sta::sta()->setClockSlew(clk, rf, min_max, slew);
}

void
unset_clock_slew_cmd(Clock *clk)
{
  Sta::sta()->removeClockSlew(clk);
}

void
set_clock_latency_cmd(Clock *clk,
		      Pin *pin,
		      const RiseFallBoth *rf,
		      MinMaxAll *min_max, float delay)
{
  Sta::sta()->setClockLatency(clk, pin, rf, min_max, delay);
}

void
set_clock_insertion_cmd(Clock *clk,
			Pin *pin,
			const RiseFallBoth *rf,
			const MinMaxAll *min_max,
			const EarlyLateAll *early_late,
			float delay)
{
  Sta::sta()->setClockInsertion(clk, pin, rf, min_max, early_late, delay);
}

void
unset_clock_latency_cmd(Clock *clk,
			Pin *pin)
{
  Sta::sta()->removeClockLatency(clk, pin);
}

void
unset_clock_insertion_cmd(Clock *clk,
			  Pin *pin)
{
  Sta::sta()->removeClockInsertion(clk, pin);
}

void
set_clock_uncertainty_clk(Clock *clk,
			  const SetupHoldAll *setup_hold,
			  float uncertainty)
{
  Sta::sta()->setClockUncertainty(clk, setup_hold, uncertainty);
}

void
unset_clock_uncertainty_clk(Clock *clk,
			    const SetupHoldAll *setup_hold)
{
  Sta::sta()->removeClockUncertainty(clk, setup_hold);
}

void
set_clock_uncertainty_pin(Pin *pin,
			  const MinMaxAll *min_max,
			  float uncertainty)
{
  Sta::sta()->setClockUncertainty(pin, min_max, uncertainty);
}

void
unset_clock_uncertainty_pin(Pin *pin,
			    const MinMaxAll *min_max)
{
  Sta::sta()->removeClockUncertainty(pin, min_max);
}

void
set_inter_clock_uncertainty(Clock *from_clk,
			    const RiseFallBoth *from_tr,
			    Clock *to_clk,
			    const RiseFallBoth *to_tr,
			    const MinMaxAll *min_max,
			    float uncertainty)
{
  Sta::sta()->setClockUncertainty(from_clk, from_tr, to_clk, to_tr, min_max,
				  uncertainty);
}

void
unset_inter_clock_uncertainty(Clock *from_clk,
			      const RiseFallBoth *from_tr,
			      Clock *to_clk,
			      const RiseFallBoth *to_tr,
			      const MinMaxAll *min_max)
{
  Sta::sta()->removeClockUncertainty(from_clk, from_tr, to_clk, to_tr, min_max);
}

void
set_clock_gating_check_cmd(const RiseFallBoth *rf,
			   const SetupHold *setup_hold,
			   float margin)
{
  Sta::sta()->setClockGatingCheck(rf, setup_hold, margin);
}

void
set_clock_gating_check_clk_cmd(Clock *clk,
			       const RiseFallBoth *rf,
			       const SetupHold *setup_hold,
			       float margin)
{
  Sta::sta()->setClockGatingCheck(clk, rf, setup_hold, margin);
}

void
set_clock_gating_check_pin_cmd(Pin *pin,
			       const RiseFallBoth *rf,
			       const SetupHold *setup_hold,
			       float margin,
			       LogicValue active_value)
{
  Sta::sta()->setClockGatingCheck(pin, rf, setup_hold, margin, active_value);
}

void
set_clock_gating_check_instance_cmd(Instance *inst,
				    const RiseFallBoth *rf,
				    const SetupHold *setup_hold,
				    float margin,
				    LogicValue active_value)
{
  Sta::sta()->setClockGatingCheck(inst, rf, setup_hold, margin, active_value);
}

void
set_data_check_cmd(Pin *from,
		   const RiseFallBoth *from_rf,
		   Pin *to,
		   const RiseFallBoth *to_rf,
		   Clock *clk,
		   const SetupHoldAll *setup_hold,
		   float margin)
{
  Sta::sta()->setDataCheck(from, from_rf, to, to_rf, clk, setup_hold, margin);
}

void
unset_data_check_cmd(Pin *from,
		     const RiseFallBoth *from_tr,
		     Pin *to,
		     const RiseFallBoth *to_tr,
		     Clock *clk,
		     const SetupHoldAll *setup_hold)
{
  Sta::sta()->removeDataCheck(from, from_tr, to, to_tr, clk, setup_hold);
}

void
set_input_delay_cmd(Pin *pin,
		    RiseFallBoth *rf,
		    Clock *clk,
		    RiseFall *clk_rf,
		    Pin *ref_pin,
		    bool source_latency_included,
		    bool network_latency_included,
		    MinMaxAll *min_max,
		    bool add,
		    float delay)
{
  Sta::sta()->setInputDelay(pin, rf, clk, clk_rf, ref_pin,
			    source_latency_included, network_latency_included,
			    min_max, add, delay);
}

void
unset_input_delay_cmd(Pin *pin,
		      RiseFallBoth *rf, 
		      Clock *clk,
		      RiseFall *clk_rf, 
		      MinMaxAll *min_max)
{
  Sta::sta()->removeInputDelay(pin, rf, clk, clk_rf, min_max);
}

void
set_output_delay_cmd(Pin *pin,
		     const RiseFallBoth *rf,
		     Clock *clk,
		     const RiseFall *clk_rf,
		     Pin *ref_pin,
		     bool source_latency_included,
		     bool network_latency_included,
		     const MinMaxAll *min_max,
		     bool add,
		     float delay)
{
  Sta::sta()->setOutputDelay(pin, rf, clk, clk_rf, ref_pin,
			     source_latency_included, network_latency_included,
			     min_max, add, delay);
}

void
unset_output_delay_cmd(Pin *pin,
		       RiseFallBoth *rf, 
		       Clock *clk,
		       RiseFall *clk_rf, 
		       MinMaxAll *min_max)
{
  Sta::sta()->removeOutputDelay(pin, rf, clk, clk_rf, min_max);
}

void
disable_cell(LibertyCell *cell,
	     LibertyPort *from,
	     LibertyPort *to)
{
  Sta::sta()->disable(cell, from, to);
}

void
unset_disable_cell(LibertyCell *cell,
		   LibertyPort *from,
		   LibertyPort *to)
{
  Sta::sta()->removeDisable(cell, from, to);
}

void
disable_lib_port(LibertyPort *port)
{
  Sta::sta()->disable(port);
}

void
unset_disable_lib_port(LibertyPort *port)
{
  Sta::sta()->removeDisable(port);
}

void
disable_port(Port *port)
{
  Sta::sta()->disable(port);
}

void
unset_disable_port(Port *port)
{
  Sta::sta()->removeDisable(port);
}

void
disable_instance(Instance *instance,
		 LibertyPort *from,
		 LibertyPort *to)
{
  Sta::sta()->disable(instance, from, to);
}

void
unset_disable_instance(Instance *instance,
		       LibertyPort *from,
		       LibertyPort *to)
{
  Sta::sta()->removeDisable(instance, from, to);
}

void
disable_pin(Pin *pin)
{
  Sta::sta()->disable(pin);
}

void
unset_disable_pin(Pin *pin)
{
  Sta::sta()->removeDisable(pin);
}

void
disable_edge(Edge *edge)
{
  Sta::sta()->disable(edge);
}

void
unset_disable_edge(Edge *edge)
{
  Sta::sta()->removeDisable(edge);
}

void
disable_timing_arc_set(TimingArcSet *arc_set)
{
  Sta::sta()->disable(arc_set);
}

void
unset_disable_timing_arc_set(TimingArcSet *arc_set)
{
  Sta::sta()->removeDisable(arc_set);
}

void
disable_clock_gating_check_inst(Instance *inst)
{
  Sta::sta()->disableClockGatingCheck(inst);
}

void
disable_clock_gating_check_pin(Pin *pin)
{
  Sta::sta()->disableClockGatingCheck(pin);
}

void
unset_disable_clock_gating_check_inst(Instance *inst)
{
  Sta::sta()->removeDisableClockGatingCheck(inst);
}

void
unset_disable_clock_gating_check_pin(Pin *pin)
{
  Sta::sta()->removeDisableClockGatingCheck(pin);
}

EdgeSeq
disabled_edges_sorted()
{
  return Sta::sta()->disabledEdgesSorted();
}

bool
timing_arc_disabled(Edge *edge,
		    TimingArc *arc)
{
  Graph *graph = Sta::sta()->graph();
  return !searchThru(edge, arc, graph);
}

void
make_false_path(ExceptionFrom *from,
		ExceptionThruSeq *thrus,
		ExceptionTo *to,
		const MinMaxAll *min_max,
		const char *comment)
{
  Sta::sta()->makeFalsePath(from, thrus, to, min_max, comment);
}

void
make_multicycle_path(ExceptionFrom *from,
		     ExceptionThruSeq *thrus,
		     ExceptionTo *to,
		     const MinMaxAll *min_max,
		     bool use_end_clk,
		     int path_multiplier,
		     const char *comment)
{
  Sta::sta()->makeMulticyclePath(from, thrus, to, min_max, use_end_clk,
				 path_multiplier, comment);
}

void
make_path_delay(ExceptionFrom *from,
		ExceptionThruSeq *thrus,
		ExceptionTo *to,
		const MinMax *min_max,
		bool ignore_clk_latency,
		float delay,
		const char *comment)
{
  Sta::sta()->makePathDelay(from, thrus, to, min_max, 
			    ignore_clk_latency, delay, comment);
}

void
reset_path_cmd(ExceptionFrom *
	       from, ExceptionThruSeq *thrus,
	       ExceptionTo *to,
	       const MinMaxAll *min_max)
{
  Sta::sta()->resetPath(from, thrus, to, min_max);
  // from/to and thru are owned and deleted by the caller.
  // ExceptionThruSeq thrus arg is made by TclListSeqExceptionThru
  // in the swig converter so it is deleted here.
  delete thrus;
}

void
make_group_path(const char *name,
		bool is_default,
		ExceptionFrom *from,
		ExceptionThruSeq *thrus,
		ExceptionTo *to,
		const char *comment)
{
  if (name[0] == '\0')
    name = nullptr;
  Sta::sta()->makeGroupPath(name, is_default, from, thrus, to, comment);
}

bool
is_path_group_name(const char *name)
{
  return Sta::sta()->isGroupPathName(name);
}

ExceptionFrom *
make_exception_from(PinSet *from_pins,
		    ClockSet *from_clks,
		    InstanceSet *from_insts,
		    const RiseFallBoth *from_tr)
{
  return Sta::sta()->makeExceptionFrom(from_pins, from_clks, from_insts,
				       from_tr);
}

void
delete_exception_from(ExceptionFrom *from)
{
  Sta::sta()->deleteExceptionFrom(from);
}

void
check_exception_from_pins(ExceptionFrom *from,
			  const char *file,
			  int line)
{
  Sta::sta()->checkExceptionFromPins(from, file, line);
}

ExceptionThru *
make_exception_thru(PinSet *pins,
		    NetSet *nets,
		    InstanceSet *insts,
		    const RiseFallBoth *rf)
{
  return Sta::sta()->makeExceptionThru(pins, nets, insts, rf);
}

void
delete_exception_thru(ExceptionThru *thru)
{
  Sta::sta()->deleteExceptionThru(thru);
}

ExceptionTo *
make_exception_to(PinSet *to_pins,
		  ClockSet *to_clks,
		  InstanceSet *to_insts,
		  const RiseFallBoth *rf,
 		  RiseFallBoth *end_rf)
{
  return Sta::sta()->makeExceptionTo(to_pins, to_clks, to_insts, rf, end_rf);
}

void
delete_exception_to(ExceptionTo *to)
{
  Sta::sta()->deleteExceptionTo(to);
}

void
check_exception_to_pins(ExceptionTo *to,
			const char *file,
			int line)
{
  Sta::sta()->checkExceptionToPins(to, file, line);
}

ClockGroups *
make_clock_groups(const char *name,
		  bool logically_exclusive,
		  bool physically_exclusive,
		  bool asynchronous,
		  bool allow_paths,
		  const char *comment)
{
  return Sta::sta()->makeClockGroups(name, logically_exclusive,
				     physically_exclusive, asynchronous,
				     allow_paths, comment);
}

void
clock_groups_make_group(ClockGroups *clk_groups,
			ClockSet *clks)
{
  Sta::sta()->makeClockGroup(clk_groups, clks);
}

void
unset_clock_groups_logically_exclusive(const char *name)
{
  Sta::sta()->removeClockGroupsLogicallyExclusive(name);
}

void
unset_clock_groups_physically_exclusive(const char *name)
{
  Sta::sta()->removeClockGroupsPhysicallyExclusive(name);
}

void
unset_clock_groups_asynchronous(const char *name)
{
  Sta::sta()->removeClockGroupsAsynchronous(name);
}

// Debugging function.
bool
same_clk_group(Clock *clk1,
	       Clock *clk2)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  return sdc->sameClockGroupExplicit(clk1, clk2);
}

void
set_clock_sense_cmd(PinSet *pins,
		    ClockSet *clks,
		    bool positive,
		    bool negative,
		    bool stop_propagation)
{
  Sta *sta = Sta::sta();
  if (positive)
    sta->setClockSense(pins, clks, ClockSense::positive);
  else if (negative)
    sta->setClockSense(pins, clks, ClockSense::negative);
  else if (stop_propagation)
    sta->setClockSense(pins, clks, ClockSense::stop);
  else
    sta->report()->critical(1577, "unknown clock sense");
}

void
set_input_slew_cmd(Port *port,
		   const RiseFallBoth *rf,
		   const MinMaxAll *min_max,
		   float slew)
{
  Sta::sta()->setInputSlew(port, rf, min_max, slew);
}

void
set_drive_cell_cmd(LibertyLibrary *library,
		   LibertyCell *cell,
		   Port *port,
		   LibertyPort *from_port,
		   float from_slew_rise,
		   float from_slew_fall,
		   LibertyPort *to_port,
		   const RiseFallBoth *rf,
		   const MinMaxAll *min_max)
{
  float from_slews[RiseFall::index_count];
  from_slews[RiseFall::riseIndex()] = from_slew_rise;
  from_slews[RiseFall::fallIndex()] = from_slew_fall;
  Sta::sta()->setDriveCell(library, cell, port, from_port, from_slews,
			   to_port, rf, min_max);
}

void
set_drive_resistance_cmd(Port *port,
			 const RiseFallBoth *rf,
			 const MinMaxAll *min_max,
			 float res)
{
  Sta::sta()->setDriveResistance(port, rf, min_max, res);
}

void
set_slew_limit_clk(Clock *clk,
		   const RiseFallBoth *rf,
		   PathClkOrData clk_data,
		   const MinMax *min_max,
		   float slew)
{
  Sta::sta()->setSlewLimit(clk, rf, clk_data, min_max, slew);
}

void
set_slew_limit_port(Port *port,
		    const MinMax *min_max,
		    float slew)
{
  Sta::sta()->setSlewLimit(port, min_max, slew);
}

void
set_slew_limit_cell(Cell *cell,
		    const MinMax *min_max,
		    float slew)
{
  Sta::sta()->setSlewLimit(cell, min_max, slew);
}

void
set_port_capacitance_limit(Port *port,
			   const MinMax *min_max,
			   float cap)
{
  Sta::sta()->setCapacitanceLimit(port, min_max, cap);
}

void
set_pin_capacitance_limit(Pin *pin,
			  const MinMax *min_max,
			  float cap)
{
  Sta::sta()->setCapacitanceLimit(pin, min_max, cap);
}

void
set_cell_capacitance_limit(Cell *cell,
			   const MinMax *min_max,
			   float cap)
{
  Sta::sta()->setCapacitanceLimit(cell, min_max, cap);
}

void
set_latch_borrow_limit_pin(Pin *pin,
			   float limit)
{
  Sta::sta()->setLatchBorrowLimit(pin, limit);
}

void
set_latch_borrow_limit_inst(Instance *inst,
			    float limit)
{
  Sta::sta()->setLatchBorrowLimit(inst, limit);
}

void
set_latch_borrow_limit_clk(Clock *clk, float limit)
{
  Sta::sta()->setLatchBorrowLimit(clk, limit);
}

void
set_min_pulse_width_global(const RiseFallBoth *rf,
			   float min_width)
{
  Sta::sta()->setMinPulseWidth(rf, min_width);
}

void
set_min_pulse_width_pin(Pin *pin,
			const RiseFallBoth *rf,
			float min_width)
{
  Sta::sta()->setMinPulseWidth(pin, rf, min_width);
}

void
set_min_pulse_width_clk(Clock *clk,
			const RiseFallBoth *rf,
			float min_width)
{
  Sta::sta()->setMinPulseWidth(clk, rf, min_width);
}

void
set_min_pulse_width_inst(Instance *inst,
			 const RiseFallBoth *rf,
			 float min_width)
{
  Sta::sta()->setMinPulseWidth(inst, rf, min_width);
}

void
set_max_area_cmd(float area)
{
  Sta::sta()->setMaxArea(area);
}

void
set_port_fanout_limit(Port *port,
		      const MinMax *min_max,
		      float fanout)
{
  Sta::sta()->setFanoutLimit(port, min_max, fanout);
}

void
set_cell_fanout_limit(Cell *cell,
		      const MinMax *min_max,
		      float fanout)
{
  Sta::sta()->setFanoutLimit(cell, min_max, fanout);
}

void
set_logic_value_cmd(Pin *pin,
		    LogicValue value)
{
  Sta::sta()->setLogicValue(pin, value);
}

void
set_case_analysis_cmd(Pin *pin,
		      LogicValue value)
{
  Sta::sta()->setCaseAnalysis(pin, value);
}

void
unset_case_analysis_cmd(Pin *pin)
{
  Sta::sta()->removeCaseAnalysis(pin);
}

void
set_timing_derate_cmd(TimingDerateType type,
		      PathClkOrData clk_data,
		      const RiseFallBoth *rf,
		      const EarlyLate *early_late,
		      float derate)
{
  Sta::sta()->setTimingDerate(type, clk_data, rf, early_late, derate);
}

void
set_timing_derate_net_cmd(const Net *net,
			  PathClkOrData clk_data,
			  const RiseFallBoth *rf,
			  const EarlyLate *early_late,
			  float derate)
{
  Sta::sta()->setTimingDerate(net, clk_data, rf, early_late, derate);
}

void
set_timing_derate_inst_cmd(const Instance *inst,
			   TimingDerateCellType type,
			   PathClkOrData clk_data,
			   const RiseFallBoth *rf,
			   const EarlyLate *early_late,
			   float derate)
{
  Sta::sta()->setTimingDerate(inst, type, clk_data, rf, early_late, derate);
}

void
set_timing_derate_cell_cmd(const LibertyCell *cell,
			   TimingDerateCellType type,
			   PathClkOrData clk_data,
			   const RiseFallBoth *rf,
			   const EarlyLate *early_late,
			   float derate)
{
  Sta::sta()->setTimingDerate(cell, type, clk_data, rf, early_late, derate);
}

void
unset_timing_derate_cmd()
{
  Sta::sta()->unsetTimingDerate();
}

Clock *
find_clock(const char *name)
{
  return Sta::sta()->sdc()->findClock(name);
}

bool
is_clock_src(const Pin *pin)
{
  return Sta::sta()->isClockSrc(pin);
}

Clock *
default_arrival_clock()
{
  return Sta::sta()->sdc()->defaultArrivalClock();
}

ClockSeq
find_clocks_matching(const char *pattern,
		     bool regexp,
		     bool nocase)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  return sdc->findClocksMatching(&matcher);
}

void
update_generated_clks()
{
  Sta::sta()->updateGeneratedClks();
}

bool
is_clock(Pin *pin)
{
  return Sta::sta()->isClock(pin);
}

bool
is_ideal_clock(Pin *pin)
{
  return Sta::sta()->isIdealClock(pin);
}

bool
is_clock_search(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Graph *graph = sta->graph();
  Search *search = sta->search();
  Vertex *vertex, *bidirect_drvr_vertex;
  graph->pinVertices(pin, vertex, bidirect_drvr_vertex);
  return search->isClock(vertex);
}

bool
is_genclk_src(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Graph *graph = sta->graph();
  Search *search = sta->search();
  Vertex *vertex, *bidirect_drvr_vertex;
  graph->pinVertices(pin, vertex, bidirect_drvr_vertex);
  return search->isGenClkSrc(vertex);
}

bool
pin_is_constrained(Pin *pin)
{
  return Sta::sta()->sdc()->isConstrained(pin);
}

bool
instance_is_constrained(Instance *inst)
{
  return Sta::sta()->sdc()->isConstrained(inst);
}

bool
net_is_constrained(Net *net)
{
  return Sta::sta()->sdc()->isConstrained(net);
}

bool
clk_thru_tristate_enabled()
{
  return Sta::sta()->clkThruTristateEnabled();
}

void
set_clk_thru_tristate_enabled(bool enabled)
{
  Sta::sta()->setClkThruTristateEnabled(enabled);
}

void
remove_constraints()
{
  Sta::sta()->removeConstraints();
}

PortSeq
all_inputs_cmd(bool no_clocks)
{
  Sta *sta = Sta::sta();
  sta->ensureLinked();
  return sta->sdc()->allInputs(no_clocks);
}

PortSeq
all_outputs_cmd()
{
  Sta *sta = Sta::sta();
  sta->ensureLinked();
  return sta->sdc()->allOutputs();
}

template <typename T> Vector<T*>
filter_objects(const char *property,
	       const char *op,
	       const char *pattern,
	       Vector<T*> *objects)
{
  Vector<T*> filtered_objects;
  if (objects) {
    Sta *sta = Sta::sta();
    bool exact_match = stringEq(op, "==");
    bool pattern_match = stringEq(op, "=~");
    bool not_match = stringEq(op, "!=");
    bool not_pattern_match = stringEq(op, "!~");
    for (T *object : *objects) {
      PropertyValue value(getProperty(object, property, sta));
      const char *prop = value.asString(sta->network());
      if (prop &&
          ((exact_match && stringEq(prop, pattern))
           || (not_match && !stringEq(prop, pattern))
           || (pattern_match && patternMatch(pattern, prop))
           || (not_pattern_match && !patternMatch(pattern, prop))))
        filtered_objects.push_back(object);
    }
    delete objects;
  }
  return filtered_objects;
}

PortSeq
filter_ports(const char *property,
	     const char *op,
	     const char *pattern,
	     PortSeq *ports)
{
  return filter_objects<const Port>(property, op, pattern, ports);
}

InstanceSeq
filter_insts(const char *property,
	     const char *op,
	     const char *pattern,
	     InstanceSeq *insts)
{
  return filter_objects<const Instance>(property, op, pattern, insts);
}

PinSeq
filter_pins(const char *property,
	    const char *op,
	    const char *pattern,
	    PinSeq *pins)
{
  return filter_objects<const Pin>(property, op, pattern, pins);
}

ClockSeq
filter_clocks(const char *property,
	      const char *op,
	      const char *pattern,
	      ClockSeq *clocks)
{
  return filter_objects<Clock>(property, op, pattern, clocks);
}

LibertyCellSeq
filter_lib_cells(const char *property,
		 const char *op,
		 const char *pattern,
		 LibertyCellSeq *cells)
{
  return filter_objects<LibertyCell>(property, op, pattern, cells);
}

LibertyPortSeq
filter_lib_pins(const char *property,
		const char *op,
		const char *pattern,
		LibertyPortSeq *pins)
{
  return filter_objects<LibertyPort>(property, op, pattern, pins);
}

LibertyLibrarySeq
filter_liberty_libraries(const char *property,
			 const char *op,
			 const char *pattern,
			 LibertyLibrarySeq *libs)
{
  return filter_objects<LibertyLibrary>(property, op, pattern, libs);
}

NetSeq
filter_nets(const char *property,
	    const char *op,
	    const char *pattern,
	    NetSeq *nets)
{
  return filter_objects<const Net>(property, op, pattern, nets);
}

EdgeSeq
filter_timing_arcs(const char *property,
		   const char *op,
		   const char *pattern,
		   EdgeSeq *edges)
{
  return filter_objects<Edge>(property, op, pattern, edges);
}

////////////////////////////////////////////////////////////////

StringSeq
path_group_names()
{
  StringSeq pg_names;
  for (auto const& [name, group] : Sta::sta()->sdc()->groupPaths())
    pg_names.push_back(name);
  return pg_names;
}

////////////////////////////////////////////////////////////////

void
set_voltage_global(const MinMax *min_max,
                   float voltage)
{
  Sta::sta()->setVoltage(min_max, voltage);
}

void
set_voltage_net(const Net *net,
                const MinMax *min_max,
                float voltage)
{
  Sta::sta()->setVoltage(net, min_max, voltage);
}

////////////////////////////////////////////////////////////////

PinSet
group_path_pins(const char *group_path_name)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  if (sdc->isGroupPathName(group_path_name))
    return sta->findGroupPathPins(group_path_name);
  else
    return PinSet(sta->network());
}

////////////////////////////////////////////////////////////////

char
pin_case_logic_value(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  LogicValue value = LogicValue::unknown;
  bool exists;
  sdc->caseLogicValue(pin, value, exists);
  return logicValueString(value);
}

char
pin_logic_value(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  LogicValue value = LogicValue::unknown;
  bool exists;
  sdc->logicValue(pin, value, exists);
  return logicValueString(value);
}

////////////////////////////////////////////////////////////////
//
// Variables
//
////////////////////////////////////////////////////////////////

bool
propagate_all_clocks()
{
  return Sta::sta()->propagateAllClocks();
}

void
set_propagate_all_clocks(bool prop)
{
  Sta::sta()->setPropagateAllClocks(prop);
}



SWIGINTERNINLINE Tcl_Obj *
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


#include "sdf/SdfReader.hh"
#include "sdf/ReportAnnotation.hh"
#include "sdf/SdfWriter.hh"
#include "Search.hh"
#include "Sta.hh"

using sta::Sta;
using sta::AnalysisType;
using sta::MinMax;
using sta::MinMaxAllNull;
using sta::stringEq;
using sta::readSdf;
using sta::reportAnnotatedDelay;
using sta::reportAnnotatedCheck;




// If unescaped_dividers is true path names do not have to escape
// hierarchy dividers when the path name is quoted.
// For example verilog "\mod1/mod2 " can be referenced as "mod1/mod2"
// instead of the correct "mod1\/mod2".

// Return true if successful.
bool
read_sdf_file(const char *filename,
              const char *path,
              Corner *corner,
              bool unescaped_dividers,
              bool incremental_only,
              MinMaxAllNull *cond_use)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  sta->ensureGraph();
  if (stringEq(path, ""))
    path = NULL;
  bool success = readSdf(filename, path, corner, unescaped_dividers, incremental_only,
                         cond_use, sta);
  sta->search()->arrivalsInvalid();
  return success;
}

void
report_annotated_delay_cmd(bool report_cells,
			   bool report_nets,
			   bool report_in_ports,
			   bool report_out_ports,
			   unsigned max_lines,
			   bool list_annotated,
			   bool list_not_annotated,
			   bool report_constant_arcs)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  sta->ensureGraph();
  reportAnnotatedDelay(report_cells, report_nets,
		       report_in_ports, report_out_ports,
		       max_lines, list_annotated, list_not_annotated,
		       report_constant_arcs, sta);
}

void
report_annotated_check_cmd(bool report_setup,
			   bool report_hold,
			   bool report_recovery,
			   bool report_removal,
			   bool report_nochange,
			   bool report_width,
			   bool report_period,
			   bool report_max_skew,
			   unsigned max_lines,
			   bool list_annotated,
			   bool list_not_annotated,
			   bool report_constant_arcs)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  sta->ensureGraph();
  reportAnnotatedCheck(report_setup, report_hold,
		       report_recovery, report_removal,
		       report_nochange, report_width,
		       report_period,  report_max_skew,
		       max_lines, list_annotated, list_not_annotated,
		       report_constant_arcs, sta);
}

void
write_sdf_cmd(char *filename,
	      Corner *corner,
	      char divider,
	      bool include_typ,
              int digits,
	      bool gzip,
	      bool no_timestamp,
	      bool no_version)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  sta->writeSdf(filename, corner, divider, include_typ, digits, gzip,
		no_timestamp, no_version);
}



SWIGINTERN int
SWIG_AsVal_unsigned_SS_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long SWIG_TCL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}



#include "Units.hh"
#include "PathGroup.hh"
#include "Search.hh"
#include "search/Levelize.hh"
#include "search/ReportPath.hh"
#include "Sta.hh"

using namespace sta;


SWIGINTERN bool VertexPathIterator_has_next(VertexPathIterator *self){ return self->hasNext(); }
SWIGINTERN PathRef *VertexPathIterator_next(VertexPathIterator *self){
  Path *path = self->next();
  return new PathRef(path);
}
SWIGINTERN void VertexPathIterator_finish(VertexPathIterator *self){ delete self; }
SWIGINTERN float PathRef_arrival(PathRef *self){
  Sta *sta = Sta::sta();
  return delayAsFloat(self->arrival(sta));
}
SWIGINTERN float PathRef_required(PathRef *self){
  Sta *sta = Sta::sta();
  return delayAsFloat(self->required(sta));
}
SWIGINTERN float PathRef_slack(PathRef *self){
  Sta *sta = Sta::sta();
  return delayAsFloat(self->slack(sta));
}
SWIGINTERN Pin const *PathRef_pin(PathRef *self){
  Sta *sta = Sta::sta();
  return self->pin(sta);
}
SWIGINTERN char const *PathRef_tag(PathRef *self){
  Sta *sta = Sta::sta();
  return self->tag(sta)->asString(sta);
}
SWIGINTERN PinSeq PathRef_pins(PathRef *self){
  Sta *sta = Sta::sta();
  PinSeq pins;
  PathRef path1(self);
  while (!path1.isNull()) {
    pins.push_back(path1.vertex(sta)->pin());
    PathRef prev_path;
    path1.prevPath(sta, prev_path);
    path1.init(prev_path);
  }
  return pins;
}
SWIGINTERN bool PathEnd_is_unconstrained(PathEnd *self){ return self->isUnconstrained(); }
SWIGINTERN bool PathEnd_is_check(PathEnd *self){ return self->isCheck(); }
SWIGINTERN bool PathEnd_is_latch_check(PathEnd *self){ return self->isLatchCheck(); }
SWIGINTERN bool PathEnd_is_data_check(PathEnd *self){ return self->isDataCheck(); }
SWIGINTERN bool PathEnd_is_output_delay(PathEnd *self){ return self->isOutputDelay(); }
SWIGINTERN bool PathEnd_is_path_delay(PathEnd *self){ return self->isPathDelay(); }
SWIGINTERN bool PathEnd_is_gated_clock(PathEnd *self){ return self->isGatedClock(); }
SWIGINTERN Vertex *PathEnd_vertex(PathEnd *self){ return self->vertex(Sta::sta()); }
SWIGINTERN PathRef *PathEnd_path(PathEnd *self){ return &self->pathRef(); }
SWIGINTERN RiseFall *PathEnd_end_transition(PathEnd *self){ return const_cast<RiseFall*>(self->path()->transition(Sta::sta())); }
SWIGINTERN Slack PathEnd_slack(PathEnd *self){ return self->slack(Sta::sta()); }
SWIGINTERN ArcDelay PathEnd_margin(PathEnd *self){ return self->margin(Sta::sta()); }
SWIGINTERN Required PathEnd_data_required_time(PathEnd *self){ return self->requiredTimeOffset(Sta::sta()); }
SWIGINTERN Arrival PathEnd_data_arrival_time(PathEnd *self){ return self->dataArrivalTimeOffset(Sta::sta()); }
SWIGINTERN TimingRole *PathEnd_check_role(PathEnd *self){ return self->checkRole(Sta::sta()); }
SWIGINTERN MinMax *PathEnd_min_max(PathEnd *self){ return const_cast<MinMax*>(self->minMax(Sta::sta())); }
SWIGINTERN float PathEnd_source_clk_offset(PathEnd *self){ return self->sourceClkOffset(Sta::sta()); }
SWIGINTERN Arrival PathEnd_source_clk_latency(PathEnd *self){ return self->sourceClkLatency(Sta::sta()); }
SWIGINTERN Arrival PathEnd_source_clk_insertion_delay(PathEnd *self){ return self->sourceClkInsertionDelay(Sta::sta()); }
SWIGINTERN Clock const *PathEnd_target_clk(PathEnd *self){ return self->targetClk(Sta::sta()); }
SWIGINTERN ClockEdge const *PathEnd_target_clk_edge(PathEnd *self){ return self->targetClkEdge(Sta::sta()); }
SWIGINTERN Path *PathEnd_target_clk_path(PathEnd *self){ return self->targetClkPath(); }
SWIGINTERN float PathEnd_target_clk_time(PathEnd *self){ return self->targetClkTime(Sta::sta()); }
SWIGINTERN float PathEnd_target_clk_offset(PathEnd *self){ return self->targetClkOffset(Sta::sta()); }
SWIGINTERN float PathEnd_target_clk_mcp_adjustment(PathEnd *self){ return self->targetClkMcpAdjustment(Sta::sta()); }
SWIGINTERN Arrival PathEnd_target_clk_delay(PathEnd *self){ return self->targetClkDelay(Sta::sta()); }
SWIGINTERN Arrival PathEnd_target_clk_insertion_delay(PathEnd *self){ return self->targetClkInsertionDelay(Sta::sta()); }
SWIGINTERN float PathEnd_target_clk_uncertainty(PathEnd *self){ return self->targetNonInterClkUncertainty(Sta::sta()); }
SWIGINTERN float PathEnd_inter_clk_uncertainty(PathEnd *self){ return self->interClkUncertainty(Sta::sta()); }
SWIGINTERN Arrival PathEnd_target_clk_arrival(PathEnd *self){ return self->targetClkArrival(Sta::sta()); }
SWIGINTERN bool PathEnd_path_delay_margin_is_external(PathEnd *self){ return self->pathDelayMarginIsExternal();}
SWIGINTERN Crpr PathEnd_check_crpr(PathEnd *self){ return self->checkCrpr(Sta::sta()); }
SWIGINTERN RiseFall *PathEnd_target_clk_end_trans(PathEnd *self){ return const_cast<RiseFall*>(self->targetClkEndTrans(Sta::sta())); }
SWIGINTERN Delay PathEnd_clk_skew(PathEnd *self){ return self->clkSkew(Sta::sta()); }
SWIGINTERN bool MinPulseWidthCheckSeqIterator_has_next(MinPulseWidthCheckSeqIterator *self){ return self->hasNext(); }
SWIGINTERN MinPulseWidthCheck *MinPulseWidthCheckSeqIterator_next(MinPulseWidthCheckSeqIterator *self){ return self->next(); }
SWIGINTERN void MinPulseWidthCheckSeqIterator_finish(MinPulseWidthCheckSeqIterator *self){ delete self; }
SWIGINTERN char const *Corner_name(Corner *self){ return self->name(); }


int group_path_count_max = PathGroup::group_path_count_max;

////////////////////////////////////////////////////////////////

// Initialize sta after delete_all_memory.
void
init_sta()
{
  initSta();
}

// Clear all state except network.
void
clear_sta()
{
  Sta::sta()->clear();
}

void
make_sta(Tcl_Interp *interp)
{
  Sta *sta = new Sta;
  Sta::setSta(sta);
  sta->makeComponents();
  sta->setTclInterp(interp);
}

Tcl_Interp *
tcl_interp()
{
  return Sta::sta()->tclInterp();
}

void
clear_network()
{
  Sta *sta = Sta::sta();
  sta->network()->clear();
}

void
delete_all_memory()
{
  deleteAllMemory();
}

////////////////////////////////////////////////////////////////

void
find_timing_cmd(bool full)
{
  Sta::sta()->updateTiming(full);
}

void
arrivals_invalid()
{
  Sta *sta = Sta::sta();
  sta->arrivalsInvalid();
}

PinSet
startpoints()
{
  return Sta::sta()->startpointPins();
}

PinSet
endpoints()
{
  return Sta::sta()->endpointPins();
}

size_t
endpoint_path_count()
{
  return Sta::sta()->endpointPins().size();
}

void
find_requireds()
{
  Sta::sta()->findRequireds();
}

Slack
total_negative_slack_cmd(const MinMax *min_max)
{
  return Sta::sta()->totalNegativeSlack(min_max);
}

Slack
total_negative_slack_corner_cmd(const Corner *corner,
				const MinMax *min_max)
{
  return Sta::sta()->totalNegativeSlack(corner, min_max);
}

Slack
worst_slack_cmd(const MinMax *min_max)
{
  Slack worst_slack;
  Vertex *worst_vertex;
  Sta::sta()->worstSlack(min_max, worst_slack, worst_vertex);
  return worst_slack;
}

Vertex *
worst_slack_vertex(const MinMax *min_max)
{
  Slack worst_slack;
  Vertex *worst_vertex;
  Sta::sta()->worstSlack(min_max, worst_slack, worst_vertex);
  return worst_vertex;;
}

Slack
worst_slack_corner(const Corner *corner,
		   const MinMax *min_max)
{
  Slack worst_slack;
  Vertex *worst_vertex;
  Sta::sta()->worstSlack(corner, min_max, worst_slack, worst_vertex);
  return worst_slack;
}

PathRef *
vertex_worst_arrival_path(Vertex *vertex,
			  const MinMax *min_max)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  PathRef path = sta->vertexWorstArrivalPath(vertex, min_max);
  if (!path.isNull())
    return new PathRef(path);
  else
    return nullptr;
}

PathRef *
vertex_worst_arrival_path_rf(Vertex *vertex,
			     const RiseFall *rf,
			     MinMax *min_max)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  PathRef path = sta->vertexWorstArrivalPath(vertex, rf, min_max);
  if (!path.isNull())
    return new PathRef(path);
  else
    return nullptr;
}

PathRef *
vertex_worst_slack_path(Vertex *vertex,
			const MinMax *min_max)
{
  Sta *sta = Sta::sta();
  sta->ensureLibLinked();
  PathRef path = sta->vertexWorstSlackPath(vertex, min_max);
  if (!path.isNull())
    return new PathRef(path);
  else
    return nullptr;
}

int
tag_group_path_count()
{
  return Sta::sta()->tagGroupCount();
}

void
report_tag_groups()
{
  Sta::sta()->search()->reportTagGroups();
}

void
report_tag_arrivals_cmd(Vertex *vertex)
{
  Sta::sta()->search()->reportArrivals(vertex);
}

void
report_arrival_count_histogram()
{
  Sta::sta()->search()->reportArrivalCountHistogram();
}

int
tag_count()
{
  return Sta::sta()->tagCount();
}

void
report_tags()
{
  Sta::sta()->search()->reportTags();
}

void
report_clk_infos()
{
  Sta::sta()->search()->reportClkInfos();
}

int
clk_info_count()
{
  return Sta::sta()->clkInfoCount();
}

int
arrival_count()
{
  return Sta::sta()->arrivalCount();
}

int
required_count()
{
  return Sta::sta()->requiredCount();
}

int
endpoint_violation_count(const MinMax *min_max)
{
  return  Sta::sta()->endpointViolationCount(min_max);
}

void
report_loops()
{
  Sta *sta = Sta::sta();
  Network *network = sta->network();
  Graph *graph = sta->ensureGraph();
  Report *report = sta->report();
  for (GraphLoop *loop : *sta->graphLoops()) {
    loop->report(report, network, graph);
    report->reportLineString("");
  }
}

char
pin_sim_logic_value(const Pin *pin)
{
  return logicValueString(Sta::sta()->simLogicValue(pin));
}

InstanceSeq
slow_drivers(int count)
{
  return Sta::sta()->slowDrivers(count);
}

////////////////////////////////////////////////////////////////

PathEndSeq
find_path_ends(ExceptionFrom *from,
	       ExceptionThruSeq *thrus,
	       ExceptionTo *to,
	       bool unconstrained,
	       Corner *corner,
	       const MinMaxAll *delay_min_max,
	       int group_path_count,
	       int endpoint_path_count,
	       bool unique_pins,
	       float slack_min,
	       float slack_max,
	       bool sort_by_slack,
	       PathGroupNameSet *groups,
	       bool setup,
	       bool hold,
	       bool recovery,
	       bool removal,
	       bool clk_gating_setup,
	       bool clk_gating_hold)
{
  Sta *sta = Sta::sta();
  PathEndSeq ends = sta->findPathEnds(from, thrus, to, unconstrained,
                                      corner, delay_min_max,
                                      group_path_count, endpoint_path_count,
				      unique_pins,
                                      slack_min, slack_max,
                                      sort_by_slack,
                                      groups->size() ? groups : nullptr,
                                      setup, hold,
                                      recovery, removal,
                                      clk_gating_setup, clk_gating_hold);
  delete groups;
  return ends;
}

////////////////////////////////////////////////////////////////

void
report_path_end_header()
{
  Sta::sta()->reportPathEndHeader();
}

void
report_path_end_footer()
{
  Sta::sta()->reportPathEndFooter();
}

void
report_path_end(PathEnd *end)
{
  Sta::sta()->reportPathEnd(end);
}

void
report_path_end2(PathEnd *end,
		 PathEnd *prev_end,
                 bool last)
{
  Sta::sta()->reportPathEnd(end, prev_end, last);
}

void
set_report_path_format(ReportPathFormat format)
{
  Sta::sta()->setReportPathFormat(format);
}
    
void
set_report_path_field_order(StringSeq *field_names)
{
  Sta::sta()->setReportPathFieldOrder(field_names);
  delete field_names;
}

void
set_report_path_fields(bool report_input_pin,
                       bool report_hier_pins,
		       bool report_net,
		       bool report_cap,
		       bool report_slew,
		       bool report_fanout,
		       bool report_src_attr)
{
  Sta::sta()->setReportPathFields(report_input_pin,
                                  report_hier_pins,
				  report_net,
				  report_cap,
				  report_slew,
				  report_fanout,
				  report_src_attr);
}

void
set_report_path_field_properties(const char *field_name,
				 const char *title,
				 int width,
				 bool left_justify)
{
  Sta *sta = Sta::sta();
  ReportField *field = sta->findReportPathField(field_name);
  if (field)
    field->setProperties(title, width, left_justify);
  else
    sta->report()->warn(1575, "unknown report path field %s", field_name);
}

void
set_report_path_field_width(const char *field_name,
			    int width)
{
  Sta *sta = Sta::sta();
  ReportField *field = sta->findReportPathField(field_name);
  if (field)
    field->setWidth(width);
  else
    sta->report()->warn(1576, "unknown report path field %s", field_name);
}

void
set_report_path_digits(int digits)
{
  Sta::sta()->setReportPathDigits(digits);
}

void
set_report_path_no_split(bool no_split)
{
  Sta::sta()->setReportPathNoSplit(no_split);
}

void
set_report_path_sigmas(bool report_sigmas)
{
  Sta::sta()->setReportPathSigmas(report_sigmas);
}

void
delete_path_ref(PathRef *path)
{
  delete path;
}

void
report_path_cmd(PathRef *path)
{
  Sta::sta()->reportPath(path);
}

void
report_path_ends(PathEndSeq *ends)
{
  Sta::sta()->reportPathEnds(ends);
  delete ends;
}

////////////////////////////////////////////////////////////////

void
report_clk_skew(ConstClockSeq clks,
		const Corner *corner,
		const SetupHold *setup_hold,
                bool include_internal_latency,
		int digits)
{
  Sta::sta()->reportClkSkew(clks, corner, setup_hold,
                            include_internal_latency, digits);
}

void
report_clk_latency(ConstClockSeq clks,
                   const Corner *corner,
                   bool include_internal_latency,
                   int digits)
{
  Sta::sta()->reportClkLatency(clks, corner, include_internal_latency, digits);
}

float
worst_clk_skew_cmd(const SetupHold *setup_hold,
                   bool include_internal_latency)
{
  return Sta::sta()->findWorstClkSkew(setup_hold, include_internal_latency);
}

////////////////////////////////////////////////////////////////

MinPulseWidthCheckSeq &
min_pulse_width_violations(const Corner *corner)
{
  return Sta::sta()->minPulseWidthViolations(corner);
}

MinPulseWidthCheckSeq &
min_pulse_width_check_pins(PinSeq *pins,
			   const Corner *corner)
{
  Sta *sta = Sta::sta();
  MinPulseWidthCheckSeq &checks = sta->minPulseWidthChecks(pins, corner);
  delete pins;
  return checks;
}

MinPulseWidthCheckSeq &
min_pulse_width_checks(const Corner *corner)
{
  return Sta::sta()->minPulseWidthChecks(corner);
}

MinPulseWidthCheck *
min_pulse_width_check_slack(const Corner *corner)
{
  return Sta::sta()->minPulseWidthSlack(corner);
}

void
report_mpw_checks(MinPulseWidthCheckSeq *checks,
		  bool verbose)
{
  Sta::sta()->reportMpwChecks(checks, verbose);
}

void
report_mpw_check(MinPulseWidthCheck *check,
		 bool verbose)
{
  Sta::sta()->reportMpwCheck(check, verbose);
}

////////////////////////////////////////////////////////////////

MinPeriodCheckSeq &
min_period_violations()
{
  return Sta::sta()->minPeriodViolations();
}

MinPeriodCheck *
min_period_check_slack()
{
  return Sta::sta()->minPeriodSlack();
}

void
report_min_period_checks(MinPeriodCheckSeq *checks,
			 bool verbose)
{
  Sta::sta()->reportChecks(checks, verbose);
}

void
report_min_period_check(MinPeriodCheck *check,
			bool verbose)
{
  Sta::sta()->reportCheck(check, verbose);
}

////////////////////////////////////////////////////////////////

MaxSkewCheckSeq &
max_skew_violations()
{
  return Sta::sta()->maxSkewViolations();
}

MaxSkewCheck *
max_skew_check_slack()
{
  return Sta::sta()->maxSkewSlack();
}

void
report_max_skew_checks(MaxSkewCheckSeq *checks,
		       bool verbose)
{
  Sta::sta()->reportChecks(checks, verbose);
}

void
report_max_skew_check(MaxSkewCheck *check,
		      bool verbose)
{
  Sta::sta()->reportCheck(check, verbose);
}

////////////////////////////////////////////////////////////////

Slack
find_clk_min_period(const Clock *clk,
                    bool ignore_port_paths)
{
  return Sta::sta()->findClkMinPeriod(clk, ignore_port_paths);
}

////////////////////////////////////////////////////////////////

PinSeq
check_slew_limits(Net *net,
                  bool violators,
                  const Corner *corner,
                  const MinMax *min_max)
{
  return Sta::sta()->checkSlewLimits(net, violators, corner, min_max);
}

size_t
max_slew_violation_count()
{
  return Sta::sta()->checkSlewLimits(nullptr, true, nullptr, MinMax::max()).size();
}

float
max_slew_check_slack()
{
  Sta *sta = Sta::sta();
  const Pin *pin;
  Slew slew;
  float slack;
  float limit;
  sta->maxSlewCheck(pin, slew, slack, limit);
  return sta->units()->timeUnit()->staToUser(slack);
}

float
max_slew_check_limit()
{
  Sta *sta = Sta::sta();
  const Pin *pin;
  Slew slew;
  float slack;
  float limit;
  sta->maxSlewCheck(pin, slew, slack, limit);
  return sta->units()->timeUnit()->staToUser(limit);
}

void
report_slew_limit_short_header()
{
  Sta::sta()->reportSlewLimitShortHeader();
}

void
report_slew_limit_short(Pin *pin,
			const Corner *corner,
			const MinMax *min_max)
{
  Sta::sta()->reportSlewLimitShort(pin, corner, min_max);
}

void
report_slew_limit_verbose(Pin *pin,
			  const Corner *corner,
			  const MinMax *min_max)
{
  Sta::sta()->reportSlewLimitVerbose(pin, corner, min_max);
}

////////////////////////////////////////////////////////////////

PinSeq
check_fanout_limits(Net *net,
                    bool violators,
                    const MinMax *min_max)
{
  return Sta::sta()->checkFanoutLimits(net, violators, min_max);
}

size_t
max_fanout_violation_count()
{
  return Sta::sta()->checkFanoutLimits(nullptr, true, MinMax::max()).size();
}

float
max_fanout_check_slack()
{
  Sta *sta = Sta::sta();
  const Pin *pin;
  float fanout;
  float slack;
  float limit;
  sta->maxFanoutCheck(pin, fanout, slack, limit);
  return slack;;
}

float
max_fanout_check_limit()
{
  Sta *sta = Sta::sta();
  const Pin *pin;
  float fanout;
  float slack;
  float limit;
  sta->maxFanoutCheck(pin, fanout, slack, limit);
  return limit;;
}

void
report_fanout_limit_short_header()
{
  Sta::sta()->reportFanoutLimitShortHeader();
}

void
report_fanout_limit_short(Pin *pin,
			  const MinMax *min_max)
{
  Sta::sta()->reportFanoutLimitShort(pin, min_max);
}

void
report_fanout_limit_verbose(Pin *pin,
			    const MinMax *min_max)
{
  Sta::sta()->reportFanoutLimitVerbose(pin, min_max);
}

////////////////////////////////////////////////////////////////

PinSeq
check_capacitance_limits(Net *net,
                         bool violators,
                         const Corner *corner,
                         const MinMax *min_max)
{
  return Sta::sta()->checkCapacitanceLimits(net, violators, corner, min_max);
}

size_t
max_capacitance_violation_count()
{
  return Sta::sta()->checkCapacitanceLimits(nullptr, true,nullptr,MinMax::max()).size();
}

float
max_capacitance_check_slack()
{
  Sta *sta = Sta::sta();
  const Pin *pin;
  float capacitance;
  float slack;
  float limit;
  sta->maxCapacitanceCheck(pin, capacitance, slack, limit);
  return sta->units()->capacitanceUnit()->staToUser(slack);
}

float
max_capacitance_check_limit()
{
  Sta *sta = Sta::sta();
  const Pin *pin;
  float capacitance;
  float slack;
  float limit;
  sta->maxCapacitanceCheck(pin, capacitance, slack, limit);
  return sta->units()->capacitanceUnit()->staToUser(limit);
}

void
report_capacitance_limit_short_header()
{
  Sta::sta()->reportCapacitanceLimitShortHeader();
}

void
report_capacitance_limit_short(Pin *pin,
			       const Corner *corner,
			       const MinMax *min_max)
{
  Sta::sta()->reportCapacitanceLimitShort(pin, corner, min_max);
}

void
report_capacitance_limit_verbose(Pin *pin,
				 const Corner *corner,
				 const MinMax *min_max)
{
  Sta::sta()->reportCapacitanceLimitVerbose(pin, corner, min_max);
}

////////////////////////////////////////////////////////////////

void
write_timing_model_cmd(const char *lib_name,
                       const char *cell_name,
                       const char *filename,
                       const Corner *corner)
{
  Sta::sta()->writeTimingModel(lib_name, cell_name, filename, corner);
}

////////////////////////////////////////////////////////////////

void
define_corners_cmd(StringSet *corner_names)
{
  Sta *sta = Sta::sta();
  sta->makeCorners(corner_names);
  delete corner_names;
}

Corner *
cmd_corner()
{
  return Sta::sta()->cmdCorner();
}

void
set_cmd_corner(Corner *corner)
{
  Sta::sta()->setCmdCorner(corner);
}

Corner *
find_corner(const char *corner_name)
{
  return Sta::sta()->findCorner(corner_name);
}

Corners *
corners()
{
  return Sta::sta()->corners();
}

bool
multi_corner()
{
  return Sta::sta()->multiCorner();
}

////////////////////////////////////////////////////////////////

CheckErrorSeq &
check_timing_cmd(bool no_input_delay,
		 bool no_output_delay,
		 bool reg_multiple_clks,
		 bool reg_no_clks,
		 bool unconstrained_endpoints,
		 bool loops,
		 bool generated_clks)
{
  return Sta::sta()->checkTiming(no_input_delay, no_output_delay,
				 reg_multiple_clks, reg_no_clks,
				 unconstrained_endpoints,
				 loops, generated_clks);
}

////////////////////////////////////////////////////////////////

PinSet
find_fanin_pins(PinSeq *to,
		bool flat,
		bool startpoints_only,
		int inst_levels,
		int pin_levels,
		bool thru_disabled,
		bool thru_constants)
{
  Sta *sta = Sta::sta();
  PinSet fanin = sta->findFaninPins(to, flat, startpoints_only,
                                    inst_levels, pin_levels,
                                    thru_disabled, thru_constants);
  delete to;
  return fanin;
}

InstanceSet
find_fanin_insts(PinSeq *to,
		 bool flat,
		 bool startpoints_only,
		 int inst_levels,
		 int pin_levels,
		 bool thru_disabled,
		 bool thru_constants)
{
  Sta *sta = Sta::sta();
  InstanceSet fanin = sta->findFaninInstances(to, flat, startpoints_only,
                                              inst_levels, pin_levels,
                                              thru_disabled, thru_constants);
  delete to;
  return fanin;
}

PinSet
find_fanout_pins(PinSeq *from,
		 bool flat,
		 bool endpoints_only,
		 int inst_levels,
		 int pin_levels,
		 bool thru_disabled,
		 bool thru_constants)
{
  Sta *sta = Sta::sta();
  PinSet fanout = sta->findFanoutPins(from, flat, endpoints_only,
                                      inst_levels, pin_levels,
                                      thru_disabled, thru_constants);
  delete from;
  return fanout;
}

InstanceSet
find_fanout_insts(PinSeq *from,
		  bool flat,
		  bool endpoints_only,
		  int inst_levels,
		  int pin_levels,
		  bool thru_disabled,
		  bool thru_constants)
{
  Sta *sta = Sta::sta();
  InstanceSet fanout = sta->findFanoutInstances(from, flat, endpoints_only,
                                                inst_levels, pin_levels,
                                                thru_disabled, thru_constants);
  delete from;
  return fanout;
}

////////////////////////////////////////////////////////////////
//
// Variables
//
////////////////////////////////////////////////////////////////

bool
crpr_enabled()
{
  return Sta::sta()->crprEnabled();
}

void
set_crpr_enabled(bool enabled)
{
  return Sta::sta()->setCrprEnabled(enabled);
}

const char *
crpr_mode()
{
  switch (Sta::sta()->crprMode()) {
  case CrprMode::same_transition:
    return "same_transition";
  case CrprMode::same_pin:
    return "same_pin";
  default:
    return "";
  }
}

void
set_crpr_mode(const char *mode)
{
  Sta *sta = Sta::sta();
  if (stringEq(mode, "same_pin"))
    Sta::sta()->setCrprMode(CrprMode::same_pin);
  else if (stringEq(mode, "same_transition"))
    Sta::sta()->setCrprMode(CrprMode::same_transition);
  else
    sta->report()->critical(1573, "unknown common clk pessimism mode.");
}

bool
pocv_enabled()
{
  return Sta::sta()->pocvEnabled();
}

void
set_pocv_enabled(bool enabled)
{
#if !SSTA
  if (enabled)
    Sta::sta()->report()->error(1574, "POCV support requires compilation with SSTA=1.");
#endif
  return Sta::sta()->setPocvEnabled(enabled);
}

float
pocv_sigma_factor()
{
  return Sta::sta()->sigmaFactor();
}

void
set_pocv_sigma_factor(float factor)
{
  Sta::sta()->setSigmaFactor(factor);
}

bool
propagate_gated_clock_enable()
{
  return Sta::sta()->propagateGatedClockEnable();
}

void
set_propagate_gated_clock_enable(bool enable)
{
  Sta::sta()->setPropagateGatedClockEnable(enable);
}

bool
preset_clr_arcs_enabled()
{
  return Sta::sta()->presetClrArcsEnabled();
}

void
set_preset_clr_arcs_enabled(bool enable)
{
  Sta::sta()->setPresetClrArcsEnabled(enable);
}

bool
cond_default_arcs_enabled()
{
  return Sta::sta()->condDefaultArcsEnabled();
}

void
set_cond_default_arcs_enabled(bool enabled)
{
  Sta::sta()->setCondDefaultArcsEnabled(enabled);
}

bool
bidirect_inst_paths_enabled()
{
  return Sta::sta()->bidirectInstPathsEnabled();
}

void
set_bidirect_inst_paths_enabled(bool enabled)
{
  Sta::sta()->setBidirectInstPathsEnabled(enabled);
}

bool
bidirect_net_paths_enabled()
{
  return Sta::sta()->bidirectNetPathsEnabled();
}

void
set_bidirect_net_paths_enabled(bool enabled)
{
  Sta::sta()->setBidirectNetPathsEnabled(enabled);
}

bool
recovery_removal_checks_enabled()
{
  return Sta::sta()->recoveryRemovalChecksEnabled();
}

void
set_recovery_removal_checks_enabled(bool enabled)
{
  Sta::sta()->setRecoveryRemovalChecksEnabled(enabled);
}

bool
gated_clk_checks_enabled()
{
  return Sta::sta()->gatedClkChecksEnabled();
}

void
set_gated_clk_checks_enabled(bool enabled)
{
  Sta::sta()->setGatedClkChecksEnabled(enabled);
}

bool
dynamic_loop_breaking()
{
  return Sta::sta()->dynamicLoopBreaking();
}

void
set_dynamic_loop_breaking(bool enable)
{
  Sta::sta()->setDynamicLoopBreaking(enable);
}

bool
use_default_arrival_clock()
{
  return Sta::sta()->useDefaultArrivalClock();
}

void
set_use_default_arrival_clock(bool enable)
{
  Sta::sta()->setUseDefaultArrivalClock(enable);
}

////////////////////////////////////////////////////////////////
//
// Properties
//
////////////////////////////////////////////////////////////////

PropertyValue
pin_property(const Pin *pin,
	     const char *property)
{
  return getProperty(pin, property, Sta::sta());
}

PropertyValue
instance_property(const Instance *inst,
		  const char *property)
{
  return getProperty(inst, property, Sta::sta());
}

PropertyValue
net_property(const Net *net,
	     const char *property)
{
  return getProperty(net, property, Sta::sta());
}

PropertyValue
port_property(const Port *port,
	      const char *property)
{
  return getProperty(port, property, Sta::sta());
}


PropertyValue
liberty_cell_property(const LibertyCell *cell,
		      const char *property)
{
  return getProperty(cell, property, Sta::sta());
}

PropertyValue
cell_property(const Cell *cell,
	      const char *property)
{
  return getProperty(cell, property, Sta::sta());
}

PropertyValue
liberty_port_property(const LibertyPort *port,
		      const char *property)
{
  return getProperty(port, property, Sta::sta());
}

PropertyValue
library_property(const Library *lib,
		 const char *property)
{
  return getProperty(lib, property, Sta::sta());
}

PropertyValue
liberty_library_property(const LibertyLibrary *lib,
			 const char *property)
{
  return getProperty(lib, property, Sta::sta());
}

PropertyValue
edge_property(Edge *edge,
	      const char *property)
{
  return getProperty(edge, property, Sta::sta());
}

PropertyValue
clock_property(Clock *clk,
	       const char *property)
{
  return getProperty(clk, property, Sta::sta());
}

PropertyValue
path_end_property(PathEnd *end,
		  const char *property)
{
  return getProperty(end, property, Sta::sta());
}

PropertyValue
path_ref_property(PathRef *path,
		  const char *property)
{
  return getProperty(path, property, Sta::sta());
}

PropertyValue
timing_arc_set_property(TimingArcSet *arc_set,
			const char *property)
{
  return getProperty(arc_set, property, Sta::sta());
}



#include <stdio.h>
#if (defined(_MSC_VER) && (_MSC_VER < 1900)) || defined(__BORLANDC__) || defined(_WATCOM)
# ifndef snprintf
#  define snprintf _snprintf
# endif
#endif


SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  if (value < (unsigned long) LONG_MAX) {
    return SWIG_From_long  (static_cast< long >(value));
  } else {
    char temp[256]; 
    SWIG_snprintf(temp, sizeof(temp), "%lu", value);
    return Tcl_NewStringObj(temp,-1);
  }
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_long_SS_long  (long long value)
{
  if (((long long) LONG_MIN <= value) && (value <= (long long) LONG_MAX)) {
    return SWIG_From_long  (static_cast< long >(value));
  } else {    
    char temp[256]; 
    SWIG_snprintf(temp, sizeof(temp), "%lld", value);
    return Tcl_NewStringObj(temp,-1);
  }
}
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  if (value < (unsigned long long) LONG_MAX) {
    return SWIG_From_long_SS_long  (static_cast< long long >(value));
  } else {
    char temp[256]; 
    SWIG_snprintf(temp, sizeof(temp), "%llu", value);
    return Tcl_NewStringObj(temp,-1);
  }
}
#endif


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}



#include "Sta.hh"
#include "StaConfig.hh"  // STA_VERSION
#include "Stats.hh"
#include "Report.hh"
#include "Error.hh"
#include "Fuzzy.hh"
#include "Units.hh"

using namespace sta;




float float_inf = INF;

const char *
version()
{
  return STA_VERSION;
}

const char *
git_sha1()
{
  return STA_GIT_SHA1;
}

// Elapsed run time (in seconds).
double
elapsed_run_time()
{
  return elapsedRunTime();
}

// User run time (in seconds).
double
user_run_time()
{
  return userRunTime();
}

// User run time (in seconds).
unsigned long
cputime()
{
  return static_cast<unsigned long>(userRunTime() + .5);
}

// Peak memory usage in bytes.
unsigned long
memory_usage()
{
  return memoryUsage();
}

int
processor_count()
{
  return processorCount();
}

int
thread_count()
{
  return Sta::sta()->threadCount();
}

void
set_thread_count(int count)
{
  Sta::sta()->setThreadCount(count);
}

////////////////////////////////////////////////////////////////

void
report_error(int id,
             const char *msg)
{
  Report *report = Sta::sta()->report();
  report->error(id, "%s", msg);
}

void
report_file_error(int id,
                  const char *filename,
                  int line,
                  const char *msg)
{
  Report *report = Sta::sta()->report();
  report->error(id, filename, line, "%s", msg);
}

void
report_warn(int id,
            const char *msg)
{
  Report *report = Sta::sta()->report();
  report->warn(id, "%s", msg);
}

void
report_file_warn(int id,
                 const char *filename,
                 int line,
                 const char *msg)
{
  Report *report = Sta::sta()->report();
  report->fileWarn(id, filename, line, "%s", msg);
}

void
report_line(const char *msg)
{
  Sta *sta = Sta::sta();
  if (sta)
    sta->report()->reportLineString(msg);
  else
    // After sta::delete_all_memory souce -echo prints the cmd file line
    printf("%s\n", msg);
}

void
suppress_msg_id(int id)
{
  Sta::sta()->report()->suppressMsgId(id);
}

void
unsuppress_msg_id(int id)
{
  Sta::sta()->report()->unsuppressMsgId(id);
}

int
is_suppressed(int id)
{
  return Sta::sta()->report()->isSuppressed(id);
}

void
fflush()
{
  fflush(stdout);
  fflush(stderr);
}

void
redirect_file_begin(const char *filename)
{
  Sta::sta()->report()->redirectFileBegin(filename);
}

void
redirect_file_append_begin(const char *filename)
{
  Sta::sta()->report()->redirectFileAppendBegin(filename);
}

void
redirect_file_end()
{
  Sta::sta()->report()->redirectFileEnd();
}

void
redirect_string_begin()
{
  Sta::sta()->report()->redirectStringBegin();
}

const char *
redirect_string_end()
{
  return Sta::sta()->report()->redirectStringEnd();
}

void
log_begin_cmd(const char *filename)
{
  Sta::sta()->report()->logBegin(filename);
}

void
log_end()
{
  Sta::sta()->report()->logEnd();
}

void
set_debug(const char *what,
	  int level)
{
  Sta::sta()->setDebugLevel(what, level);
}

////////////////////////////////////////////////////////////////

bool
is_object(const char *obj)
{
  // _hexaddress_p_type
  const char *s = obj;
  char ch = *s++;
  if (ch != '_')
    return false;
  while (*s && isxdigit(*s))
    s++;
  if ((s - obj - 1) == sizeof(void*) * 2
      && *s && *s++ == '_'
      && *s && *s++ == 'p'
      && *s && *s++ == '_') {
    while (*s && *s != ' ')
      s++;
    return *s == '\0';
  }
  else
    return false;
}

// Assumes is_object is true.
const char *
object_type(const char *obj)
{
  return &obj[1 + sizeof(void*) * 2 + 3];
}

bool
is_object_list(const char *list,
	       const char *type)
{
  const char *s = list;
  while (s) {
    bool type_match;
    const char *next;
    objectListNext(s, type, type_match, next);
    if (type_match)
      s = next;
    else
      return false;
  }
  return true;
}

////////////////////////////////////////////////////////////////
//
// Units
//
////////////////////////////////////////////////////////////////

// <unit>_sta_ui conversion from sta units to user interface units.
// <unit>_ui_sta conversion from user interface units to sta units.

double
time_ui_sta(double value)
{
  return Sta::sta()->units()->timeUnit()->userToSta(value);
}

double
time_sta_ui(double value)
{
  return Sta::sta()->units()->timeUnit()->staToUser(value);
}

double
capacitance_ui_sta(double value)
{
  return Sta::sta()->units()->capacitanceUnit()->userToSta(value);
}

double
capacitance_sta_ui(double value)
{
  return Sta::sta()->units()->capacitanceUnit()->staToUser(value);
}

double
resistance_ui_sta(double value)
{
  return Sta::sta()->units()->resistanceUnit()->userToSta(value);
}

double
resistance_sta_ui(double value)
{
  return Sta::sta()->units()->resistanceUnit()->staToUser(value);
}

double
voltage_ui_sta(double value)
{
  return Sta::sta()->units()->voltageUnit()->userToSta(value);
}

double
voltage_sta_ui(double value)
{
  return Sta::sta()->units()->voltageUnit()->staToUser(value);
}

double
current_ui_sta(double value)
{
  return Sta::sta()->units()->currentUnit()->userToSta(value);
}

double
current_sta_ui(double value)
{
  return Sta::sta()->units()->currentUnit()->staToUser(value);
}

double
power_ui_sta(double value)
{
  return Sta::sta()->units()->powerUnit()->userToSta(value);
}

double
power_sta_ui(double value)
{
  return Sta::sta()->units()->powerUnit()->staToUser(value);
}

double
distance_ui_sta(double value)
{
  return Sta::sta()->units()->distanceUnit()->userToSta(value);
}

double
distance_sta_ui(double value)
{
  return Sta::sta()->units()->distanceUnit()->staToUser(value);
}

double
area_ui_sta(double value)
{
  double scale = Sta::sta()->units()->distanceUnit()->scale();
  return value * scale * scale;
}

double
area_sta_ui(double value)
{
  double scale = Sta::sta()->units()->distanceUnit()->scale();
  return value / (scale * scale);
}

////////////////////////////////////////////////////////////////

void
set_cmd_unit_scale(const char *unit_name,
		   float scale)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    unit->setScale(scale);
}

void
set_cmd_unit_digits(const char *unit_name,
		    int digits)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    unit->setDigits(digits);
}

void
set_cmd_unit_suffix(const char *unit_name,
		    const char *suffix)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit) {
    unit->setSuffix(suffix);
  }
}

const char *
unit_scale_abbreviation (const char *unit_name)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    return unit->scaleAbbreviation();
  else
    return "";
}

const char *
unit_suffix(const char *unit_name)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    return unit->suffix();
  else
    return "";
}

const char *
unit_scaled_suffix(const char *unit_name)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    return unit->scaledSuffix();
  else
    return "";
}

float
unit_scale(const char *unit_name)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    return unit->scale();
  else
    return 1.0F;
}

////////////////////////////////////////////////////////////////

// format_unit functions print with fixed digits and suffix.
// Pass value arg as string to support NaNs.
const char *
format_time(const char *value,
	    int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->timeUnit()->asString(value1, digits);
}

const char *
format_capacitance(const char *value,
		   int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->capacitanceUnit()->asString(value1, digits);
}

const char *
format_resistance(const char *value,
		  int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->resistanceUnit()->asString(value1, digits);
}

const char *
format_voltage(const char *value,
	       int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->voltageUnit()->asString(value1, digits);
}

const char *
format_current(const char *value,
	       int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->currentUnit()->asString(value1, digits);
}

const char *
format_power(const char *value,
	     int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->powerUnit()->asString(value1, digits);
}

const char *
format_distance(const char *value,
		int digits)
{
  float value1 = strtof(value, nullptr);
  Unit *dist_unit = Sta::sta()->units()->distanceUnit();
  return dist_unit->asString(value1, digits);
}

const char *
format_area(const char *value,
	    int digits)
{
  float value1 = strtof(value, nullptr);
  Unit *dist_unit = Sta::sta()->units()->distanceUnit();
  return dist_unit->asString(value1 / dist_unit->scale(), digits);
}

////////////////////////////////////////////////////////////////

const char *
rise_short_name()
{
  return RiseFall::rise()->shortName();
}

const char *
fall_short_name()
{
  return RiseFall::fall()->shortName();
}

////////////////////////////////////////////////////////////////

bool
fuzzy_equal(float value1,
	    float value2)
{
  return fuzzyEqual(value1, value2);
}




#include "spice/WritePathSpice.hh"




void
write_path_spice_cmd(PathRef *path,
		     const char *spice_filename,
		     const char *subckt_filename,
		     const char *lib_subckt_filename,
		     const char *model_filename,
		     const char *power_name,
		     const char *gnd_name,
                     CircuitSim ckt_sim)
{
  Sta *sta = Sta::sta();
  sta->writePathSpice(path, spice_filename, subckt_filename,
                      lib_subckt_filename, model_filename,
                      power_name, gnd_name, ckt_sim);
}



#include "VerilogWriter.hh"
#include "Sta.hh"



bool
read_verilog_cmd(const char *filename)
{
  return Sta::sta()->readVerilog(filename);
}

void
write_verilog_cmd(const char *filename,
		  bool sort,
		  bool include_pwr_gnd,
		  CellSeq *remove_cells)
{
  // This does NOT want the SDC (cmd) network because it wants
  // to see the sta internal names.
  Network *network = Sta::sta()->network();
  writeVerilog(filename, sort, include_pwr_gnd, remove_cells, network);
  delete remove_cells;
}


#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN int
_wrap_delay_calc_names(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  StringSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::delay_calc_names ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = delay_calc_names(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq &strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (const char *str : strs) {
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_delay_calc_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_delay_calc_name alg ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_delay_calc_name" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)is_delay_calc_name((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_delay_calculator_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_delay_calculator_cmd alg ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_delay_calculator_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_delay_calculator_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_delay_calc_incremental_tolerance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float arg1 ;
  float val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_delay_calc_incremental_tolerance tol ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_delay_calc_incremental_tolerance" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  {
    try {
      set_delay_calc_incremental_tolerance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_delay_calc_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  string result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::report_delay_calc_cmd edge arc corner min_max digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_delay_calc_cmd" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_delay_calc_cmd" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "report_delay_calc_cmd" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "report_delay_calc_cmd" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = report_delay_calc_cmd(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    string &str = result;
    // String is volatile because it is deleted.
    Tcl_SetResult(interp, const_cast<char*>(str.c_str()), TCL_VOLATILE);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_prima_reduce_order(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_prima_reduce_order order ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_prima_reduce_order" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try {
      set_prima_reduce_order(SWIG_STD_MOVE(arg1)); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::find_delays ") == TCL_ERROR) SWIG_fail;
  {
    try {
      find_delays(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delays_invalid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::delays_invalid ") == TCL_ERROR) SWIG_fail;
  {
    try {
      delays_invalid(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_pin" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (Pin *)Vertex_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_is_bidirect_driver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_is_bidirect_driver self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_is_bidirect_driver" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_is_bidirect_driver(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_level(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_level self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_level" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (int)Vertex_level(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_tag_group_index(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_tag_group_index self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_tag_group_index" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (int)Vertex_tag_group_index(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slew result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Vertex_slew self rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slew" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = Vertex_slew(arg1,(RiseFall const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slew_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Slew result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_slew_corner self rf corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slew_corner" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_slew_corner" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = Vertex_slew_corner(arg1,(RiseFall const *)arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_out_edge_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VertexOutEdgeIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_out_edge_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_out_edge_iterator" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (VertexOutEdgeIterator *)Vertex_out_edge_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexOutEdgeIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_in_edge_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VertexInEdgeIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_in_edge_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_in_edge_iterator" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (VertexInEdgeIterator *)Vertex_in_edge_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexInEdgeIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_arrivals_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_arrivals_clk self rf clk clk_rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_arrivals_clk" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_arrivals_clk" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  {
    try {
      result = Vertex_arrivals_clk(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_arrivals_clk_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  StringSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::Vertex_arrivals_clk_delays self rf clk clk_rf digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_arrivals_clk_delays" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_arrivals_clk_delays" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Vertex_arrivals_clk_delays" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = Vertex_arrivals_clk_delays(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq &strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (const char *str : strs) {
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_requireds_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_requireds_clk self rf clk clk_rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_requireds_clk" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_requireds_clk" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  {
    try {
      result = Vertex_requireds_clk(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_requireds_clk_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  StringSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::Vertex_requireds_clk_delays self rf clk clk_rf digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_requireds_clk_delays" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_requireds_clk_delays" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Vertex_requireds_clk_delays" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = Vertex_requireds_clk_delays(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq &strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (const char *str : strs) {
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Vertex_slack self min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slack" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = Vertex_slack(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slacks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Vertex_slacks self rf ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slacks" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    try {
      result = Vertex_slacks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slacks_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_slacks_clk self rf clk clk_rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slacks_clk" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_slacks_clk" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  {
    try {
      result = Vertex_slacks_clk(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slacks_clk_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  StringSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::Vertex_slacks_clk_delays self rf clk clk_rf digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slacks_clk_delays" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_slacks_clk_delays" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Vertex_slacks_clk_delays" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = Vertex_slacks_clk_delays(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq &strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (const char *str : strs) {
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_path_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VertexPathIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Vertex_path_iterator self rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_path_iterator" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (VertexPathIterator *)Vertex_path_iterator(arg1,(RiseFall const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexPathIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_has_downstream_clk_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_has_downstream_clk_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_has_downstream_clk_pin" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_has_downstream_clk_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_is_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_is_clock self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_is_clock" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_is_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_is_disabled_constraint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_is_disabled_constraint self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_is_disabled_constraint" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_is_disabled_constraint(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Vertex_methods[] = {
    {"pin", _wrap_Vertex_pin}, 
    {"is_bidirect_driver", _wrap_Vertex_is_bidirect_driver}, 
    {"level", _wrap_Vertex_level}, 
    {"tag_group_index", _wrap_Vertex_tag_group_index}, 
    {"slew", _wrap_Vertex_slew}, 
    {"slew_corner", _wrap_Vertex_slew_corner}, 
    {"out_edge_iterator", _wrap_Vertex_out_edge_iterator}, 
    {"in_edge_iterator", _wrap_Vertex_in_edge_iterator}, 
    {"arrivals_clk", _wrap_Vertex_arrivals_clk}, 
    {"arrivals_clk_delays", _wrap_Vertex_arrivals_clk_delays}, 
    {"requireds_clk", _wrap_Vertex_requireds_clk}, 
    {"requireds_clk_delays", _wrap_Vertex_requireds_clk_delays}, 
    {"slack", _wrap_Vertex_slack}, 
    {"slacks", _wrap_Vertex_slacks}, 
    {"slacks_clk", _wrap_Vertex_slacks_clk}, 
    {"slacks_clk_delays", _wrap_Vertex_slacks_clk_delays}, 
    {"path_iterator", _wrap_Vertex_path_iterator}, 
    {"has_downstream_clk_pin", _wrap_Vertex_has_downstream_clk_pin}, 
    {"is_clock", _wrap_Vertex_is_clock}, 
    {"is_disabled_constraint", _wrap_Vertex_is_disabled_constraint}, 
    {0,0}
};
static swig_attribute swig_Vertex_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Vertex_bases[] = {0};
static const char * swig_Vertex_base_names[] = {0};
static swig_class _wrap_class_Vertex = { "Vertex", &SWIGTYPE_p_Vertex,0,0, swig_Vertex_methods, swig_Vertex_attributes, swig_Vertex_bases,swig_Vertex_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Edge_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_from self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_from" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Vertex *)Edge_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_to self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_to" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Vertex *)Edge_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_from_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_from_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_from_pin" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Pin *)Edge_from_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_to_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_to_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_to_pin" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Pin *)Edge_to_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_role" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (TimingRole *)Edge_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_sense(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_sense self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_sense" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_sense(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_timing_arcs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingArcSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_timing_arcs self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_timing_arcs" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (TimingArcSeq *) &Edge_timing_arcs(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqPtrTclList<TimingArcSeq, TimingArc>(result, SWIGTYPE_p_TimingArc, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_loop(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_loop self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_loop" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_loop(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_constraint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_constraint self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_constraint" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_constraint(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_constant(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_constant self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_constant" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_constant(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_cond_default(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_cond_default self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_cond_default" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_cond_default(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_disabled_constant_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_disabled_constant_pins self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_disabled_constant_pins" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = Edge_disabled_constant_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_bidirect_inst_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_bidirect_inst_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_bidirect_inst_path" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_bidirect_inst_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_bidirect_net_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_bidirect_net_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_bidirect_net_path" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_bidirect_net_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_preset_clear(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_preset_clear self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_preset_clear" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_preset_clear(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_sim_timing_sense(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_sim_timing_sense self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_sim_timing_sense" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_sim_timing_sense(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_arc_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Edge_arc_delays self arc ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_arc_delays" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_arc_delays" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  {
    try {
      result = Edge_arc_delays(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_arc_delay_strings(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  StringSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Edge_arc_delay_strings self arc digits ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_arc_delay_strings" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_arc_delay_strings" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Edge_arc_delay_strings" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = Edge_arc_delay_strings(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq &strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (const char *str : strs) {
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_delay_annotated(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Edge_delay_annotated self arc corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_delay_annotated" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_delay_annotated" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Edge_delay_annotated" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (bool)Edge_delay_annotated(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_arc_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Edge_arc_delay self arc corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_arc_delay" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_arc_delay" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Edge_arc_delay" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Edge_arc_delay(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_cond(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_cond self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_cond" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_cond(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_mode_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_mode_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_mode_name" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_mode_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_mode_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_mode_value self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_mode_value" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_mode_value(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_latch_d_to_q_en(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_latch_d_to_q_en self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_latch_d_to_q_en" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_latch_d_to_q_en(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Edge_methods[] = {
    {"from", _wrap_Edge_from}, 
    {"to", _wrap_Edge_to}, 
    {"from_pin", _wrap_Edge_from_pin}, 
    {"to_pin", _wrap_Edge_to_pin}, 
    {"role", _wrap_Edge_role}, 
    {"sense", _wrap_Edge_sense}, 
    {"timing_arcs", _wrap_Edge_timing_arcs}, 
    {"is_disabled_loop", _wrap_Edge_is_disabled_loop}, 
    {"is_disabled_constraint", _wrap_Edge_is_disabled_constraint}, 
    {"is_disabled_constant", _wrap_Edge_is_disabled_constant}, 
    {"is_disabled_cond_default", _wrap_Edge_is_disabled_cond_default}, 
    {"disabled_constant_pins", _wrap_Edge_disabled_constant_pins}, 
    {"is_disabled_bidirect_inst_path", _wrap_Edge_is_disabled_bidirect_inst_path}, 
    {"is_disabled_bidirect_net_path", _wrap_Edge_is_disabled_bidirect_net_path}, 
    {"is_disabled_preset_clear", _wrap_Edge_is_disabled_preset_clear}, 
    {"sim_timing_sense", _wrap_Edge_sim_timing_sense}, 
    {"arc_delays", _wrap_Edge_arc_delays}, 
    {"arc_delay_strings", _wrap_Edge_arc_delay_strings}, 
    {"delay_annotated", _wrap_Edge_delay_annotated}, 
    {"arc_delay", _wrap_Edge_arc_delay}, 
    {"cond", _wrap_Edge_cond}, 
    {"mode_name", _wrap_Edge_mode_name}, 
    {"mode_value", _wrap_Edge_mode_value}, 
    {"latch_d_to_q_en", _wrap_Edge_latch_d_to_q_en}, 
    {0,0}
};
static swig_attribute swig_Edge_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Edge_bases[] = {0};
static const char * swig_Edge_base_names[] = {0};
static swig_class _wrap_class_Edge = { "Edge", &SWIGTYPE_p_Edge,0,0, swig_Edge_methods, swig_Edge_attributes, swig_Edge_bases,swig_Edge_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_VertexIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexIterator *arg1 = (VertexIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexIterator_has_next" "', argument " "1"" of type '" "VertexIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexIterator * >(argp1);
  {
    try {
      result = (bool)VertexIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexIterator *arg1 = (VertexIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexIterator_next" "', argument " "1"" of type '" "VertexIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexIterator * >(argp1);
  {
    try {
      result = (Vertex *)VertexIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexIterator *arg1 = (VertexIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexIterator_finish" "', argument " "1"" of type '" "VertexIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexIterator * >(argp1);
  {
    try {
      VertexIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexIterator_methods[] = {
    {"has_next", _wrap_VertexIterator_has_next}, 
    {"next", _wrap_VertexIterator_next}, 
    {"finish", _wrap_VertexIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexIterator_bases[] = {0};
static const char * swig_VertexIterator_base_names[] = {0};
static swig_class _wrap_class_VertexIterator = { "VertexIterator", &SWIGTYPE_p_VertexIterator,0,0, swig_VertexIterator_methods, swig_VertexIterator_attributes, swig_VertexIterator_bases,swig_VertexIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_VertexInEdgeIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexInEdgeIterator *arg1 = (VertexInEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexInEdgeIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexInEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexInEdgeIterator_has_next" "', argument " "1"" of type '" "VertexInEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexInEdgeIterator * >(argp1);
  {
    try {
      result = (bool)VertexInEdgeIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexInEdgeIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexInEdgeIterator *arg1 = (VertexInEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Edge *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexInEdgeIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexInEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexInEdgeIterator_next" "', argument " "1"" of type '" "VertexInEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexInEdgeIterator * >(argp1);
  {
    try {
      result = (Edge *)VertexInEdgeIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Edge, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexInEdgeIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexInEdgeIterator *arg1 = (VertexInEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexInEdgeIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexInEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexInEdgeIterator_finish" "', argument " "1"" of type '" "VertexInEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexInEdgeIterator * >(argp1);
  {
    try {
      VertexInEdgeIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexInEdgeIterator_methods[] = {
    {"has_next", _wrap_VertexInEdgeIterator_has_next}, 
    {"next", _wrap_VertexInEdgeIterator_next}, 
    {"finish", _wrap_VertexInEdgeIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexInEdgeIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexInEdgeIterator_bases[] = {0};
static const char * swig_VertexInEdgeIterator_base_names[] = {0};
static swig_class _wrap_class_VertexInEdgeIterator = { "VertexInEdgeIterator", &SWIGTYPE_p_VertexInEdgeIterator,0,0, swig_VertexInEdgeIterator_methods, swig_VertexInEdgeIterator_attributes, swig_VertexInEdgeIterator_bases,swig_VertexInEdgeIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_VertexOutEdgeIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexOutEdgeIterator *arg1 = (VertexOutEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexOutEdgeIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexOutEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexOutEdgeIterator_has_next" "', argument " "1"" of type '" "VertexOutEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexOutEdgeIterator * >(argp1);
  {
    try {
      result = (bool)VertexOutEdgeIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexOutEdgeIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexOutEdgeIterator *arg1 = (VertexOutEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Edge *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexOutEdgeIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexOutEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexOutEdgeIterator_next" "', argument " "1"" of type '" "VertexOutEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexOutEdgeIterator * >(argp1);
  {
    try {
      result = (Edge *)VertexOutEdgeIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Edge, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexOutEdgeIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexOutEdgeIterator *arg1 = (VertexOutEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexOutEdgeIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexOutEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexOutEdgeIterator_finish" "', argument " "1"" of type '" "VertexOutEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexOutEdgeIterator * >(argp1);
  {
    try {
      VertexOutEdgeIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexOutEdgeIterator_methods[] = {
    {"has_next", _wrap_VertexOutEdgeIterator_has_next}, 
    {"next", _wrap_VertexOutEdgeIterator_next}, 
    {"finish", _wrap_VertexOutEdgeIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexOutEdgeIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexOutEdgeIterator_bases[] = {0};
static const char * swig_VertexOutEdgeIterator_base_names[] = {0};
static swig_class _wrap_class_VertexOutEdgeIterator = { "VertexOutEdgeIterator", &SWIGTYPE_p_VertexOutEdgeIterator,0,0, swig_VertexOutEdgeIterator_methods, swig_VertexOutEdgeIterator_attributes, swig_VertexOutEdgeIterator_bases,swig_VertexOutEdgeIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_vertex_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::vertex_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (VertexIterator *)vertex_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_arc_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_arc_delay edge arc corner min_max delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_arc_delay" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_arc_delay" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_arc_delay" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_arc_delay" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_arc_delay(arg1,arg2,(Corner const *)arg3,(MinMaxAll const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_annotated_slew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_annotated_slew vertex corner min_max rf slew ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_annotated_slew" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_annotated_slew" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_annotated_slew" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_annotated_slew(arg1,(Corner const *)arg2,(MinMaxAll const *)arg3,(RiseFallBoth const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_remove_delay_slew_annotations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::remove_delay_slew_annotations ") == TCL_ERROR) SWIG_fail;
  {
    try {
      remove_delay_slew_annotations(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibrary_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_name" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      result = (char *)LibertyLibrary_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_liberty_cell self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_liberty_cell" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_liberty_cell" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (LibertyCell *)LibertyLibrary_find_liberty_cell(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_liberty_cells_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  LibertyCellSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::LibertyLibrary_find_liberty_cells_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = LibertyLibrary_find_liberty_cells_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<LibertyCellSeq, LibertyCell>(result, SWIGTYPE_p_LibertyCell, interp);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_wireload(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Wireload *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_wireload self model_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_wireload" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_wireload" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Wireload *)LibertyLibrary_find_wireload(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Wireload, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_wireload_selection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  WireloadSelection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_wireload_selection self selection_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_wireload_selection" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_wireload_selection" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (WireloadSelection *)LibertyLibrary_find_wireload_selection(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_WireloadSelection, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_operating_conditions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  OperatingConditions *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_operating_conditions self op_cond_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_operating_conditions" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_operating_conditions" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (OperatingConditions *)LibertyLibrary_find_operating_conditions(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_OperatingConditions, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_default_operating_conditions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  OperatingConditions *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibrary_default_operating_conditions self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_default_operating_conditions" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      result = (OperatingConditions *)LibertyLibrary_default_operating_conditions(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_OperatingConditions, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyLibrary_methods[] = {
    {"name", _wrap_LibertyLibrary_name}, 
    {"find_liberty_cell", _wrap_LibertyLibrary_find_liberty_cell}, 
    {"find_liberty_cells_matching", _wrap_LibertyLibrary_find_liberty_cells_matching}, 
    {"find_wireload", _wrap_LibertyLibrary_find_wireload}, 
    {"find_wireload_selection", _wrap_LibertyLibrary_find_wireload_selection}, 
    {"find_operating_conditions", _wrap_LibertyLibrary_find_operating_conditions}, 
    {"default_operating_conditions", _wrap_LibertyLibrary_default_operating_conditions}, 
    {0,0}
};
static swig_attribute swig_LibertyLibrary_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyLibrary_bases[] = {0};
static const char * swig_LibertyLibrary_base_names[] = {0};
static swig_class _wrap_class_LibertyLibrary = { "LibertyLibrary", &SWIGTYPE_p_LibertyLibrary,0,0, swig_LibertyLibrary_methods, swig_LibertyLibrary_attributes, swig_LibertyLibrary_bases,swig_LibertyLibrary_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyLibraryIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibraryIterator *arg1 = (LibertyLibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibraryIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibraryIterator_has_next" "', argument " "1"" of type '" "LibertyLibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibraryIterator * >(argp1);
  {
    try {
      result = (bool)LibertyLibraryIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibraryIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibraryIterator *arg1 = (LibertyLibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyLibrary *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibraryIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibraryIterator_next" "', argument " "1"" of type '" "LibertyLibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibraryIterator * >(argp1);
  {
    try {
      result = (LibertyLibrary *)LibertyLibraryIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_LibertyLibrary,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibraryIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibraryIterator *arg1 = (LibertyLibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibraryIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibraryIterator_finish" "', argument " "1"" of type '" "LibertyLibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibraryIterator * >(argp1);
  {
    try {
      LibertyLibraryIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyLibraryIterator_methods[] = {
    {"has_next", _wrap_LibertyLibraryIterator_has_next}, 
    {"next", _wrap_LibertyLibraryIterator_next}, 
    {"finish", _wrap_LibertyLibraryIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibertyLibraryIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyLibraryIterator_bases[] = {0};
static const char * swig_LibertyLibraryIterator_base_names[] = {0};
static swig_class _wrap_class_LibertyLibraryIterator = { "LibertyLibraryIterator", &SWIGTYPE_p_LibertyLibraryIterator,0,0, swig_LibertyLibraryIterator_methods, swig_LibertyLibraryIterator_attributes, swig_LibertyLibraryIterator_bases,swig_LibertyLibraryIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyCell_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_name" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (char *)LibertyCell_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_is_leaf" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (bool)LibertyCell_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_is_buffer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_is_buffer self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_is_buffer" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (bool)LibertyCell_is_buffer(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_is_inverter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_is_inverter self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_is_inverter" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (bool)LibertyCell_is_inverter(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_liberty_library(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyLibrary *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_liberty_library self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_liberty_library" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyLibrary *)LibertyCell_liberty_library(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_LibertyLibrary,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_cell" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (Cell *)LibertyCell_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_find_liberty_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyCell_find_liberty_port self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_find_liberty_port" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyCell_find_liberty_port" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (LibertyPort *)LibertyCell_find_liberty_port(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_find_liberty_ports_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  LibertyPortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::LibertyCell_find_liberty_ports_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = LibertyCell_find_liberty_ports_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<LibertyPortSeq, LibertyPort>(result, SWIGTYPE_p_LibertyPort, interp);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_liberty_port_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCellPortIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_liberty_port_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_liberty_port_iterator" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyCellPortIterator *)LibertyCell_liberty_port_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCellPortIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_timing_arc_sets(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingArcSetSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_timing_arc_sets self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_timing_arc_sets" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (TimingArcSetSeq *) &LibertyCell_timing_arc_sets(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqPtrTclList<TimingArcSetSeq, TimingArcSet>(result, SWIGTYPE_p_TimingArcSet, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_ensure_voltage_waveforms(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_ensure_voltage_waveforms self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_ensure_voltage_waveforms" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      LibertyCell_ensure_voltage_waveforms(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_test_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_test_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_test_cell" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyCell *)LibertyCell_test_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyCell_methods[] = {
    {"name", _wrap_LibertyCell_name}, 
    {"is_leaf", _wrap_LibertyCell_is_leaf}, 
    {"is_buffer", _wrap_LibertyCell_is_buffer}, 
    {"is_inverter", _wrap_LibertyCell_is_inverter}, 
    {"liberty_library", _wrap_LibertyCell_liberty_library}, 
    {"cell", _wrap_LibertyCell_cell}, 
    {"find_liberty_port", _wrap_LibertyCell_find_liberty_port}, 
    {"find_liberty_ports_matching", _wrap_LibertyCell_find_liberty_ports_matching}, 
    {"liberty_port_iterator", _wrap_LibertyCell_liberty_port_iterator}, 
    {"timing_arc_sets", _wrap_LibertyCell_timing_arc_sets}, 
    {"ensure_voltage_waveforms", _wrap_LibertyCell_ensure_voltage_waveforms}, 
    {"test_cell", _wrap_LibertyCell_test_cell}, 
    {0,0}
};
static swig_attribute swig_LibertyCell_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyCell_bases[] = {0};
static const char * swig_LibertyCell_base_names[] = {0};
static swig_class _wrap_class_LibertyCell = { "LibertyCell", &SWIGTYPE_p_LibertyCell,0,0, swig_LibertyCell_methods, swig_LibertyCell_attributes, swig_LibertyCell_bases,swig_LibertyCell_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyPort_bus_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_bus_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_bus_name" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)LibertyPort_bus_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_cell" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (Cell *)LibertyPort_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_is_bus(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_is_bus self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_is_bus" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (bool)LibertyPort_is_bus(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_member_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPortMemberIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_member_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_member_iterator" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (LibertyPortMemberIterator *)LibertyPort_member_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPortMemberIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_function(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_function self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_function" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)LibertyPort_function(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_tristate_enable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_tristate_enable self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_tristate_enable" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)LibertyPort_tristate_enable(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::LibertyPort_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_capacitance" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyPort_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)LibertyPort_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_set_direction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyPort_set_direction self dir ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_set_direction" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyPort_set_direction" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      LibertyPort_set_direction(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_scan_signal_type(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_scan_signal_type self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_scan_signal_type" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)LibertyPort_scan_signal_type(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyPort_methods[] = {
    {"bus_name", _wrap_LibertyPort_bus_name}, 
    {"cell", _wrap_LibertyPort_cell}, 
    {"is_bus", _wrap_LibertyPort_is_bus}, 
    {"member_iterator", _wrap_LibertyPort_member_iterator}, 
    {"function", _wrap_LibertyPort_function}, 
    {"tristate_enable", _wrap_LibertyPort_tristate_enable}, 
    {"capacitance", _wrap_LibertyPort_capacitance}, 
    {"set_direction", _wrap_LibertyPort_set_direction}, 
    {"scan_signal_type", _wrap_LibertyPort_scan_signal_type}, 
    {0,0}
};
static swig_attribute swig_LibertyPort_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyPort_bases[] = {0};
static const char * swig_LibertyPort_base_names[] = {0};
static swig_class _wrap_class_LibertyPort = { "LibertyPort", &SWIGTYPE_p_LibertyPort,0,0, swig_LibertyPort_methods, swig_LibertyPort_attributes, swig_LibertyPort_bases,swig_LibertyPort_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyCellPortIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCellPortIterator *arg1 = (LibertyCellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellPortIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellPortIterator_has_next" "', argument " "1"" of type '" "LibertyCellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellPortIterator * >(argp1);
  {
    try {
      result = (bool)LibertyCellPortIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCellPortIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCellPortIterator *arg1 = (LibertyCellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellPortIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellPortIterator_next" "', argument " "1"" of type '" "LibertyCellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellPortIterator * >(argp1);
  {
    try {
      result = (LibertyPort *)LibertyCellPortIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCellPortIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCellPortIterator *arg1 = (LibertyCellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellPortIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellPortIterator_finish" "', argument " "1"" of type '" "LibertyCellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellPortIterator * >(argp1);
  {
    try {
      LibertyCellPortIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyCellPortIterator_methods[] = {
    {"has_next", _wrap_LibertyCellPortIterator_has_next}, 
    {"next", _wrap_LibertyCellPortIterator_next}, 
    {"finish", _wrap_LibertyCellPortIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibertyCellPortIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyCellPortIterator_bases[] = {0};
static const char * swig_LibertyCellPortIterator_base_names[] = {0};
static swig_class _wrap_class_LibertyCellPortIterator = { "LibertyCellPortIterator", &SWIGTYPE_p_LibertyCellPortIterator,0,0, swig_LibertyCellPortIterator_methods, swig_LibertyCellPortIterator_attributes, swig_LibertyCellPortIterator_bases,swig_LibertyCellPortIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyPortMemberIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPortMemberIterator *arg1 = (LibertyPortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPortMemberIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPortMemberIterator_has_next" "', argument " "1"" of type '" "LibertyPortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPortMemberIterator * >(argp1);
  {
    try {
      result = (bool)LibertyPortMemberIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPortMemberIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPortMemberIterator *arg1 = (LibertyPortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPortMemberIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPortMemberIterator_next" "', argument " "1"" of type '" "LibertyPortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPortMemberIterator * >(argp1);
  {
    try {
      result = (LibertyPort *)LibertyPortMemberIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPortMemberIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPortMemberIterator *arg1 = (LibertyPortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPortMemberIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPortMemberIterator_finish" "', argument " "1"" of type '" "LibertyPortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPortMemberIterator * >(argp1);
  {
    try {
      LibertyPortMemberIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyPortMemberIterator_methods[] = {
    {"has_next", _wrap_LibertyPortMemberIterator_has_next}, 
    {"next", _wrap_LibertyPortMemberIterator_next}, 
    {"finish", _wrap_LibertyPortMemberIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibertyPortMemberIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyPortMemberIterator_bases[] = {0};
static const char * swig_LibertyPortMemberIterator_base_names[] = {0};
static swig_class _wrap_class_LibertyPortMemberIterator = { "LibertyPortMemberIterator", &SWIGTYPE_p_LibertyPortMemberIterator,0,0, swig_LibertyPortMemberIterator_methods, swig_LibertyPortMemberIterator_attributes, swig_LibertyPortMemberIterator_bases,swig_LibertyPortMemberIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_TimingArcSet_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_from self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_from" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArcSet_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_to self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_to" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArcSet_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_role" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (TimingRole *)TimingArcSet_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_sdf_cond(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_sdf_cond self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_sdf_cond" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (char *)TimingArcSet_sdf_cond(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_full_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_full_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_full_name" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (char *)TimingArcSet_full_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_timing_arcs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingArcSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_timing_arcs self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_timing_arcs" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (TimingArcSeq *) &TimingArcSet_timing_arcs(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqPtrTclList<TimingArcSeq, TimingArc>(result, SWIGTYPE_p_TimingArc, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_TimingArcSet_methods[] = {
    {"from", _wrap_TimingArcSet_from}, 
    {"to", _wrap_TimingArcSet_to}, 
    {"role", _wrap_TimingArcSet_role}, 
    {"sdf_cond", _wrap_TimingArcSet_sdf_cond}, 
    {"full_name", _wrap_TimingArcSet_full_name}, 
    {"timing_arcs", _wrap_TimingArcSet_timing_arcs}, 
    {0,0}
};
static swig_attribute swig_TimingArcSet_attributes[] = {
    {0,0,0}
};
static swig_class *swig_TimingArcSet_bases[] = {0};
static const char * swig_TimingArcSet_base_names[] = {0};
static swig_class _wrap_class_TimingArcSet = { "TimingArcSet", &SWIGTYPE_p_TimingArcSet,0,0, swig_TimingArcSet_methods, swig_TimingArcSet_attributes, swig_TimingArcSet_bases,swig_TimingArcSet_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_TimingArc_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_from self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_from" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArc_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_to self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_to" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArc_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_from_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transition *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_from_edge self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_from_edge" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (Transition *)TimingArc_from_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Transition *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_from_edge_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_from_edge_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_from_edge_name" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (char *)TimingArc_from_edge_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_to_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transition *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_to_edge self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_to_edge" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (Transition *)TimingArc_to_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Transition *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_to_edge_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_to_edge_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_to_edge_name" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (char *)TimingArc_to_edge_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_role" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (TimingRole *)TimingArc_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_time_voltage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::TimingArc_time_voltage self in_slew load_cap time ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_time_voltage" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_time_voltage" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_time_voltage" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TimingArc_time_voltage" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      result = (float)TimingArc_time_voltage(arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_time_current(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::TimingArc_time_current self in_slew load_cap time ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_time_current" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_time_current" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_time_current" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TimingArc_time_current" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      result = (float)TimingArc_time_current(arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_voltage_current(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::TimingArc_voltage_current self in_slew load_cap voltage ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_voltage_current" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_voltage_current" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_voltage_current" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TimingArc_voltage_current" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      result = (float)TimingArc_voltage_current(arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_voltage_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::TimingArc_voltage_time self in_slew load_cap voltage ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_voltage_time" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_voltage_time" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_voltage_time" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TimingArc_voltage_time" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      result = (float)TimingArc_voltage_time(arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_voltage_waveform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  Table1 result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::TimingArc_voltage_waveform self in_slew load_cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_voltage_waveform" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_voltage_waveform" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_voltage_waveform" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      result = TimingArc_voltage_waveform(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Table1 &table = result;
    if (table.axis1()) {
      Tcl_Obj *list3 = Tcl_NewListObj(0, nullptr);
      Tcl_Obj *list1 = Tcl_NewListObj(0, nullptr);
      for (float f : *table.axis1()->values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list1, obj);
      }
      Tcl_Obj *list2 = Tcl_NewListObj(0, nullptr);
      for (float f : *table.values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list2, obj);
      }
      Tcl_ListObjAppendElement(interp, list3, list1);
      Tcl_ListObjAppendElement(interp, list3, list2);
      Tcl_SetObjResult(interp, list3);
    }
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_voltage_waveform_raw(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  Table1 *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::TimingArc_voltage_waveform_raw self in_slew load_cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_voltage_waveform_raw" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_voltage_waveform_raw" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_voltage_waveform_raw" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      result = (Table1 *)TimingArc_voltage_waveform_raw(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const Table1 *table = result;
    Tcl_Obj *list3 = Tcl_NewListObj(0, nullptr);
    if (table) {
      Tcl_Obj *list1 = Tcl_NewListObj(0, nullptr);
      for (float f : *table->axis1()->values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list1, obj);
      }
      Tcl_Obj *list2 = Tcl_NewListObj(0, nullptr);
      for (float f : *table->values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list2, obj);
      }
      Tcl_ListObjAppendElement(interp, list3, list1);
      Tcl_ListObjAppendElement(interp, list3, list2);
    }
    Tcl_SetObjResult(interp, list3);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_current_waveform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  Table1 result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::TimingArc_current_waveform self in_slew load_cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_current_waveform" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_current_waveform" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_current_waveform" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      result = TimingArc_current_waveform(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Table1 &table = result;
    if (table.axis1()) {
      Tcl_Obj *list3 = Tcl_NewListObj(0, nullptr);
      Tcl_Obj *list1 = Tcl_NewListObj(0, nullptr);
      for (float f : *table.axis1()->values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list1, obj);
      }
      Tcl_Obj *list2 = Tcl_NewListObj(0, nullptr);
      for (float f : *table.values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list2, obj);
      }
      Tcl_ListObjAppendElement(interp, list3, list1);
      Tcl_ListObjAppendElement(interp, list3, list2);
      Tcl_SetObjResult(interp, list3);
    }
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_current_waveform_raw(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  Table1 *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::TimingArc_current_waveform_raw self in_slew load_cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_current_waveform_raw" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_current_waveform_raw" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_current_waveform_raw" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      result = (Table1 *)TimingArc_current_waveform_raw(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const Table1 *table = result;
    Tcl_Obj *list3 = Tcl_NewListObj(0, nullptr);
    if (table) {
      Tcl_Obj *list1 = Tcl_NewListObj(0, nullptr);
      for (float f : *table->axis1()->values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list1, obj);
      }
      Tcl_Obj *list2 = Tcl_NewListObj(0, nullptr);
      for (float f : *table->values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list2, obj);
      }
      Tcl_ListObjAppendElement(interp, list3, list1);
      Tcl_ListObjAppendElement(interp, list3, list2);
    }
    Tcl_SetObjResult(interp, list3);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_voltage_current_waveform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  Table1 result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::TimingArc_voltage_current_waveform self in_slew load_cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_voltage_current_waveform" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TimingArc_voltage_current_waveform" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TimingArc_voltage_current_waveform" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      result = TimingArc_voltage_current_waveform(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Table1 &table = result;
    if (table.axis1()) {
      Tcl_Obj *list3 = Tcl_NewListObj(0, nullptr);
      Tcl_Obj *list1 = Tcl_NewListObj(0, nullptr);
      for (float f : *table.axis1()->values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list1, obj);
      }
      Tcl_Obj *list2 = Tcl_NewListObj(0, nullptr);
      for (float f : *table.values()) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list2, obj);
      }
      Tcl_ListObjAppendElement(interp, list3, list1);
      Tcl_ListObjAppendElement(interp, list3, list2);
      Tcl_SetObjResult(interp, list3);
    }
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_final_resistance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_final_resistance self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_final_resistance" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (float)TimingArc_final_resistance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_TimingArc_methods[] = {
    {"from", _wrap_TimingArc_from}, 
    {"to", _wrap_TimingArc_to}, 
    {"from_edge", _wrap_TimingArc_from_edge}, 
    {"from_edge_name", _wrap_TimingArc_from_edge_name}, 
    {"to_edge", _wrap_TimingArc_to_edge}, 
    {"to_edge_name", _wrap_TimingArc_to_edge_name}, 
    {"role", _wrap_TimingArc_role}, 
    {"time_voltage", _wrap_TimingArc_time_voltage}, 
    {"time_current", _wrap_TimingArc_time_current}, 
    {"voltage_current", _wrap_TimingArc_voltage_current}, 
    {"voltage_time", _wrap_TimingArc_voltage_time}, 
    {"voltage_waveform", _wrap_TimingArc_voltage_waveform}, 
    {"voltage_waveform_raw", _wrap_TimingArc_voltage_waveform_raw}, 
    {"current_waveform", _wrap_TimingArc_current_waveform}, 
    {"current_waveform_raw", _wrap_TimingArc_current_waveform_raw}, 
    {"voltage_current_waveform", _wrap_TimingArc_voltage_current_waveform}, 
    {"final_resistance", _wrap_TimingArc_final_resistance}, 
    {0,0}
};
static swig_attribute swig_TimingArc_attributes[] = {
    {0,0,0}
};
static swig_class *swig_TimingArc_bases[] = {0};
static const char * swig_TimingArc_base_names[] = {0};
static swig_class _wrap_class_TimingArc = { "TimingArc", &SWIGTYPE_p_TimingArc,0,0, swig_TimingArc_methods, swig_TimingArc_attributes, swig_TimingArc_bases,swig_TimingArc_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_Wireload_methods[] = {
    {0,0}
};
static swig_attribute swig_Wireload_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Wireload_bases[] = {0};
static const char * swig_Wireload_base_names[] = {0};
static swig_class _wrap_class_Wireload = { "Wireload", &SWIGTYPE_p_Wireload,0,0, swig_Wireload_methods, swig_Wireload_attributes, swig_Wireload_bases,swig_Wireload_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_WireloadSelection_methods[] = {
    {0,0}
};
static swig_attribute swig_WireloadSelection_attributes[] = {
    {0,0,0}
};
static swig_class *swig_WireloadSelection_bases[] = {0};
static const char * swig_WireloadSelection_base_names[] = {0};
static swig_class _wrap_class_WireloadSelection = { "WireloadSelection", &SWIGTYPE_p_WireloadSelection,0,0, swig_WireloadSelection_methods, swig_WireloadSelection_attributes, swig_WireloadSelection_bases,swig_WireloadSelection_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_read_liberty_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  bool arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::read_liberty_cmd filename corner min_max infer_latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_liberty_cmd" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_liberty_cmd" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "read_liberty_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (bool)read_liberty_cmd(arg1,arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_liberty_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::write_liberty_cmd library filename ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_liberty_cmd" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write_liberty_cmd" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      write_liberty_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_equiv_cells(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::make_equiv_cells lib ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_equiv_cells" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      make_equiv_cells(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_equiv_cells(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCellSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_equiv_cells cell ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_equiv_cells" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyCellSeq *)find_equiv_cells(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqPtrTclList<LibertyCellSeq, LibertyCell>(result, SWIGTYPE_p_LibertyCell, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_equiv_cells(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::equiv_cells cell1 cell2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equiv_cells" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equiv_cells" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      result = (bool)equiv_cells(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_equiv_cell_ports(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::equiv_cell_ports cell1 cell2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equiv_cell_ports" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equiv_cell_ports" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      result = (bool)equiv_cell_ports(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_equiv_cell_timing_arcs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::equiv_cell_timing_arcs cell1 cell2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equiv_cell_timing_arcs" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equiv_cell_timing_arcs" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      result = (bool)equiv_cell_timing_arcs(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_library_buffers(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCellSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_library_buffers library ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_library_buffers" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      result = (LibertyCellSeq *)find_library_buffers(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqPtrTclList<LibertyCellSeq, LibertyCell>(result, SWIGTYPE_p_LibertyCell, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_port_direction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::liberty_port_direction port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_port_direction" "', argument " "1"" of type '" "LibertyPort const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)liberty_port_direction((LibertyPort const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_supply_exists(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::liberty_supply_exists supply_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_supply_exists" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)liberty_supply_exists((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_library_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibraryIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::liberty_library_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (LibertyLibraryIterator *)liberty_library_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyLibraryIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_liberty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  LibertyLibrary *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_liberty name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_liberty" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (LibertyLibrary *)find_liberty((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_LibertyLibrary,0));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_liberty_cell name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_liberty_cell" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (LibertyCell *)find_liberty_cell((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_timing_role_is_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingRole *arg1 = (TimingRole *) 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::timing_role_is_check role ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[1], &length);
    TimingRole *role = TimingRole::find(arg);
    if (role)
    arg1 = TimingRole::find(arg);
    else {
      tclArgError(interp, 2154, "Unknown timing role '%s'.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (bool)timing_role_is_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Library_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Library *arg1 = (Library *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Library_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Library_name" "', argument " "1"" of type '" "Library *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  {
    try {
      result = (char *)Library_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Library_find_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Library *arg1 = (Library *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Library_find_cell self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Library_find_cell" "', argument " "1"" of type '" "Library *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Library_find_cell" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Cell *)Library_find_cell(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Library_find_cells_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Library *arg1 = (Library *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  CellSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Library_find_cells_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Library_find_cells_matching" "', argument " "1"" of type '" "Library *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Library_find_cells_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Library_find_cells_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Library_find_cells_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = Library_find_cells_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<CellSeq, Cell>(result, SWIGTYPE_p_Cell, interp);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


static swig_method swig_Library_methods[] = {
    {"name", _wrap_Library_name}, 
    {"find_cell", _wrap_Library_find_cell}, 
    {"find_cells_matching", _wrap_Library_find_cells_matching}, 
    {0,0}
};
static swig_attribute swig_Library_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Library_bases[] = {0};
static const char * swig_Library_base_names[] = {0};
static swig_class _wrap_class_Library = { "Library", &SWIGTYPE_p_Library,0,0, swig_Library_methods, swig_Library_attributes, swig_Library_bases,swig_Library_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibraryIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibraryIterator *arg1 = (LibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibraryIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibraryIterator_has_next" "', argument " "1"" of type '" "LibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibraryIterator * >(argp1);
  {
    try {
      result = (bool)LibraryIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibraryIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibraryIterator *arg1 = (LibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Library *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibraryIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibraryIterator_next" "', argument " "1"" of type '" "LibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibraryIterator * >(argp1);
  {
    try {
      result = (Library *)LibraryIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Library, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibraryIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibraryIterator *arg1 = (LibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibraryIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibraryIterator_finish" "', argument " "1"" of type '" "LibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibraryIterator * >(argp1);
  {
    try {
      LibraryIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibraryIterator_methods[] = {
    {"has_next", _wrap_LibraryIterator_has_next}, 
    {"next", _wrap_LibraryIterator_next}, 
    {"finish", _wrap_LibraryIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibraryIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibraryIterator_bases[] = {0};
static const char * swig_LibraryIterator_base_names[] = {0};
static swig_class _wrap_class_LibraryIterator = { "LibraryIterator", &SWIGTYPE_p_LibraryIterator,0,0, swig_LibraryIterator_methods, swig_LibraryIterator_attributes, swig_LibraryIterator_bases,swig_LibraryIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Cell_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_name" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (char *)Cell_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_library(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Library *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_library self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_library" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (Library *)Cell_library(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Library, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_liberty_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_liberty_cell" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (LibertyCell *)Cell_liberty_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_is_leaf" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (bool)Cell_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_port_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CellPortIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_port_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_port_iterator" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (CellPortIterator *)Cell_port_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_CellPortIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_get_attribute(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  string result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Cell_get_attribute self key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_get_attribute" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Cell_get_attribute" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = Cell_get_attribute(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    string &str = result;
    // String is volatile because it is deleted.
    Tcl_SetResult(interp, const_cast<char*>(str.c_str()), TCL_VOLATILE);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_find_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Cell_find_port self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_find_port" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Cell_find_port" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Port *)Cell_find_port(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_find_ports_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Cell_find_ports_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_find_ports_matching" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Cell_find_ports_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Cell_find_ports_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Cell_find_ports_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = Cell_find_ports_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PortSeq, Port>(result, SWIGTYPE_p_Port, interp);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


static swig_method swig_Cell_methods[] = {
    {"name", _wrap_Cell_name}, 
    {"library", _wrap_Cell_library}, 
    {"liberty_cell", _wrap_Cell_liberty_cell}, 
    {"is_leaf", _wrap_Cell_is_leaf}, 
    {"port_iterator", _wrap_Cell_port_iterator}, 
    {"get_attribute", _wrap_Cell_get_attribute}, 
    {"find_port", _wrap_Cell_find_port}, 
    {"find_ports_matching", _wrap_Cell_find_ports_matching}, 
    {0,0}
};
static swig_attribute swig_Cell_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Cell_bases[] = {0};
static const char * swig_Cell_base_names[] = {0};
static swig_class _wrap_class_Cell = { "Cell", &SWIGTYPE_p_Cell,0,0, swig_Cell_methods, swig_Cell_attributes, swig_Cell_bases,swig_Cell_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_CellPortIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  CellPortIterator *arg1 = (CellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::CellPortIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_CellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CellPortIterator_has_next" "', argument " "1"" of type '" "CellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< CellPortIterator * >(argp1);
  {
    try {
      result = (bool)CellPortIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_CellPortIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  CellPortIterator *arg1 = (CellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::CellPortIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_CellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CellPortIterator_next" "', argument " "1"" of type '" "CellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< CellPortIterator * >(argp1);
  {
    try {
      result = (Port *)CellPortIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_CellPortIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  CellPortIterator *arg1 = (CellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::CellPortIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_CellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CellPortIterator_finish" "', argument " "1"" of type '" "CellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< CellPortIterator * >(argp1);
  {
    try {
      CellPortIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_CellPortIterator_methods[] = {
    {"has_next", _wrap_CellPortIterator_has_next}, 
    {"next", _wrap_CellPortIterator_next}, 
    {"finish", _wrap_CellPortIterator_finish}, 
    {0,0}
};
static swig_attribute swig_CellPortIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_CellPortIterator_bases[] = {0};
static const char * swig_CellPortIterator_base_names[] = {0};
static swig_class _wrap_class_CellPortIterator = { "CellPortIterator", &SWIGTYPE_p_CellPortIterator,0,0, swig_CellPortIterator_methods, swig_CellPortIterator_attributes, swig_CellPortIterator_bases,swig_CellPortIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Port_bus_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_bus_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_bus_name" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (char *)Port_bus_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_cell" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (Cell *)Port_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_liberty_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_liberty_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_liberty_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (LibertyPort *)Port_liberty_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_is_bus(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_is_bus self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_is_bus" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (bool)Port_is_bus(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_member_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PortMemberIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_member_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_member_iterator" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (PortMemberIterator *)Port_member_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_PortMemberIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Port_methods[] = {
    {"bus_name", _wrap_Port_bus_name}, 
    {"cell", _wrap_Port_cell}, 
    {"liberty_port", _wrap_Port_liberty_port}, 
    {"is_bus", _wrap_Port_is_bus}, 
    {"member_iterator", _wrap_Port_member_iterator}, 
    {0,0}
};
static swig_attribute swig_Port_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Port_bases[] = {0};
static const char * swig_Port_base_names[] = {0};
static swig_class _wrap_class_Port = { "Port", &SWIGTYPE_p_Port,0,0, swig_Port_methods, swig_Port_attributes, swig_Port_bases,swig_Port_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PortMemberIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PortMemberIterator *arg1 = (PortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PortMemberIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortMemberIterator_has_next" "', argument " "1"" of type '" "PortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< PortMemberIterator * >(argp1);
  {
    try {
      result = (bool)PortMemberIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PortMemberIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PortMemberIterator *arg1 = (PortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PortMemberIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortMemberIterator_next" "', argument " "1"" of type '" "PortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< PortMemberIterator * >(argp1);
  {
    try {
      result = (Port *)PortMemberIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PortMemberIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PortMemberIterator *arg1 = (PortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PortMemberIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortMemberIterator_finish" "', argument " "1"" of type '" "PortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< PortMemberIterator * >(argp1);
  {
    try {
      PortMemberIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PortMemberIterator_methods[] = {
    {"has_next", _wrap_PortMemberIterator_has_next}, 
    {"next", _wrap_PortMemberIterator_next}, 
    {"finish", _wrap_PortMemberIterator_finish}, 
    {0,0}
};
static swig_attribute swig_PortMemberIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PortMemberIterator_bases[] = {0};
static const char * swig_PortMemberIterator_base_names[] = {0};
static swig_class _wrap_class_PortMemberIterator = { "PortMemberIterator", &SWIGTYPE_p_PortMemberIterator,0,0, swig_PortMemberIterator_methods, swig_PortMemberIterator_attributes, swig_PortMemberIterator_bases,swig_PortMemberIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Instance_parent(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_parent self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_parent" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (Instance *)Instance_parent(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_cell" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (Cell *)Instance_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_liberty_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_liberty_cell" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (LibertyCell *)Instance_liberty_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_is_leaf" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (bool)Instance_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_child_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InstanceChildIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_child_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_child_iterator" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (InstanceChildIterator *)Instance_child_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_InstanceChildIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InstancePinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_pin_iterator" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (InstancePinIterator *)Instance_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_InstancePinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_net_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InstanceNetIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_net_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_net_iterator" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (InstanceNetIterator *)Instance_net_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_InstanceNetIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_find_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Instance_find_pin self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_find_pin" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Instance_find_pin" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Pin *)Instance_find_pin(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_get_attribute(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  string result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Instance_get_attribute self key ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_get_attribute" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Instance_get_attribute" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = Instance_get_attribute(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    string &str = result;
    // String is volatile because it is deleted.
    Tcl_SetResult(interp, const_cast<char*>(str.c_str()), TCL_VOLATILE);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


static swig_method swig_Instance_methods[] = {
    {"parent", _wrap_Instance_parent}, 
    {"cell", _wrap_Instance_cell}, 
    {"liberty_cell", _wrap_Instance_liberty_cell}, 
    {"is_leaf", _wrap_Instance_is_leaf}, 
    {"child_iterator", _wrap_Instance_child_iterator}, 
    {"pin_iterator", _wrap_Instance_pin_iterator}, 
    {"net_iterator", _wrap_Instance_net_iterator}, 
    {"find_pin", _wrap_Instance_find_pin}, 
    {"get_attribute", _wrap_Instance_get_attribute}, 
    {0,0}
};
static swig_attribute swig_Instance_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Instance_bases[] = {0};
static const char * swig_Instance_base_names[] = {0};
static swig_class _wrap_class_Instance = { "Instance", &SWIGTYPE_p_Instance,0,0, swig_Instance_methods, swig_Instance_attributes, swig_Instance_bases,swig_Instance_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Pin_port_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_port_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_port_name" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char *)Pin_port_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_instance self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_instance" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Instance *)Pin_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_net self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_net" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Net *)Pin_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_port" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Port *)Pin_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_term(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Term *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_term self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_term" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Term *)Pin_term(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Term,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_liberty_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_liberty_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_liberty_port" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (LibertyPort *)Pin_liberty_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_driver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_driver self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_driver" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_driver(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_load(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_load self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_load" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_load(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_leaf" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_hierarchical(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_hierarchical self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_hierarchical" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_hierarchical(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_top_level_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_top_level_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_top_level_port" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_top_level_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_connected_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinConnectedPinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_connected_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_connected_pin_iterator" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (PinConnectedPinIterator *)Pin_connected_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj=SWIG_NewInstanceObj(result, SWIGTYPE_p_PinConnectedPinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_vertices(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex **result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_vertices self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_vertices" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Vertex **)Pin_vertices(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    int i = 0;
    Tcl_ResetResult(interp);
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    while (result[i]) {
      Tcl_Obj *obj = SWIG_NewInstanceObj(result[i], SWIGTYPE_p_Vertex,false);
      Tcl_ListObjAppendElement(interp, list, obj);
      i++;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Pin_methods[] = {
    {"port_name", _wrap_Pin_port_name}, 
    {"instance", _wrap_Pin_instance}, 
    {"net", _wrap_Pin_net}, 
    {"port", _wrap_Pin_port}, 
    {"term", _wrap_Pin_term}, 
    {"liberty_port", _wrap_Pin_liberty_port}, 
    {"is_driver", _wrap_Pin_is_driver}, 
    {"is_load", _wrap_Pin_is_load}, 
    {"is_leaf", _wrap_Pin_is_leaf}, 
    {"is_hierarchical", _wrap_Pin_is_hierarchical}, 
    {"is_top_level_port", _wrap_Pin_is_top_level_port}, 
    {"connected_pin_iterator", _wrap_Pin_connected_pin_iterator}, 
    {"vertices", _wrap_Pin_vertices}, 
    {0,0}
};
static swig_attribute swig_Pin_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Pin_bases[] = {0};
static const char * swig_Pin_base_names[] = {0};
static swig_class _wrap_class_Pin = { "Pin", &SWIGTYPE_p_Pin,0,0, swig_Pin_methods, swig_Pin_attributes, swig_Pin_bases,swig_Pin_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Term_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Term *arg1 = (Term *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Term_net self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Term, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Term_net" "', argument " "1"" of type '" "Term *""'"); 
  }
  arg1 = reinterpret_cast< Term * >(argp1);
  {
    try {
      result = (Net *)Term_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Term_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Term *arg1 = (Term *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Term_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Term, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Term_pin" "', argument " "1"" of type '" "Term *""'"); 
  }
  arg1 = reinterpret_cast< Term * >(argp1);
  {
    try {
      result = (Pin *)Term_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Term_methods[] = {
    {"net", _wrap_Term_net}, 
    {"pin", _wrap_Term_pin}, 
    {0,0}
};
static swig_attribute swig_Term_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Term_bases[] = {0};
static const char * swig_Term_base_names[] = {0};
static swig_class _wrap_class_Term = { "Term", &SWIGTYPE_p_Term,0,0, swig_Term_methods, swig_Term_attributes, swig_Term_bases,swig_Term_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_InstanceChildIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstanceChildIterator *arg1 = (InstanceChildIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceChildIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceChildIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceChildIterator_has_next" "', argument " "1"" of type '" "InstanceChildIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceChildIterator * >(argp1);
  {
    try {
      result = (bool)InstanceChildIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceChildIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstanceChildIterator *arg1 = (InstanceChildIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceChildIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceChildIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceChildIterator_next" "', argument " "1"" of type '" "InstanceChildIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceChildIterator * >(argp1);
  {
    try {
      result = (Instance *)InstanceChildIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceChildIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstanceChildIterator *arg1 = (InstanceChildIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceChildIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceChildIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceChildIterator_finish" "', argument " "1"" of type '" "InstanceChildIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceChildIterator * >(argp1);
  {
    try {
      InstanceChildIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_InstanceChildIterator_methods[] = {
    {"has_next", _wrap_InstanceChildIterator_has_next}, 
    {"next", _wrap_InstanceChildIterator_next}, 
    {"finish", _wrap_InstanceChildIterator_finish}, 
    {0,0}
};
static swig_attribute swig_InstanceChildIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_InstanceChildIterator_bases[] = {0};
static const char * swig_InstanceChildIterator_base_names[] = {0};
static swig_class _wrap_class_InstanceChildIterator = { "InstanceChildIterator", &SWIGTYPE_p_InstanceChildIterator,0,0, swig_InstanceChildIterator_methods, swig_InstanceChildIterator_attributes, swig_InstanceChildIterator_bases,swig_InstanceChildIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_InstancePinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstancePinIterator *arg1 = (InstancePinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstancePinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstancePinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstancePinIterator_has_next" "', argument " "1"" of type '" "InstancePinIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstancePinIterator * >(argp1);
  {
    try {
      result = (bool)InstancePinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstancePinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstancePinIterator *arg1 = (InstancePinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstancePinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstancePinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstancePinIterator_next" "', argument " "1"" of type '" "InstancePinIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstancePinIterator * >(argp1);
  {
    try {
      result = (Pin *)InstancePinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstancePinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstancePinIterator *arg1 = (InstancePinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstancePinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstancePinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstancePinIterator_finish" "', argument " "1"" of type '" "InstancePinIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstancePinIterator * >(argp1);
  {
    try {
      InstancePinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_InstancePinIterator_methods[] = {
    {"has_next", _wrap_InstancePinIterator_has_next}, 
    {"next", _wrap_InstancePinIterator_next}, 
    {"finish", _wrap_InstancePinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_InstancePinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_InstancePinIterator_bases[] = {0};
static const char * swig_InstancePinIterator_base_names[] = {0};
static swig_class _wrap_class_InstancePinIterator = { "InstancePinIterator", &SWIGTYPE_p_InstancePinIterator,0,0, swig_InstancePinIterator_methods, swig_InstancePinIterator_attributes, swig_InstancePinIterator_bases,swig_InstancePinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_InstanceNetIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstanceNetIterator *arg1 = (InstanceNetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceNetIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceNetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceNetIterator_has_next" "', argument " "1"" of type '" "InstanceNetIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceNetIterator * >(argp1);
  {
    try {
      result = (bool)InstanceNetIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceNetIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstanceNetIterator *arg1 = (InstanceNetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceNetIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceNetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceNetIterator_next" "', argument " "1"" of type '" "InstanceNetIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceNetIterator * >(argp1);
  {
    try {
      result = (Net *)InstanceNetIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceNetIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstanceNetIterator *arg1 = (InstanceNetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceNetIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceNetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceNetIterator_finish" "', argument " "1"" of type '" "InstanceNetIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceNetIterator * >(argp1);
  {
    try {
      InstanceNetIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_InstanceNetIterator_methods[] = {
    {"has_next", _wrap_InstanceNetIterator_has_next}, 
    {"next", _wrap_InstanceNetIterator_next}, 
    {"finish", _wrap_InstanceNetIterator_finish}, 
    {0,0}
};
static swig_attribute swig_InstanceNetIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_InstanceNetIterator_bases[] = {0};
static const char * swig_InstanceNetIterator_base_names[] = {0};
static swig_class _wrap_class_InstanceNetIterator = { "InstanceNetIterator", &SWIGTYPE_p_InstanceNetIterator,0,0, swig_InstanceNetIterator_methods, swig_InstanceNetIterator_attributes, swig_InstanceNetIterator_bases,swig_InstanceNetIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LeafInstanceIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LeafInstanceIterator *arg1 = (LeafInstanceIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LeafInstanceIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LeafInstanceIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LeafInstanceIterator_has_next" "', argument " "1"" of type '" "LeafInstanceIterator *""'"); 
  }
  arg1 = reinterpret_cast< LeafInstanceIterator * >(argp1);
  {
    try {
      result = (bool)LeafInstanceIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LeafInstanceIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LeafInstanceIterator *arg1 = (LeafInstanceIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LeafInstanceIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LeafInstanceIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LeafInstanceIterator_next" "', argument " "1"" of type '" "LeafInstanceIterator *""'"); 
  }
  arg1 = reinterpret_cast< LeafInstanceIterator * >(argp1);
  {
    try {
      result = (Instance *)LeafInstanceIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LeafInstanceIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LeafInstanceIterator *arg1 = (LeafInstanceIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LeafInstanceIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LeafInstanceIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LeafInstanceIterator_finish" "', argument " "1"" of type '" "LeafInstanceIterator *""'"); 
  }
  arg1 = reinterpret_cast< LeafInstanceIterator * >(argp1);
  {
    try {
      LeafInstanceIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LeafInstanceIterator_methods[] = {
    {"has_next", _wrap_LeafInstanceIterator_has_next}, 
    {"next", _wrap_LeafInstanceIterator_next}, 
    {"finish", _wrap_LeafInstanceIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LeafInstanceIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LeafInstanceIterator_bases[] = {0};
static const char * swig_LeafInstanceIterator_base_names[] = {0};
static swig_class _wrap_class_LeafInstanceIterator = { "LeafInstanceIterator", &SWIGTYPE_p_LeafInstanceIterator,0,0, swig_LeafInstanceIterator_methods, swig_LeafInstanceIterator_attributes, swig_LeafInstanceIterator_bases,swig_LeafInstanceIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Net_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_instance self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_instance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (Instance *)Net_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_highest_connected_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_highest_connected_net self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_highest_connected_net" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (Net *)Net_highest_connected_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  NetPinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_pin_iterator" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (NetPinIterator *)Net_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_NetPinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_term_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  NetTermIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_term_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_term_iterator" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (NetTermIterator *)Net_term_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_NetTermIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_connected_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  NetConnectedPinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_connected_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_connected_pin_iterator" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (NetConnectedPinIterator *)Net_connected_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj=SWIG_NewInstanceObj(result, SWIGTYPE_p_NetConnectedPinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_is_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_is_power self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_is_power" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (bool)Net_is_power(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_is_ground(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_is_ground self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_is_ground" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (bool)Net_is_ground(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Net_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_capacitance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Net_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Net_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_pin_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Net_pin_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_pin_capacitance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Net_pin_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Net_pin_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_wire_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Net_wire_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_wire_capacitance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Net_wire_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Net_wire_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_ports(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_ports self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_ports" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = Net_ports(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PortSeq, Port>(result, SWIGTYPE_p_Port, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Net_methods[] = {
    {"instance", _wrap_Net_instance}, 
    {"highest_connected_net", _wrap_Net_highest_connected_net}, 
    {"pin_iterator", _wrap_Net_pin_iterator}, 
    {"term_iterator", _wrap_Net_term_iterator}, 
    {"connected_pin_iterator", _wrap_Net_connected_pin_iterator}, 
    {"is_power", _wrap_Net_is_power}, 
    {"is_ground", _wrap_Net_is_ground}, 
    {"capacitance", _wrap_Net_capacitance}, 
    {"pin_capacitance", _wrap_Net_pin_capacitance}, 
    {"wire_capacitance", _wrap_Net_wire_capacitance}, 
    {"ports", _wrap_Net_ports}, 
    {0,0}
};
static swig_attribute swig_Net_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Net_bases[] = {0};
static const char * swig_Net_base_names[] = {0};
static swig_class _wrap_class_Net = { "Net", &SWIGTYPE_p_Net,0,0, swig_Net_methods, swig_Net_attributes, swig_Net_bases,swig_Net_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_NetPinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetPinIterator *arg1 = (NetPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetPinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetPinIterator_has_next" "', argument " "1"" of type '" "NetPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetPinIterator * >(argp1);
  {
    try {
      result = (bool)NetPinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetPinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetPinIterator *arg1 = (NetPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetPinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetPinIterator_next" "', argument " "1"" of type '" "NetPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetPinIterator * >(argp1);
  {
    try {
      result = (Pin *)NetPinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetPinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetPinIterator *arg1 = (NetPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetPinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetPinIterator_finish" "', argument " "1"" of type '" "NetPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetPinIterator * >(argp1);
  {
    try {
      NetPinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_NetPinIterator_methods[] = {
    {"has_next", _wrap_NetPinIterator_has_next}, 
    {"next", _wrap_NetPinIterator_next}, 
    {"finish", _wrap_NetPinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_NetPinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_NetPinIterator_bases[] = {0};
static const char * swig_NetPinIterator_base_names[] = {0};
static swig_class _wrap_class_NetPinIterator = { "NetPinIterator", &SWIGTYPE_p_NetPinIterator,0,0, swig_NetPinIterator_methods, swig_NetPinIterator_attributes, swig_NetPinIterator_bases,swig_NetPinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_NetTermIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetTermIterator *arg1 = (NetTermIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetTermIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetTermIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetTermIterator_has_next" "', argument " "1"" of type '" "NetTermIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetTermIterator * >(argp1);
  {
    try {
      result = (bool)NetTermIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetTermIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetTermIterator *arg1 = (NetTermIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Term *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetTermIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetTermIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetTermIterator_next" "', argument " "1"" of type '" "NetTermIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetTermIterator * >(argp1);
  {
    try {
      result = (Term *)NetTermIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Term,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetTermIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetTermIterator *arg1 = (NetTermIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetTermIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetTermIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetTermIterator_finish" "', argument " "1"" of type '" "NetTermIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetTermIterator * >(argp1);
  {
    try {
      NetTermIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_NetTermIterator_methods[] = {
    {"has_next", _wrap_NetTermIterator_has_next}, 
    {"next", _wrap_NetTermIterator_next}, 
    {"finish", _wrap_NetTermIterator_finish}, 
    {0,0}
};
static swig_attribute swig_NetTermIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_NetTermIterator_bases[] = {0};
static const char * swig_NetTermIterator_base_names[] = {0};
static swig_class _wrap_class_NetTermIterator = { "NetTermIterator", &SWIGTYPE_p_NetTermIterator,0,0, swig_NetTermIterator_methods, swig_NetTermIterator_attributes, swig_NetTermIterator_bases,swig_NetTermIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_NetConnectedPinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetConnectedPinIterator *arg1 = (NetConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetConnectedPinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetConnectedPinIterator_has_next" "', argument " "1"" of type '" "NetConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetConnectedPinIterator * >(argp1);
  {
    try {
      result = (bool)NetConnectedPinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetConnectedPinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetConnectedPinIterator *arg1 = (NetConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetConnectedPinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetConnectedPinIterator_next" "', argument " "1"" of type '" "NetConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetConnectedPinIterator * >(argp1);
  {
    try {
      result = (Pin *)NetConnectedPinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetConnectedPinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NetConnectedPinIterator *arg1 = (NetConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetConnectedPinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetConnectedPinIterator_finish" "', argument " "1"" of type '" "NetConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetConnectedPinIterator * >(argp1);
  {
    try {
      NetConnectedPinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_NetConnectedPinIterator_methods[] = {
    {"has_next", _wrap_NetConnectedPinIterator_has_next}, 
    {"next", _wrap_NetConnectedPinIterator_next}, 
    {"finish", _wrap_NetConnectedPinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_NetConnectedPinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_NetConnectedPinIterator_bases[] = {0};
static const char * swig_NetConnectedPinIterator_base_names[] = {0};
static swig_class _wrap_class_NetConnectedPinIterator = { "NetConnectedPinIterator", &SWIGTYPE_p_NetConnectedPinIterator,0,0, swig_NetConnectedPinIterator_methods, swig_NetConnectedPinIterator_attributes, swig_NetConnectedPinIterator_bases,swig_NetConnectedPinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PinConnectedPinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinConnectedPinIterator *arg1 = (PinConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PinConnectedPinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PinConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PinConnectedPinIterator_has_next" "', argument " "1"" of type '" "PinConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< PinConnectedPinIterator * >(argp1);
  {
    try {
      result = (bool)PinConnectedPinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PinConnectedPinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinConnectedPinIterator *arg1 = (PinConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PinConnectedPinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PinConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PinConnectedPinIterator_next" "', argument " "1"" of type '" "PinConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< PinConnectedPinIterator * >(argp1);
  {
    try {
      result = (Pin *)PinConnectedPinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PinConnectedPinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinConnectedPinIterator *arg1 = (PinConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PinConnectedPinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PinConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PinConnectedPinIterator_finish" "', argument " "1"" of type '" "PinConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< PinConnectedPinIterator * >(argp1);
  {
    try {
      PinConnectedPinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PinConnectedPinIterator_methods[] = {
    {"has_next", _wrap_PinConnectedPinIterator_has_next}, 
    {"next", _wrap_PinConnectedPinIterator_next}, 
    {"finish", _wrap_PinConnectedPinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_PinConnectedPinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PinConnectedPinIterator_bases[] = {0};
static const char * swig_PinConnectedPinIterator_base_names[] = {0};
static swig_class _wrap_class_PinConnectedPinIterator = { "PinConnectedPinIterator", &SWIGTYPE_p_PinConnectedPinIterator,0,0, swig_PinConnectedPinIterator_methods, swig_PinConnectedPinIterator_attributes, swig_PinConnectedPinIterator_bases,swig_PinConnectedPinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_network_is_linked(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_is_linked ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)network_is_linked(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_path_divider(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char arg1 ;
  char val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_path_divider divider ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_char SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_path_divider" "', argument " "1"" of type '" "char""'");
  } 
  arg1 = static_cast< char >(val1);
  {
    try {
      set_path_divider(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_current_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_current_instance inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_current_instance" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      set_current_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_instance_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_instance_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_instance_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_pin_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_pin_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_pin_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_net_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_net_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_net_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_leaf_instance_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_leaf_instance_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_leaf_instance_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_leaf_pin_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_leaf_pin_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_leaf_pin_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_library(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Library *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_library name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_library" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Library *)find_library((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Library, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_library_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibraryIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::library_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (LibraryIterator *)library_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibraryIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_cells_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  CellSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_cells_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_cells_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_cells_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_cells_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_cells_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<CellSeq, Cell>(result, SWIGTYPE_p_Cell, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_namespace_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_cmd_namespace_cmd namespc ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_namespace_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_cmd_namespace_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_link_design_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::link_design_cmd top_cell_name make_black_boxes ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "link_design_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "link_design_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = (bool)link_design_cmd((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_top_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::top_instance ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Instance *)top_instance(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_leaf_instance_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LeafInstanceIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::leaf_instance_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (LeafInstanceIterator *)leaf_instance_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LeafInstanceIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_direction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::port_direction port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_direction" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (char *)port_direction((Port const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_direction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_direction pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_direction" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char *)pin_direction((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_ports_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_ports_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_ports_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_ports_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_ports_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_ports_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PortSeq, Port>(result, SWIGTYPE_p_Port, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_port_pins_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_port_pins_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_port_pins_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_port_pins_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_port_pins_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_port_pins_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_pin path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pin" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Pin *)find_pin((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_get_port_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::get_port_pin port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "get_port_pin" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (Pin *)get_port_pin((Port const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pins_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_pins_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pins_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_pins_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_pins_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_pins_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pins_hier_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_pins_hier_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pins_hier_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_pins_hier_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_pins_hier_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_pins_hier_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_instance path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_instance" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Instance *)find_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_leaf_instances(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  InstanceSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_leaf_instances ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = network_leaf_instances(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<InstanceSeq, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_instances_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  InstanceSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_instances_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_instances_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_instances_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_instances_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_instances_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<InstanceSeq, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_instances_hier_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  InstanceSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_instances_hier_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_instances_hier_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_instances_hier_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_instances_hier_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_instances_hier_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<InstanceSeq, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_instances(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  InstanceSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_instances clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPtr<ClockSet, Clock>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_instances" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_instances" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = find_register_instances(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<InstanceSet, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_data_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_data_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPtr<ClockSet, Clock>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_data_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_data_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = find_register_data_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_clk_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_clk_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPtr<ClockSet, Clock>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_clk_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_clk_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = find_register_clk_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_async_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_async_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPtr<ClockSet, Clock>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_async_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_async_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = find_register_async_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_output_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_output_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPtr<ClockSet, Clock>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_output_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_output_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = find_register_output_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_net path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_net" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Net *)find_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_nets_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  NetSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_nets_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_nets_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_nets_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_nets_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_nets_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<NetSeq, Net>(result, SWIGTYPE_p_Net, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_nets_hier_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  NetSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_nets_hier_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_nets_hier_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_nets_hier_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_nets_hier_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_nets_hier_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<NetSeq, Net>(result, SWIGTYPE_p_Net, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_driver_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::net_driver_pins net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_driver_pins" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = net_driver_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_load_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::net_load_pins net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_load_pins" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = net_load_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_location(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_location pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_location" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char *)pin_location((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_location(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::port_location port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_location" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (char *)port_location((Port const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_instance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  Instance *arg3 = (Instance *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::make_instance_cmd name cell parent ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_instance_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "make_instance_cmd" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_instance_cmd" "', argument " "3"" of type '" "Instance *""'"); 
  }
  arg3 = reinterpret_cast< Instance * >(argp3);
  {
    try {
      result = (Instance *)make_instance_cmd((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_instance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_instance_cmd inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_instance_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      delete_instance_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_replace_cell_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::replace_cell_cmd inst to_cell ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "replace_cell_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "replace_cell_cmd" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      replace_cell_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_net_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  Instance *arg2 = (Instance *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::make_net_cmd name parent ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_net_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "make_net_cmd" "', argument " "2"" of type '" "Instance *""'"); 
  }
  arg2 = reinterpret_cast< Instance * >(argp2);
  {
    try {
      result = (Net *)make_net_cmd((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_port_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  PortDirection *arg2 = (PortDirection *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::make_port_pin_cmd port_name dir ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_port_pin_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    PortDirection *dir = PortDirection::find(arg);
    if (dir == nullptr) {
      tclArgError(interp, 2153, "Unknown port direction '%s'.", arg);
      return TCL_ERROR;
    }
    else
    arg2 = dir;
  }
  {
    try {
      make_port_pin_cmd((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_net_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_net_cmd net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_net_cmd" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      delete_net_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_connect_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  Port *arg2 = (Port *) 0 ;
  Net *arg3 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::connect_pin_cmd inst port net ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "connect_pin_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "connect_pin_cmd" "', argument " "2"" of type '" "Port *""'"); 
  }
  arg2 = reinterpret_cast< Port * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "connect_pin_cmd" "', argument " "3"" of type '" "Net *""'"); 
  }
  arg3 = reinterpret_cast< Net * >(argp3);
  {
    try {
      connect_pin_cmd(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disconnect_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disconnect_pin_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disconnect_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      disconnect_pin_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_changed(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_changed ") == TCL_ERROR) SWIG_fail;
  {
    try {
      network_changed(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_spef_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  Instance *arg2 = (Instance *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  bool arg5 ;
  bool arg6 ;
  float arg7 ;
  bool arg8 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  float val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooo:sta::read_spef_cmd filename instance corner min_max pin_cap_included keep_coupling_caps coupling_cap_factor reduce ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_spef_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_spef_cmd" "', argument " "2"" of type '" "Instance *""'"); 
  }
  arg2 = reinterpret_cast< Instance * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "read_spef_cmd" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "read_spef_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "read_spef_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "read_spef_cmd" "', argument " "7"" of type '" "float""'");
  } 
  arg7 = static_cast< float >(val7);
  ecode8 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "read_spef_cmd" "', argument " "8"" of type '" "bool""'");
  } 
  arg8 = static_cast< bool >(val8);
  {
    try {
      result = (bool)read_spef_cmd((char const *)arg1,arg2,(Corner const *)arg3,(MinMaxAll const *)arg4,arg5,arg6,arg7,arg8); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_parasitic_annotation_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  Corner *arg2 = (Corner *) 0 ;
  bool val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_parasitic_annotation_cmd report_unannotated corner ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_parasitic_annotation_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_parasitic_annotation_cmd" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    try {
      report_parasitic_annotation_cmd(arg1,(Corner const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pi_elmore(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_pi_elmore drvr_pin rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pi_elmore" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = find_pi_elmore(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_elmore(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFall *arg3 = (RiseFall *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_elmore drvr_pin load_pin rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_elmore" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "find_elmore" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg3 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)find_elmore(arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pi_model_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_pi_model_cmd drvr_pin rf min_max c2 rpi c1 ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_pi_model_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_pi_model_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_pi_model_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_pi_model_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_pi_model_cmd(arg1,arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_elmore_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFall *arg3 = (RiseFall *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_elmore_cmd drvr_pin load_pin rf min_max elmore ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_elmore_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_elmore_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg3 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_elmore_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_elmore_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pushPowerResultFloats(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PowerResult *arg1 = 0 ;
  FloatSeq *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::pushPowerResultFloats power powers ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1, SWIGTYPE_p_PowerResult,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pushPowerResultFloats" "', argument " "1"" of type '" "PowerResult &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "pushPowerResultFloats" "', argument " "1"" of type '" "PowerResult &""'"); 
  }
  arg1 = reinterpret_cast< PowerResult * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2, SWIGTYPE_p_FloatSeq,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pushPowerResultFloats" "', argument " "2"" of type '" "FloatSeq &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "pushPowerResultFloats" "', argument " "2"" of type '" "FloatSeq &""'"); 
  }
  arg2 = reinterpret_cast< FloatSeq * >(argp2);
  {
    try {
      pushPowerResultFloats(*arg1,*arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_design_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::design_power corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "design_power" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = design_power((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_instance_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  FloatSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::instance_power inst corner ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "instance_power" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "instance_power" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    try {
      result = instance_power(arg1,(Corner const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq &floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (float f : floats) {
      Tcl_Obj *obj = Tcl_NewDoubleObj(f);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_global_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_power_global_activity activity duty ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_power_global_activity" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_global_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_power_global_activity(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_input_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_power_input_activity activity duty ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_power_input_activity" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_input_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_power_input_activity(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_input_port_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_power_input_port_activity input_port activity duty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_power_input_port_activity" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_input_port_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_power_input_port_activity" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_power_input_port_activity((Port const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_pin_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_power_pin_activity pin activity duty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_power_pin_activity" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_pin_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_power_pin_activity" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_power_pin_activity((Pin const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clock_min_period(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::clock_min_period ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)clock_min_period(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_highest_power_instances(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  size_t arg1 ;
  Corner *arg2 = (Corner *) 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  InstanceSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::highest_power_instances count corner ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "highest_power_instances" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "highest_power_instances" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    try {
      result = highest_power_instances(SWIG_STD_MOVE(arg1),(Corner const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<InstanceSeq, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_vcd_file(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::read_vcd_file filename scope ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_vcd_file" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_vcd_file" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      read_vcd_file((char const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_saif_file(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::read_saif_file filename scope ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_saif_file" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_saif_file" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (bool)read_saif_file((char const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_activity_annotation_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_activity_annotation_cmd report_unannotated report_annotated ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_activity_annotation_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_activity_annotation_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_activity_annotation_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_period(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_period self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_period" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (float)Clock_period(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_waveform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_waveform self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_waveform" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (FloatSeq *)Clock_waveform(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (float f : *floats) {
        Tcl_Obj *obj = Tcl_NewDoubleObj(f);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Clock_time self rf ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_time" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    try {
      result = (float)Clock_time(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_is_generated(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_is_generated self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_is_generated" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_is_generated(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_waveform_valid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_waveform_valid self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_waveform_valid" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_waveform_valid(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_is_virtual(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_is_virtual self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_is_virtual" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_is_virtual(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_is_propagated(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_is_propagated self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_is_propagated" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_is_propagated(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_sources(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_sources self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_sources" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (PinSet *) &Clock_sources(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    // A swig bug sets the result to PinSet* rather than const PinSet&.
    PinSet *pins = result;
    for (const Pin *pin : *pins) {
      Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_slew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Clock_slew self rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_slew" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Clock_slew(arg1,(RiseFall const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Clock_methods[] = {
    {"period", _wrap_Clock_period}, 
    {"waveform", _wrap_Clock_waveform}, 
    {"time", _wrap_Clock_time}, 
    {"is_generated", _wrap_Clock_is_generated}, 
    {"waveform_valid", _wrap_Clock_waveform_valid}, 
    {"is_virtual", _wrap_Clock_is_virtual}, 
    {"is_propagated", _wrap_Clock_is_propagated}, 
    {"sources", _wrap_Clock_sources}, 
    {"slew", _wrap_Clock_slew}, 
    {0,0}
};
static swig_attribute swig_Clock_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Clock_bases[] = {0};
static const char * swig_Clock_base_names[] = {0};
static swig_class _wrap_class_Clock = { "Clock", &SWIGTYPE_p_Clock,0,0, swig_Clock_methods, swig_Clock_attributes, swig_Clock_bases,swig_Clock_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_ClockEdge_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockEdge *arg1 = (ClockEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockEdge_clock self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockEdge_clock" "', argument " "1"" of type '" "ClockEdge *""'"); 
  }
  arg1 = reinterpret_cast< ClockEdge * >(argp1);
  {
    try {
      result = (Clock *)ClockEdge_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_ClockEdge_transition(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockEdge *arg1 = (ClockEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RiseFall *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockEdge_transition self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockEdge_transition" "', argument " "1"" of type '" "ClockEdge *""'"); 
  }
  arg1 = reinterpret_cast< ClockEdge * >(argp1);
  {
    try {
      result = (RiseFall *)ClockEdge_transition(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const RiseFall *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_ClockEdge_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockEdge *arg1 = (ClockEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockEdge_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockEdge_time" "', argument " "1"" of type '" "ClockEdge *""'"); 
  }
  arg1 = reinterpret_cast< ClockEdge * >(argp1);
  {
    try {
      result = (float)ClockEdge_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_ClockEdge_methods[] = {
    {"clock", _wrap_ClockEdge_clock}, 
    {"transition", _wrap_ClockEdge_transition}, 
    {"time", _wrap_ClockEdge_time}, 
    {0,0}
};
static swig_attribute swig_ClockEdge_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ClockEdge_bases[] = {0};
static const char * swig_ClockEdge_base_names[] = {0};
static swig_class _wrap_class_ClockEdge = { "ClockEdge", &SWIGTYPE_p_ClockEdge,0,0, swig_ClockEdge_methods, swig_ClockEdge_attributes, swig_ClockEdge_bases,swig_ClockEdge_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_ExceptionFrom_methods[] = {
    {0,0}
};
static swig_attribute swig_ExceptionFrom_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ExceptionFrom_bases[] = {0};
static const char * swig_ExceptionFrom_base_names[] = {0};
static swig_class _wrap_class_ExceptionFrom = { "ExceptionFrom", &SWIGTYPE_p_ExceptionFrom,0,0, swig_ExceptionFrom_methods, swig_ExceptionFrom_attributes, swig_ExceptionFrom_bases,swig_ExceptionFrom_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_ExceptionThru_methods[] = {
    {0,0}
};
static swig_attribute swig_ExceptionThru_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ExceptionThru_bases[] = {0};
static const char * swig_ExceptionThru_base_names[] = {0};
static swig_class _wrap_class_ExceptionThru = { "ExceptionThru", &SWIGTYPE_p_ExceptionThru,0,0, swig_ExceptionThru_methods, swig_ExceptionThru_attributes, swig_ExceptionThru_bases,swig_ExceptionThru_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_ExceptionTo_methods[] = {
    {0,0}
};
static swig_attribute swig_ExceptionTo_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ExceptionTo_bases[] = {0};
static const char * swig_ExceptionTo_base_names[] = {0};
static swig_class _wrap_class_ExceptionTo = { "ExceptionTo", &SWIGTYPE_p_ExceptionTo,0,0, swig_ExceptionTo_methods, swig_ExceptionTo_attributes, swig_ExceptionTo_bases,swig_ExceptionTo_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_OperatingConditions_process(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::OperatingConditions_process self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OperatingConditions_process" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    try {
      result = (float)OperatingConditions_process(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_OperatingConditions_voltage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::OperatingConditions_voltage self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OperatingConditions_voltage" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    try {
      result = (float)OperatingConditions_voltage(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_OperatingConditions_temperature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::OperatingConditions_temperature self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OperatingConditions_temperature" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    try {
      result = (float)OperatingConditions_temperature(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_OperatingConditions_methods[] = {
    {"process", _wrap_OperatingConditions_process}, 
    {"voltage", _wrap_OperatingConditions_voltage}, 
    {"temperature", _wrap_OperatingConditions_temperature}, 
    {0,0}
};
static swig_attribute swig_OperatingConditions_attributes[] = {
    {0,0,0}
};
static swig_class *swig_OperatingConditions_bases[] = {0};
static const char * swig_OperatingConditions_base_names[] = {0};
static swig_class _wrap_class_OperatingConditions = { "OperatingConditions", &SWIGTYPE_p_OperatingConditions,0,0, swig_OperatingConditions_methods, swig_OperatingConditions_attributes, swig_OperatingConditions_bases,swig_OperatingConditions_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_write_sdc_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  bool arg5 ;
  bool arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::write_sdc_cmd filename leaf compatible digits gzip no_timestamp ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_sdc_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "write_sdc_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "write_sdc_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "write_sdc_cmd" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "write_sdc_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "write_sdc_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  {
    try {
      write_sdc_cmd((char const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_analysis_type_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_analysis_type_cmd analysis_type ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_analysis_type_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_analysis_type_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_operating_conditions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  OperatingConditions *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::operating_conditions min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (OperatingConditions *)operating_conditions((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_OperatingConditions, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_operating_conditions_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_operating_conditions_cmd op_cond min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_operating_conditions_cmd" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_operating_conditions_cmd(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_operating_condition_analysis_type(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::operating_condition_analysis_type ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)operating_condition_analysis_type(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_instance_pvt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_instance_pvt inst min_max process voltage temperature ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_instance_pvt" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_instance_pvt" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_instance_pvt" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_instance_pvt" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_instance_pvt(arg1,(MinMaxAll const *)arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_ext_pin_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::port_ext_pin_cap port corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_ext_pin_cap" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "port_ext_pin_cap" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)port_ext_pin_cap((Port const *)arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_ext_pin_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_port_ext_pin_cap port rf corner min_max cap ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_ext_pin_cap" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_port_ext_pin_cap" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_port_ext_pin_cap" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_port_ext_pin_cap((Port const *)arg1,(RiseFallBoth const *)arg2,(Corner const *)arg3,(MinMaxAll const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_ext_wire_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::port_ext_wire_cap port corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_ext_wire_cap" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "port_ext_wire_cap" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)port_ext_wire_cap((Port const *)arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_ext_wire_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  bool arg2 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  Corner *arg4 = (Corner *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_port_ext_wire_cap port subtract_pin_cap rf corner min_max cap ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_ext_wire_cap" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_port_ext_wire_cap" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "set_port_ext_wire_cap" "', argument " "4"" of type '" "Corner const *""'"); 
  }
  arg4 = reinterpret_cast< Corner * >(argp4);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_port_ext_wire_cap" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_port_ext_wire_cap((Port const *)arg1,arg2,(RiseFallBoth const *)arg3,(Corner const *)arg4,(MinMaxAll const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_ext_fanout_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  int arg2 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_port_ext_fanout_cmd port fanout corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_ext_fanout_cmd" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_port_ext_fanout_cmd" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_port_ext_fanout_cmd" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_port_ext_fanout_cmd((Port const *)arg1,arg2,(Corner const *)arg3,(MinMaxAll const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_ext_fanout(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::port_ext_fanout port corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_ext_fanout" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "port_ext_fanout" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)port_ext_fanout((Port const *)arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_net_wire_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_net_wire_cap net subtract_pin_cap corner min_max cap ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_net_wire_cap" "', argument " "1"" of type '" "Net const *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_net_wire_cap" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_net_wire_cap" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_net_wire_cap" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_net_wire_cap((Net const *)arg1,arg2,(Corner const *)arg3,(MinMaxAll const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_wire_load_mode_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_wire_load_mode_cmd mode_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_wire_load_mode_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_wire_load_mode_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_net_resistance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_net_resistance net min_max res ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_net_resistance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_net_resistance" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_net_resistance(arg1,(MinMaxAll const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_wire_load_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Wireload *arg1 = (Wireload *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_wire_load_cmd wireload min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Wireload, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_wire_load_cmd" "', argument " "1"" of type '" "Wireload *""'"); 
  }
  arg1 = reinterpret_cast< Wireload * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_wire_load_cmd(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_wire_load_selection_group_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  WireloadSelection *arg1 = (WireloadSelection *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_wire_load_selection_group_cmd selection min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_WireloadSelection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_wire_load_selection_group_cmd" "', argument " "1"" of type '" "WireloadSelection *""'"); 
  }
  arg1 = reinterpret_cast< WireloadSelection * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_wire_load_selection_group_cmd(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  PinSet *arg2 = (PinSet *) 0 ;
  bool arg3 ;
  float arg4 ;
  FloatSeq *arg5 = (FloatSeq *) 0 ;
  char *arg6 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::make_clock name pins add_to_pins period waveform comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_clock" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    Network *network = Sta::sta()->ensureLinked();
    arg2 = tclListNetworkSet<PinSet, Pin>(objv[2], SWIGTYPE_p_Pin, interp, network);
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "make_clock" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "make_clock" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    Tcl_Size argc;
    Tcl_Obj **argv;
    FloatSeq *floats = nullptr;
    
    if (Tcl_ListObjGetElements(interp, objv[5], &argc, &argv) == TCL_OK) {
      if (argc)
      floats = new FloatSeq;
      for (int i = 0; i < argc; i++) {
        char *arg = Tcl_GetString(argv[i]);
        double value;
        if (Tcl_GetDouble(interp, arg, &value) == TCL_OK)
        floats->push_back(static_cast<float>(value));
        else {
          delete floats;
          tclArgError(interp, 2157, "%s is not a floating point number.", arg);
          return TCL_ERROR;
        }
      }
    }
    arg5 = floats;
  }
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "make_clock" "', argument " "6"" of type '" "char *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  {
    try {
      make_clock((char const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_generated_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  PinSet *arg2 = (PinSet *) 0 ;
  bool arg3 ;
  Pin *arg4 = (Pin *) 0 ;
  Clock *arg5 = (Clock *) 0 ;
  int arg6 ;
  int arg7 ;
  float arg8 ;
  bool arg9 ;
  bool arg10 ;
  IntSeq *arg11 = (IntSeq *) 0 ;
  FloatSeq *arg12 = (FloatSeq *) 0 ;
  char *arg13 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  float val8 ;
  int ecode8 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  bool val10 ;
  int ecode10 = 0 ;
  int res13 ;
  char *buf13 = 0 ;
  int alloc13 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooooooooo:sta::make_generated_clock name pins add_to_pins src_pin master_clk divide_by multiply_by duty_cycle invert combinational edges edge_shifts comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_generated_clock" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    Network *network = Sta::sta()->ensureLinked();
    arg2 = tclListNetworkSet<PinSet, Pin>(objv[2], SWIGTYPE_p_Pin, interp, network);
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "make_generated_clock" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "make_generated_clock" "', argument " "4"" of type '" "Pin *""'"); 
  }
  arg4 = reinterpret_cast< Pin * >(argp4);
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "make_generated_clock" "', argument " "5"" of type '" "Clock *""'"); 
  }
  arg5 = reinterpret_cast< Clock * >(argp5);
  ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "make_generated_clock" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  ecode7 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "make_generated_clock" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = static_cast< int >(val7);
  ecode8 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "make_generated_clock" "', argument " "8"" of type '" "float""'");
  } 
  arg8 = static_cast< float >(val8);
  ecode9 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "make_generated_clock" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = static_cast< bool >(val9);
  ecode10 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "make_generated_clock" "', argument " "10"" of type '" "bool""'");
  } 
  arg10 = static_cast< bool >(val10);
  {
    Tcl_Size argc;
    Tcl_Obj **argv;
    IntSeq *ints = nullptr;
    
    if (Tcl_ListObjGetElements(interp, objv[11], &argc, &argv) == TCL_OK) {
      if (argc)
      ints = new IntSeq;
      for (int i = 0; i < argc; i++) {
        char *arg = Tcl_GetString(argv[i]);
        int value;
        if (Tcl_GetInt(interp, arg, &value) == TCL_OK)
        ints->push_back(value);
        else {
          delete ints;
          tclArgError(interp, 2158, "%s is not an integer.", arg);
          return TCL_ERROR;
        }
      }
    }
    arg11 = ints;
  }
  {
    Tcl_Size argc;
    Tcl_Obj **argv;
    FloatSeq *floats = nullptr;
    
    if (Tcl_ListObjGetElements(interp, objv[12], &argc, &argv) == TCL_OK) {
      if (argc)
      floats = new FloatSeq;
      for (int i = 0; i < argc; i++) {
        char *arg = Tcl_GetString(argv[i]);
        double value;
        if (Tcl_GetDouble(interp, arg, &value) == TCL_OK)
        floats->push_back(static_cast<float>(value));
        else {
          delete floats;
          tclArgError(interp, 2157, "%s is not a floating point number.", arg);
          return TCL_ERROR;
        }
      }
    }
    arg12 = floats;
  }
  res13 = SWIG_AsCharPtrAndSize(objv[13], &buf13, NULL, &alloc13);
  if (!SWIG_IsOK(res13)) {
    SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "make_generated_clock" "', argument " "13"" of type '" "char *""'");
  }
  arg13 = reinterpret_cast< char * >(buf13);
  {
    try {
      make_generated_clock((char const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc13 == SWIG_NEWOBJ) delete[] buf13;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc13 == SWIG_NEWOBJ) delete[] buf13;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_remove_clock_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::remove_clock_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "remove_clock_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      remove_clock_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagated_clock_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagated_clock_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_propagated_clock_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      set_propagated_clock_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagated_clock_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagated_clock_pin_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_propagated_clock_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      set_propagated_clock_pin_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_propagated_clock_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_propagated_clock_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_propagated_clock_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      unset_propagated_clock_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_propagated_clock_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_propagated_clock_pin_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_propagated_clock_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_propagated_clock_pin_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_slew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_clock_slew_cmd clk rf min_max slew ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_slew_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_slew_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_clock_slew_cmd(arg1,(RiseFallBoth const *)arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_slew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_slew_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_slew_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      unset_clock_slew_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_latency_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_latency_cmd clk pin rf min_max delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_latency_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_clock_latency_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_clock_latency_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_clock_latency_cmd(arg1,arg2,(RiseFallBoth const *)arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_insertion_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  EarlyLateAll *arg5 = (EarlyLateAll *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_clock_insertion_cmd clk pin rf min_max early_late delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_insertion_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_clock_insertion_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    EarlyLateAll *early_late = EarlyLateAll::find(arg);
    if (early_late)
    arg5 = early_late;
    else {
      tclArgError(interp, 2165, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_clock_insertion_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_clock_insertion_cmd(arg1,arg2,(RiseFallBoth const *)arg3,(MinMaxAll const *)arg4,(EarlyLateAll const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_latency_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_latency_cmd clk pin ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_latency_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_clock_latency_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    try {
      unset_clock_latency_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_insertion_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_insertion_cmd clk pin ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_insertion_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_clock_insertion_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    try {
      unset_clock_insertion_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_uncertainty_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  SetupHoldAll *arg2 = (SetupHoldAll *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_clock_uncertainty_clk clk setup_hold uncertainty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_uncertainty_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg2 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg2 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg2 = SetupHoldAll::all();
    else {
      tclArgError(interp, 2163, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_uncertainty_clk" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_clock_uncertainty_clk(arg1,(SetupHoldAll const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_uncertainty_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  SetupHoldAll *arg2 = (SetupHoldAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_uncertainty_clk clk setup_hold ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_uncertainty_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg2 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg2 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg2 = SetupHoldAll::all();
    else {
      tclArgError(interp, 2163, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_clock_uncertainty_clk(arg1,(SetupHoldAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_uncertainty_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_clock_uncertainty_pin pin min_max uncertainty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_uncertainty_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_uncertainty_pin" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_clock_uncertainty_pin(arg1,(MinMaxAll const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_uncertainty_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_uncertainty_pin pin min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_uncertainty_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_clock_uncertainty_pin(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_inter_clock_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_inter_clock_uncertainty from_clk from_tr to_clk to_tr min_max uncertainty ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_inter_clock_uncertainty" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_inter_clock_uncertainty" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_inter_clock_uncertainty" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_inter_clock_uncertainty(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,(MinMaxAll const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_inter_clock_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::unset_inter_clock_uncertainty from_clk from_tr to_clk to_tr min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_inter_clock_uncertainty" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_inter_clock_uncertainty" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_inter_clock_uncertainty(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,(MinMaxAll const *)arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  RiseFallBoth *arg1 = (RiseFallBoth *) 0 ;
  SetupHold *arg2 = (SetupHold *) 0 ;
  float arg3 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_clock_gating_check_cmd rf setup_hold margin ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[1], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg1 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg2 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg2 = MinMax::max();
    else {
      tclArgError(interp, 2162, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_gating_check_cmd" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_clock_gating_check_cmd((RiseFallBoth const *)arg1,(SetupHold const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_clk_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_clock_gating_check_clk_cmd clk rf setup_hold margin ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_gating_check_clk_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, 2162, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_gating_check_clk_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_clock_gating_check_clk_cmd(arg1,(RiseFallBoth const *)arg2,(SetupHold const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  float arg4 ;
  LogicValue arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_gating_check_pin_cmd pin rf setup_hold margin active_value ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_gating_check_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, 2162, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_gating_check_pin_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[5], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg5 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg5 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg5 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg5 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg5 = LogicValue::fall;
    else {
      tclArgError(interp, 2155, "Unknown logic value '%s'.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_clock_gating_check_pin_cmd(arg1,(RiseFallBoth const *)arg2,(SetupHold const *)arg3,arg4,SWIG_STD_MOVE(arg5)); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_instance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  float arg4 ;
  LogicValue arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_gating_check_instance_cmd inst rf setup_hold margin active_value ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_gating_check_instance_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, 2162, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_gating_check_instance_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[5], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg5 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg5 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg5 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg5 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg5 = LogicValue::fall;
    else {
      tclArgError(interp, 2155, "Unknown logic value '%s'.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_clock_gating_check_instance_cmd(arg1,(RiseFallBoth const *)arg2,(SetupHold const *)arg3,arg4,SWIG_STD_MOVE(arg5)); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_data_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Pin *arg3 = (Pin *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  Clock *arg5 = (Clock *) 0 ;
  SetupHoldAll *arg6 = (SetupHoldAll *) 0 ;
  float arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  float val7 ;
  int ecode7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::set_data_check_cmd from from_rf to to_rf clk setup_hold margin ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_data_check_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_data_check_cmd" "', argument " "3"" of type '" "Pin *""'"); 
  }
  arg3 = reinterpret_cast< Pin * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "set_data_check_cmd" "', argument " "5"" of type '" "Clock *""'"); 
  }
  arg5 = reinterpret_cast< Clock * >(argp5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg6 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg6 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg6 = SetupHoldAll::all();
    else {
      tclArgError(interp, 2163, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode7 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "set_data_check_cmd" "', argument " "7"" of type '" "float""'");
  } 
  arg7 = static_cast< float >(val7);
  {
    try {
      set_data_check_cmd(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,arg5,(SetupHoldAll const *)arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_data_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Pin *arg3 = (Pin *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  Clock *arg5 = (Clock *) 0 ;
  SetupHoldAll *arg6 = (SetupHoldAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::unset_data_check_cmd from from_tr to to_tr clk setup_hold ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_data_check_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_data_check_cmd" "', argument " "3"" of type '" "Pin *""'"); 
  }
  arg3 = reinterpret_cast< Pin * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "unset_data_check_cmd" "', argument " "5"" of type '" "Clock *""'"); 
  }
  arg5 = reinterpret_cast< Clock * >(argp5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg6 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg6 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg6 = SetupHoldAll::all();
    else {
      tclArgError(interp, 2163, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_data_check_cmd(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,arg5,(SetupHoldAll const *)arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_input_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  Pin *arg5 = (Pin *) 0 ;
  bool arg6 ;
  bool arg7 ;
  MinMaxAll *arg8 = (MinMaxAll *) 0 ;
  bool arg9 ;
  float arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  float val10 ;
  int ecode10 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooooo:sta::set_input_delay_cmd pin rf clk clk_rf ref_pin source_latency_included network_latency_included min_max add delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_input_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_input_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "set_input_delay_cmd" "', argument " "5"" of type '" "Pin *""'"); 
  }
  arg5 = reinterpret_cast< Pin * >(argp5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_input_delay_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "set_input_delay_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[8], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg8 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode9 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "set_input_delay_cmd" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = static_cast< bool >(val9);
  ecode10 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "set_input_delay_cmd" "', argument " "10"" of type '" "float""'");
  } 
  arg10 = static_cast< float >(val10);
  {
    try {
      set_input_delay_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_input_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::unset_input_delay_cmd pin rf clk clk_rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_input_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_input_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_input_delay_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_output_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  Pin *arg5 = (Pin *) 0 ;
  bool arg6 ;
  bool arg7 ;
  MinMaxAll *arg8 = (MinMaxAll *) 0 ;
  bool arg9 ;
  float arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  float val10 ;
  int ecode10 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooooo:sta::set_output_delay_cmd pin rf clk clk_rf ref_pin source_latency_included network_latency_included min_max add delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_output_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_output_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "set_output_delay_cmd" "', argument " "5"" of type '" "Pin *""'"); 
  }
  arg5 = reinterpret_cast< Pin * >(argp5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_output_delay_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "set_output_delay_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[8], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg8 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode9 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "set_output_delay_cmd" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = static_cast< bool >(val9);
  ecode10 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "set_output_delay_cmd" "', argument " "10"" of type '" "float""'");
  } 
  arg10 = static_cast< float >(val10);
  {
    try {
      set_output_delay_cmd(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFall const *)arg4,arg5,arg6,arg7,(MinMaxAll const *)arg8,arg9,arg10); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_output_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::unset_output_delay_cmd pin rf clk clk_rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_output_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_output_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_output_delay_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::disable_cell cell from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_cell" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "disable_cell" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "disable_cell" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      disable_cell(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::unset_disable_cell cell from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_cell" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_disable_cell" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_disable_cell" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      unset_disable_cell(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_lib_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_lib_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_lib_port" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      disable_lib_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_lib_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_lib_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_lib_port" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      unset_disable_lib_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      disable_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      unset_disable_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::disable_instance instance from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_instance" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "disable_instance" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "disable_instance" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      disable_instance(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::unset_disable_instance instance from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_instance" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_disable_instance" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_disable_instance" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      unset_disable_instance(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      disable_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_disable_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_edge edge ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_edge" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      disable_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_edge edge ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_edge" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      unset_disable_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_timing_arc_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_timing_arc_set arc_set ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_timing_arc_set" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      disable_timing_arc_set(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_timing_arc_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_timing_arc_set arc_set ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_timing_arc_set" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      unset_disable_timing_arc_set(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_clock_gating_check_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_clock_gating_check_inst inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_clock_gating_check_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      disable_clock_gating_check_inst(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_clock_gating_check_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_clock_gating_check_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_clock_gating_check_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      disable_clock_gating_check_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_clock_gating_check_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_clock_gating_check_inst inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_clock_gating_check_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      unset_disable_clock_gating_check_inst(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_clock_gating_check_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_clock_gating_check_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_clock_gating_check_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_disable_clock_gating_check_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disabled_edges_sorted(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  EdgeSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::disabled_edges_sorted ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = disabled_edges_sorted(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<EdgeSeq, Edge>(result, SWIGTYPE_p_Edge, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_timing_arc_disabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::timing_arc_disabled edge arc ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "timing_arc_disabled" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "timing_arc_disabled" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  {
    try {
      result = (bool)timing_arc_disabled(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_false_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  char *arg5 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::make_false_path from thrus to min_max comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_false_path" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeqPtr<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_false_path" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  res5 = SWIG_AsCharPtrAndSize(objv[5], &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "make_false_path" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = reinterpret_cast< char * >(buf5);
  {
    try {
      make_false_path(arg1,arg2,arg3,(MinMaxAll const *)arg4,(char const *)arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return TCL_OK;
fail:
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_multicycle_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  bool arg5 ;
  int arg6 ;
  char *arg7 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::make_multicycle_path from thrus to min_max use_end_clk path_multiplier comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_multicycle_path" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeqPtr<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_multicycle_path" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "make_multicycle_path" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "make_multicycle_path" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "make_multicycle_path" "', argument " "7"" of type '" "char const *""'");
  }
  arg7 = reinterpret_cast< char * >(buf7);
  {
    try {
      make_multicycle_path(arg1,arg2,arg3,(MinMaxAll const *)arg4,arg5,arg6,(char const *)arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_OK;
fail:
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_path_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  bool arg5 ;
  float arg6 ;
  char *arg7 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::make_path_delay from thrus to min_max ignore_clk_latency delay comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_path_delay" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeqPtr<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_path_delay" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "make_path_delay" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "make_path_delay" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "make_path_delay" "', argument " "7"" of type '" "char const *""'");
  }
  arg7 = reinterpret_cast< char * >(buf7);
  {
    try {
      make_path_delay(arg1,arg2,arg3,(MinMax const *)arg4,arg5,arg6,(char const *)arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_OK;
fail:
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_reset_path_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::reset_path_cmd from thrus to min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "reset_path_cmd" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeqPtr<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "reset_path_cmd" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      reset_path_cmd(arg1,arg2,arg3,(MinMaxAll const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_group_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  ExceptionFrom *arg3 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg4 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg5 = (ExceptionTo *) 0 ;
  char *arg6 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::make_group_path name is_default from thrus to comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_group_path" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "make_group_path" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_group_path" "', argument " "3"" of type '" "ExceptionFrom *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionFrom * >(argp3);
  {
    arg4 = tclListSeqPtr<ExceptionThru*>(objv[4], SWIGTYPE_p_ExceptionThru, interp);
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "make_group_path" "', argument " "5"" of type '" "ExceptionTo *""'"); 
  }
  arg5 = reinterpret_cast< ExceptionTo * >(argp5);
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "make_group_path" "', argument " "6"" of type '" "char const *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  {
    try {
      make_group_path((char const *)arg1,arg2,arg3,arg4,arg5,(char const *)arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_path_group_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_path_group_name name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_path_group_name" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)is_path_group_name((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_exception_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  InstanceSet *arg3 = (InstanceSet *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  ExceptionFrom *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::make_exception_from from_pins from_clks from_insts from_tr ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    Network *network = Sta::sta()->ensureLinked();
    arg1 = tclListNetworkSet<PinSet, Pin>(objv[1], SWIGTYPE_p_Pin, interp, network);
  }
  {
    arg2 = tclListSetPtr<ClockSet, Clock>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  {
    Network *network = Sta::sta()->ensureLinked();
    arg3 = tclListNetworkSet<InstanceSet, Instance>(objv[3], SWIGTYPE_p_Instance,
      interp, network);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    try {
      result = (ExceptionFrom *)make_exception_from(arg1,arg2,arg3,(RiseFallBoth const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_ExceptionFrom, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_exception_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_exception_from from ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_exception_from" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    try {
      delete_exception_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_exception_from_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::check_exception_from_pins from file line ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_exception_from_pins" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "check_exception_from_pins" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "check_exception_from_pins" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      check_exception_from_pins(arg1,(char const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_exception_thru(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  NetSet *arg2 = (NetSet *) 0 ;
  InstanceSet *arg3 = (InstanceSet *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  ExceptionThru *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::make_exception_thru pins nets insts rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    Network *network = Sta::sta()->ensureLinked();
    arg1 = tclListNetworkSet<PinSet, Pin>(objv[1], SWIGTYPE_p_Pin, interp, network);
  }
  {
    Network *network = Sta::sta()->ensureLinked();
    arg2 = tclListNetworkSet<NetSet, Net>(objv[2], SWIGTYPE_p_Net, interp, network);
  }
  {
    Network *network = Sta::sta()->ensureLinked();
    arg3 = tclListNetworkSet<InstanceSet, Instance>(objv[3], SWIGTYPE_p_Instance,
      interp, network);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    try {
      result = (ExceptionThru *)make_exception_thru(arg1,arg2,arg3,(RiseFallBoth const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_ExceptionThru, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_exception_thru(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionThru *arg1 = (ExceptionThru *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_exception_thru thru ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionThru, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_exception_thru" "', argument " "1"" of type '" "ExceptionThru *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionThru * >(argp1);
  {
    try {
      delete_exception_thru(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_exception_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  InstanceSet *arg3 = (InstanceSet *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  RiseFallBoth *arg5 = (RiseFallBoth *) 0 ;
  ExceptionTo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::make_exception_to to_pins to_clks to_insts rf end_rf ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    Network *network = Sta::sta()->ensureLinked();
    arg1 = tclListNetworkSet<PinSet, Pin>(objv[1], SWIGTYPE_p_Pin, interp, network);
  }
  {
    arg2 = tclListSetPtr<ClockSet, Clock>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  {
    Network *network = Sta::sta()->ensureLinked();
    arg3 = tclListNetworkSet<InstanceSet, Instance>(objv[3], SWIGTYPE_p_Instance,
      interp, network);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[5], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg5 = tr;
  }
  {
    try {
      result = (ExceptionTo *)make_exception_to(arg1,arg2,arg3,(RiseFallBoth const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_ExceptionTo, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_exception_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionTo *arg1 = (ExceptionTo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_exception_to to ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_exception_to" "', argument " "1"" of type '" "ExceptionTo *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionTo * >(argp1);
  {
    try {
      delete_exception_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_exception_to_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionTo *arg1 = (ExceptionTo *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::check_exception_to_pins to file line ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_exception_to_pins" "', argument " "1"" of type '" "ExceptionTo *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionTo * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "check_exception_to_pins" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "check_exception_to_pins" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      check_exception_to_pins(arg1,(char const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_clock_groups(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  char *arg6 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  ClockGroups *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::make_clock_groups name logically_exclusive physically_exclusive asynchronous allow_paths comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_clock_groups" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "make_clock_groups" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "make_clock_groups" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "make_clock_groups" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "make_clock_groups" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "make_clock_groups" "', argument " "6"" of type '" "char const *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  {
    try {
      result = (ClockGroups *)make_clock_groups((char const *)arg1,arg2,arg3,arg4,arg5,(char const *)arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_ClockGroups,0));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clock_groups_make_group(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ClockGroups *arg1 = (ClockGroups *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::clock_groups_make_group clk_groups clks ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockGroups, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clock_groups_make_group" "', argument " "1"" of type '" "ClockGroups *""'"); 
  }
  arg1 = reinterpret_cast< ClockGroups * >(argp1);
  {
    arg2 = tclListSetPtr<ClockSet, Clock>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  {
    try {
      clock_groups_make_group(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_groups_logically_exclusive(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_groups_logically_exclusive name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_groups_logically_exclusive" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      unset_clock_groups_logically_exclusive((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_groups_physically_exclusive(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_groups_physically_exclusive name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_groups_physically_exclusive" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      unset_clock_groups_physically_exclusive((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_groups_asynchronous(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_groups_asynchronous name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_groups_asynchronous" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      unset_clock_groups_asynchronous((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_same_clk_group(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Clock *arg2 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::same_clk_group clk1 clk2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "same_clk_group" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "same_clk_group" "', argument " "2"" of type '" "Clock *""'"); 
  }
  arg2 = reinterpret_cast< Clock * >(argp2);
  {
    try {
      result = (bool)same_clk_group(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_sense_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_sense_cmd pins clks positive negative stop_propagation ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    Network *network = Sta::sta()->ensureLinked();
    arg1 = tclListNetworkSet<PinSet, Pin>(objv[1], SWIGTYPE_p_Pin, interp, network);
  }
  {
    arg2 = tclListSetPtr<ClockSet, Clock>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_sense_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_sense_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_clock_sense_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      set_clock_sense_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_input_slew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_input_slew_cmd port rf min_max slew ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_input_slew_cmd" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_input_slew_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_input_slew_cmd(arg1,(RiseFallBoth const *)arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_drive_cell_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  Port *arg3 = (Port *) 0 ;
  LibertyPort *arg4 = (LibertyPort *) 0 ;
  float arg5 ;
  float arg6 ;
  LibertyPort *arg7 = (LibertyPort *) 0 ;
  RiseFallBoth *arg8 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg9 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooooo:sta::set_drive_cell_cmd library cell port from_port from_slew_rise from_slew_fall to_port rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_drive_cell_cmd" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_drive_cell_cmd" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_drive_cell_cmd" "', argument " "3"" of type '" "Port *""'"); 
  }
  arg3 = reinterpret_cast< Port * >(argp3);
  res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "set_drive_cell_cmd" "', argument " "4"" of type '" "LibertyPort *""'"); 
  }
  arg4 = reinterpret_cast< LibertyPort * >(argp4);
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_drive_cell_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_drive_cell_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  res7 = SWIG_ConvertPtr(objv[7], &argp7,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "set_drive_cell_cmd" "', argument " "7"" of type '" "LibertyPort *""'"); 
  }
  arg7 = reinterpret_cast< LibertyPort * >(argp7);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[8], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg8 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[9], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg9 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_drive_cell_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,(RiseFallBoth const *)arg8,(MinMaxAll const *)arg9); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_drive_resistance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_drive_resistance_cmd port rf min_max res ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_drive_resistance_cmd" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_drive_resistance_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_drive_resistance_cmd(arg1,(RiseFallBoth const *)arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_slew_limit_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  PathClkOrData arg3 ;
  MinMax *arg4 = (MinMax *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_slew_limit_clk clk rf clk_data min_max slew ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_slew_limit_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEq(arg, "clk"))
    arg3 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg3 = PathClkOrData::data;
    else {
      tclArgError(interp, 2168, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_slew_limit_clk" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_slew_limit_clk(arg1,(RiseFallBoth const *)arg2,SWIG_STD_MOVE(arg3),(MinMax const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_slew_limit_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_slew_limit_port port min_max slew ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_slew_limit_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_slew_limit_port" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_slew_limit_port(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_slew_limit_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_slew_limit_cell cell min_max slew ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_slew_limit_cell" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_slew_limit_cell" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_slew_limit_cell(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_capacitance_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_port_capacitance_limit port min_max cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_capacitance_limit" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_port_capacitance_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_port_capacitance_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pin_capacitance_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_pin_capacitance_limit pin min_max cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_pin_capacitance_limit" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_pin_capacitance_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_pin_capacitance_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cell_capacitance_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_cell_capacitance_limit cell min_max cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cell_capacitance_limit" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_cell_capacitance_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_cell_capacitance_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_latch_borrow_limit_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_latch_borrow_limit_pin pin limit ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_latch_borrow_limit_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_latch_borrow_limit_pin" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_latch_borrow_limit_pin(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_latch_borrow_limit_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_latch_borrow_limit_inst inst limit ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_latch_borrow_limit_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_latch_borrow_limit_inst" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_latch_borrow_limit_inst(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_latch_borrow_limit_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_latch_borrow_limit_clk clk limit ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_latch_borrow_limit_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_latch_borrow_limit_clk" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_latch_borrow_limit_clk(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_global(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  RiseFallBoth *arg1 = (RiseFallBoth *) 0 ;
  float arg2 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_min_pulse_width_global rf min_width ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[1], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg1 = tr;
  }
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_min_pulse_width_global" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_min_pulse_width_global((RiseFallBoth const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_min_pulse_width_pin pin rf min_width ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_min_pulse_width_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_min_pulse_width_pin" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_min_pulse_width_pin(arg1,(RiseFallBoth const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_min_pulse_width_clk clk rf min_width ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_min_pulse_width_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_min_pulse_width_clk" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_min_pulse_width_clk(arg1,(RiseFallBoth const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_min_pulse_width_inst inst rf min_width ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_min_pulse_width_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_min_pulse_width_inst" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_min_pulse_width_inst(arg1,(RiseFallBoth const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_max_area_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float arg1 ;
  float val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_max_area_cmd area ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_max_area_cmd" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  {
    try {
      set_max_area_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_fanout_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_port_fanout_limit port min_max fanout ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_fanout_limit" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_port_fanout_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_port_fanout_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cell_fanout_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_cell_fanout_limit cell min_max fanout ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cell_fanout_limit" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_cell_fanout_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_cell_fanout_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_logic_value_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  LogicValue arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_logic_value_cmd pin value ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_logic_value_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg2 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg2 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg2 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg2 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg2 = LogicValue::fall;
    else {
      tclArgError(interp, 2155, "Unknown logic value '%s'.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_logic_value_cmd(arg1,SWIG_STD_MOVE(arg2)); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_case_analysis_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  LogicValue arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_case_analysis_cmd pin value ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_case_analysis_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg2 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg2 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg2 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg2 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg2 = LogicValue::fall;
    else {
      tclArgError(interp, 2155, "Unknown logic value '%s'.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_case_analysis_cmd(arg1,SWIG_STD_MOVE(arg2)); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_case_analysis_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_case_analysis_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_case_analysis_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_case_analysis_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingDerateType arg1 ;
  PathClkOrData arg2 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  EarlyLate *arg4 = (EarlyLate *) 0 ;
  float arg5 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_timing_derate_cmd type clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    if (stringEq(arg, "net_delay"))
    arg1 = TimingDerateType::net_delay;
    else if (stringEq(arg, "cell_delay"))
    arg1 = TimingDerateType::cell_delay;
    else if (stringEq(arg, "cell_check"))
    arg1 = TimingDerateType::cell_check;
    else {
      tclArgError(interp, 2166, "%s not net_delay, cell_delay or cell_check.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "clk"))
    arg2 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg2 = PathClkOrData::data;
    else {
      tclArgError(interp, 2168, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg4 = early_late;
    else {
      tclArgError(interp, 2164, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_timing_derate_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_timing_derate_cmd(SWIG_STD_MOVE(arg1),SWIG_STD_MOVE(arg2),(RiseFallBoth const *)arg3,(EarlyLate const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_net_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  PathClkOrData arg2 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  EarlyLate *arg4 = (EarlyLate *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_timing_derate_net_cmd net clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_timing_derate_net_cmd" "', argument " "1"" of type '" "Net const *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "clk"))
    arg2 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg2 = PathClkOrData::data;
    else {
      tclArgError(interp, 2168, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg4 = early_late;
    else {
      tclArgError(interp, 2164, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_timing_derate_net_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_timing_derate_net_cmd((Net const *)arg1,SWIG_STD_MOVE(arg2),(RiseFallBoth const *)arg3,(EarlyLate const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_inst_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  TimingDerateCellType arg2 ;
  PathClkOrData arg3 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  EarlyLate *arg5 = (EarlyLate *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_timing_derate_inst_cmd inst type clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_timing_derate_inst_cmd" "', argument " "1"" of type '" "Instance const *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "cell_delay"))
    arg2 = TimingDerateCellType::cell_delay;
    else if (stringEq(arg, "cell_check"))
    arg2 = TimingDerateCellType::cell_check;
    else {
      tclArgError(interp, 2167, "%s not cell_delay or cell_check.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEq(arg, "clk"))
    arg3 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg3 = PathClkOrData::data;
    else {
      tclArgError(interp, 2168, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg5 = early_late;
    else {
      tclArgError(interp, 2164, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_timing_derate_inst_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_timing_derate_inst_cmd((Instance const *)arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),(RiseFallBoth const *)arg4,(EarlyLate const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_cell_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  TimingDerateCellType arg2 ;
  PathClkOrData arg3 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  EarlyLate *arg5 = (EarlyLate *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_timing_derate_cell_cmd cell type clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_timing_derate_cell_cmd" "', argument " "1"" of type '" "LibertyCell const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "cell_delay"))
    arg2 = TimingDerateCellType::cell_delay;
    else if (stringEq(arg, "cell_check"))
    arg2 = TimingDerateCellType::cell_check;
    else {
      tclArgError(interp, 2167, "%s not cell_delay or cell_check.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEq(arg, "clk"))
    arg3 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg3 = PathClkOrData::data;
    else {
      tclArgError(interp, 2168, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      tclArgError(interp, 2152, "Unknown transition name '%s'.", arg);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg5 = early_late;
    else {
      tclArgError(interp, 2164, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_timing_derate_cell_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_timing_derate_cell_cmd((LibertyCell const *)arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3),(RiseFallBoth const *)arg4,(EarlyLate const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_timing_derate_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::unset_timing_derate_cmd ") == TCL_ERROR) SWIG_fail;
  {
    try {
      unset_timing_derate_cmd(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_clock name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_clock" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Clock *)find_clock((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_clock_src(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_clock_src pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_clock_src" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_clock_src((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_default_arrival_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::default_arrival_clock ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Clock *)default_arrival_clock(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_clocks_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  ClockSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_clocks_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_clocks_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_clocks_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_clocks_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = find_clocks_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<ClockSeq, Clock>(result, SWIGTYPE_p_Clock, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_update_generated_clks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::update_generated_clks ") == TCL_ERROR) SWIG_fail;
  {
    try {
      update_generated_clks(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_clock pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_clock" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_ideal_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_ideal_clock pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_ideal_clock" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_ideal_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_clock_search(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_clock_search pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_clock_search" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_clock_search((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_genclk_src(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_genclk_src pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_genclk_src" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_genclk_src((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_is_constrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_is_constrained pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_is_constrained" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)pin_is_constrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_instance_is_constrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::instance_is_constrained inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "instance_is_constrained" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (bool)instance_is_constrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_is_constrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::net_is_constrained net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_is_constrained" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (bool)net_is_constrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clk_thru_tristate_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::clk_thru_tristate_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)clk_thru_tristate_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clk_thru_tristate_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_clk_thru_tristate_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_clk_thru_tristate_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_clk_thru_tristate_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_remove_constraints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::remove_constraints ") == TCL_ERROR) SWIG_fail;
  {
    try {
      remove_constraints(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_all_inputs_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  PortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::all_inputs_cmd no_clocks ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "all_inputs_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      result = all_inputs_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PortSeq, Port>(result, SWIGTYPE_p_Port, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_all_outputs_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::all_outputs_cmd ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = all_outputs_cmd(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PortSeq, Port>(result, SWIGTYPE_p_Port, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_ports(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  PortSeq *arg4 = (PortSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_ports property op pattern ports ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_ports" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_ports" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_ports" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<const Port*>(objv[4], SWIGTYPE_p_Port, interp);
  }
  {
    try {
      result = filter_ports((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PortSeq, Port>(result, SWIGTYPE_p_Port, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_insts(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  InstanceSeq *arg4 = (InstanceSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  InstanceSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_insts property op pattern insts ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_insts" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_insts" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_insts" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<const Instance*>(objv[4], SWIGTYPE_p_Instance, interp);
  }
  {
    try {
      result = filter_insts((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<InstanceSeq, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  PinSeq *arg4 = (PinSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_pins property op pattern pins ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_pins" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_pins" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_pins" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<const Pin*>(objv[4], SWIGTYPE_p_Pin, interp);
  }
  {
    try {
      result = filter_pins((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_clocks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  ClockSeq *arg4 = (ClockSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  ClockSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_clocks property op pattern clocks ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_clocks" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_clocks" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_clocks" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<Clock*>(objv[4], SWIGTYPE_p_Clock, interp);
  }
  {
    try {
      result = filter_clocks((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<ClockSeq, Clock>(result, SWIGTYPE_p_Clock, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_lib_cells(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  LibertyCellSeq *arg4 = (LibertyCellSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  LibertyCellSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_lib_cells property op pattern cells ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_lib_cells" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_lib_cells" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_lib_cells" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<LibertyCell*>(objv[4], SWIGTYPE_p_LibertyCell, interp);
  }
  {
    try {
      result = filter_lib_cells((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<LibertyCellSeq, LibertyCell>(result, SWIGTYPE_p_LibertyCell, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_lib_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  LibertyPortSeq *arg4 = (LibertyPortSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  LibertyPortSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_lib_pins property op pattern pins ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_lib_pins" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_lib_pins" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_lib_pins" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<LibertyPort*>(objv[4], SWIGTYPE_p_LibertyPort, interp);
  }
  {
    try {
      result = filter_lib_pins((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<LibertyPortSeq, LibertyPort>(result, SWIGTYPE_p_LibertyPort, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_liberty_libraries(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  LibertyLibrarySeq *arg4 = (LibertyLibrarySeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  LibertyLibrarySeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_liberty_libraries property op pattern libs ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_liberty_libraries" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_liberty_libraries" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_liberty_libraries" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<LibertyLibrary*>(objv[4], SWIGTYPE_p_LibertyLibrary, interp);
  }
  {
    try {
      result = filter_liberty_libraries((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<LibertyLibrarySeq, LibertyLibrary>(result, SWIGTYPE_p_LibertyLibrary, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_nets(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  NetSeq *arg4 = (NetSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  NetSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_nets property op pattern nets ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_nets" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_nets" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_nets" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<const Net*>(objv[4], SWIGTYPE_p_Net, interp);
  }
  {
    try {
      result = filter_nets((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<NetSeq, Net>(result, SWIGTYPE_p_Net, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_timing_arcs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  EdgeSeq *arg4 = (EdgeSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  EdgeSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_timing_arcs property op pattern edges ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_timing_arcs" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_timing_arcs" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_timing_arcs" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeqPtr<Edge*>(objv[4], SWIGTYPE_p_Edge, interp);
  }
  {
    try {
      result = filter_timing_arcs((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<EdgeSeq, Edge>(result, SWIGTYPE_p_Edge, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_path_group_names(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  StringSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::path_group_names ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = path_group_names(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq &strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    for (const char *str : strs) {
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_voltage_global(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  float arg2 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_voltage_global min_max voltage ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_voltage_global" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_voltage_global((MinMax const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_voltage_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_voltage_net net min_max voltage ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_voltage_net" "', argument " "1"" of type '" "Net const *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_voltage_net" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_voltage_net((Net const *)arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_group_path_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::group_path_pins group_path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "group_path_pins" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = group_path_pins((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_case_logic_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_case_logic_value pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_case_logic_value" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char)pin_case_logic_value((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_char(static_cast< char >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_logic_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_logic_value pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_logic_value" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char)pin_logic_value((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_char(static_cast< char >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_propagate_all_clocks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::propagate_all_clocks ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)propagate_all_clocks(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagate_all_clocks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagate_all_clocks prop ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_propagate_all_clocks" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_propagate_all_clocks(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_sdf_file(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  bool arg4 ;
  bool arg5 ;
  MinMaxAllNull *arg6 = (MinMaxAllNull *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::read_sdf_file filename path corner unescaped_dividers incremental_only cond_use ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_sdf_file" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_sdf_file" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "read_sdf_file" "', argument " "3"" of type '" "Corner *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "read_sdf_file" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "read_sdf_file" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    if (stringEqual(arg, "NULL"))
    arg6 = nullptr;
    else {
      MinMaxAll *min_max = MinMaxAll::find(arg);
      if (min_max)
      arg6 = min_max;
      else {
        tclArgError(interp, 2161, "%s not min, max or min_max.", arg);
        return TCL_ERROR;
      }
    }
  }
  {
    try {
      result = (bool)read_sdf_file((char const *)arg1,(char const *)arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_annotated_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  unsigned int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool arg8 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooo:sta::report_annotated_delay_cmd report_cells report_nets report_in_ports report_out_ports max_lines list_annotated list_not_annotated report_constant_arcs ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_annotated_delay_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_annotated_delay_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_annotated_delay_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "report_annotated_delay_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "report_annotated_delay_cmd" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "report_annotated_delay_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "report_annotated_delay_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  ecode8 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "report_annotated_delay_cmd" "', argument " "8"" of type '" "bool""'");
  } 
  arg8 = static_cast< bool >(val8);
  {
    try {
      report_annotated_delay_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_annotated_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool arg8 ;
  unsigned int arg9 ;
  bool arg10 ;
  bool arg11 ;
  bool arg12 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  unsigned int val9 ;
  int ecode9 = 0 ;
  bool val10 ;
  int ecode10 = 0 ;
  bool val11 ;
  int ecode11 = 0 ;
  bool val12 ;
  int ecode12 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooooooo:sta::report_annotated_check_cmd report_setup report_hold report_recovery report_removal report_nochange report_width report_period report_max_skew max_lines list_annotated list_not_annotated report_constant_arcs ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_annotated_check_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_annotated_check_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_annotated_check_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "report_annotated_check_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "report_annotated_check_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "report_annotated_check_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "report_annotated_check_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  ecode8 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "report_annotated_check_cmd" "', argument " "8"" of type '" "bool""'");
  } 
  arg8 = static_cast< bool >(val8);
  ecode9 = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "report_annotated_check_cmd" "', argument " "9"" of type '" "unsigned int""'");
  } 
  arg9 = static_cast< unsigned int >(val9);
  ecode10 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "report_annotated_check_cmd" "', argument " "10"" of type '" "bool""'");
  } 
  arg10 = static_cast< bool >(val10);
  ecode11 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[11], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "report_annotated_check_cmd" "', argument " "11"" of type '" "bool""'");
  } 
  arg11 = static_cast< bool >(val11);
  ecode12 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[12], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "report_annotated_check_cmd" "', argument " "12"" of type '" "bool""'");
  } 
  arg12 = static_cast< bool >(val12);
  {
    try {
      report_annotated_check_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_sdf_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  char arg3 ;
  bool arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool arg8 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooo:sta::write_sdf_cmd filename corner divider include_typ digits gzip no_timestamp no_version ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_sdf_cmd" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write_sdf_cmd" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  ecode3 = SWIG_AsVal_char SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "write_sdf_cmd" "', argument " "3"" of type '" "char""'");
  } 
  arg3 = static_cast< char >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "write_sdf_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "write_sdf_cmd" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "write_sdf_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "write_sdf_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  ecode8 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "write_sdf_cmd" "', argument " "8"" of type '" "bool""'");
  } 
  arg8 = static_cast< bool >(val8);
  {
    try {
      write_sdf_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexPathIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexPathIterator *arg1 = (VertexPathIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexPathIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexPathIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexPathIterator_has_next" "', argument " "1"" of type '" "VertexPathIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexPathIterator * >(argp1);
  {
    try {
      result = (bool)VertexPathIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexPathIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexPathIterator *arg1 = (VertexPathIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexPathIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexPathIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexPathIterator_next" "', argument " "1"" of type '" "VertexPathIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexPathIterator * >(argp1);
  {
    try {
      result = (PathRef *)VertexPathIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexPathIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  VertexPathIterator *arg1 = (VertexPathIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexPathIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexPathIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexPathIterator_finish" "', argument " "1"" of type '" "VertexPathIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexPathIterator * >(argp1);
  {
    try {
      VertexPathIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexPathIterator_methods[] = {
    {"has_next", _wrap_VertexPathIterator_has_next}, 
    {"next", _wrap_VertexPathIterator_next}, 
    {"finish", _wrap_VertexPathIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexPathIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexPathIterator_bases[] = {0};
static const char * swig_VertexPathIterator_base_names[] = {0};
static swig_class _wrap_class_VertexPathIterator = { "VertexPathIterator", &SWIGTYPE_p_VertexPathIterator,0,0, swig_VertexPathIterator_methods, swig_VertexPathIterator_attributes, swig_VertexPathIterator_bases,swig_VertexPathIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PathRef_arrival(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_arrival self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_arrival" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (float)PathRef_arrival(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_required(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_required self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_required" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (float)PathRef_required(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_slack self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_slack" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (float)PathRef_slack(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_pin" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (Pin *)PathRef_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_tag(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_tag self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_tag" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (char *)PathRef_tag(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_pins self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_pins" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = PathRef_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PathRef_methods[] = {
    {"arrival", _wrap_PathRef_arrival}, 
    {"required", _wrap_PathRef_required}, 
    {"slack", _wrap_PathRef_slack}, 
    {"pin", _wrap_PathRef_pin}, 
    {"tag", _wrap_PathRef_tag}, 
    {"pins", _wrap_PathRef_pins}, 
    {0,0}
};
static swig_attribute swig_PathRef_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PathRef_bases[] = {0};
static const char * swig_PathRef_base_names[] = {0};
static swig_class _wrap_class_PathRef = { "PathRef", &SWIGTYPE_p_PathRef,0,0, swig_PathRef_methods, swig_PathRef_attributes, swig_PathRef_bases,swig_PathRef_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PathEnd_is_unconstrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_unconstrained self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_unconstrained" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_unconstrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_check self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_check" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_latch_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_latch_check self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_latch_check" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_latch_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_data_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_data_check self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_data_check" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_data_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_output_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_output_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_output_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_output_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_path_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_path_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_path_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_path_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_gated_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_gated_clock self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_gated_clock" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_gated_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_vertex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_vertex self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_vertex" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (Vertex *)PathEnd_vertex(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_path" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (PathRef *)PathEnd_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_end_transition(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RiseFall *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_end_transition self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_end_transition" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (RiseFall *)PathEnd_end_transition(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const RiseFall *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_slack self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_slack" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_slack(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_margin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ArcDelay result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_margin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_margin" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_margin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_data_required_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Required result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_data_required_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_data_required_time" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_data_required_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_data_arrival_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_data_arrival_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_data_arrival_time" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_data_arrival_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_check_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_check_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_check_role" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (TimingRole *)PathEnd_check_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_min_max(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinMax *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_min_max self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_min_max" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (MinMax *)PathEnd_min_max(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_source_clk_offset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_source_clk_offset self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_source_clk_offset" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_source_clk_offset(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_source_clk_latency(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_source_clk_latency self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_source_clk_latency" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_source_clk_latency(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_source_clk_insertion_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_source_clk_insertion_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_source_clk_insertion_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_source_clk_insertion_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (Clock *)PathEnd_target_clk(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ClockEdge *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_edge self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_edge" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (ClockEdge *)PathEnd_target_clk_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result,SWIGTYPE_p_ClockEdge, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Path *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_path" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (Path *)PathEnd_target_clk_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Path,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_time" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_offset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_offset self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_offset" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_offset(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_mcp_adjustment(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_mcp_adjustment self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_mcp_adjustment" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_mcp_adjustment(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_target_clk_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_insertion_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_insertion_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_insertion_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_target_clk_insertion_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_uncertainty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_uncertainty" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_uncertainty(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_inter_clk_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_inter_clk_uncertainty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_inter_clk_uncertainty" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_inter_clk_uncertainty(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_arrival(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_arrival self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_arrival" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_target_clk_arrival(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_path_delay_margin_is_external(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_path_delay_margin_is_external self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_path_delay_margin_is_external" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_path_delay_margin_is_external(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_check_crpr(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Crpr result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_check_crpr self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_check_crpr" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_check_crpr(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_end_trans(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RiseFall *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_end_trans self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_end_trans" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (RiseFall *)PathEnd_target_clk_end_trans(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const RiseFall *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_clk_skew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Delay result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_clk_skew self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_clk_skew" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_clk_skew(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PathEnd_methods[] = {
    {"is_unconstrained", _wrap_PathEnd_is_unconstrained}, 
    {"is_check", _wrap_PathEnd_is_check}, 
    {"is_latch_check", _wrap_PathEnd_is_latch_check}, 
    {"is_data_check", _wrap_PathEnd_is_data_check}, 
    {"is_output_delay", _wrap_PathEnd_is_output_delay}, 
    {"is_path_delay", _wrap_PathEnd_is_path_delay}, 
    {"is_gated_clock", _wrap_PathEnd_is_gated_clock}, 
    {"vertex", _wrap_PathEnd_vertex}, 
    {"path", _wrap_PathEnd_path}, 
    {"end_transition", _wrap_PathEnd_end_transition}, 
    {"slack", _wrap_PathEnd_slack}, 
    {"margin", _wrap_PathEnd_margin}, 
    {"data_required_time", _wrap_PathEnd_data_required_time}, 
    {"data_arrival_time", _wrap_PathEnd_data_arrival_time}, 
    {"check_role", _wrap_PathEnd_check_role}, 
    {"min_max", _wrap_PathEnd_min_max}, 
    {"source_clk_offset", _wrap_PathEnd_source_clk_offset}, 
    {"source_clk_latency", _wrap_PathEnd_source_clk_latency}, 
    {"source_clk_insertion_delay", _wrap_PathEnd_source_clk_insertion_delay}, 
    {"target_clk", _wrap_PathEnd_target_clk}, 
    {"target_clk_edge", _wrap_PathEnd_target_clk_edge}, 
    {"target_clk_path", _wrap_PathEnd_target_clk_path}, 
    {"target_clk_time", _wrap_PathEnd_target_clk_time}, 
    {"target_clk_offset", _wrap_PathEnd_target_clk_offset}, 
    {"target_clk_mcp_adjustment", _wrap_PathEnd_target_clk_mcp_adjustment}, 
    {"target_clk_delay", _wrap_PathEnd_target_clk_delay}, 
    {"target_clk_insertion_delay", _wrap_PathEnd_target_clk_insertion_delay}, 
    {"target_clk_uncertainty", _wrap_PathEnd_target_clk_uncertainty}, 
    {"inter_clk_uncertainty", _wrap_PathEnd_inter_clk_uncertainty}, 
    {"target_clk_arrival", _wrap_PathEnd_target_clk_arrival}, 
    {"path_delay_margin_is_external", _wrap_PathEnd_path_delay_margin_is_external}, 
    {"check_crpr", _wrap_PathEnd_check_crpr}, 
    {"target_clk_end_trans", _wrap_PathEnd_target_clk_end_trans}, 
    {"clk_skew", _wrap_PathEnd_clk_skew}, 
    {0,0}
};
static swig_attribute swig_PathEnd_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PathEnd_bases[] = {0};
static const char * swig_PathEnd_base_names[] = {0};
static swig_class _wrap_class_PathEnd = { "PathEnd", &SWIGTYPE_p_PathEnd,0,0, swig_PathEnd_methods, swig_PathEnd_attributes, swig_PathEnd_bases,swig_PathEnd_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_MinPulseWidthCheck_methods[] = {
    {0,0}
};
static swig_attribute swig_MinPulseWidthCheck_attributes[] = {
    {0,0,0}
};
static swig_class *swig_MinPulseWidthCheck_bases[] = {0};
static const char * swig_MinPulseWidthCheck_base_names[] = {0};
static swig_class _wrap_class_MinPulseWidthCheck = { "MinPulseWidthCheck", &SWIGTYPE_p_MinPulseWidthCheck,0,0, swig_MinPulseWidthCheck_methods, swig_MinPulseWidthCheck_attributes, swig_MinPulseWidthCheck_bases,swig_MinPulseWidthCheck_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_MinPulseWidthCheckSeq_methods[] = {
    {0,0}
};
static swig_attribute swig_MinPulseWidthCheckSeq_attributes[] = {
    {0,0,0}
};
static swig_class *swig_MinPulseWidthCheckSeq_bases[] = {0};
static const char * swig_MinPulseWidthCheckSeq_base_names[] = {0};
static swig_class _wrap_class_MinPulseWidthCheckSeq = { "MinPulseWidthCheckSeq", &SWIGTYPE_p_MinPulseWidthCheckSeq,0,0, swig_MinPulseWidthCheckSeq_methods, swig_MinPulseWidthCheckSeq_attributes, swig_MinPulseWidthCheckSeq_bases,swig_MinPulseWidthCheckSeq_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_MinPulseWidthCheckSeqIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPulseWidthCheckSeqIterator *arg1 = (MinPulseWidthCheckSeqIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::MinPulseWidthCheckSeqIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeqIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MinPulseWidthCheckSeqIterator_has_next" "', argument " "1"" of type '" "MinPulseWidthCheckSeqIterator *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeqIterator * >(argp1);
  {
    try {
      result = (bool)MinPulseWidthCheckSeqIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_MinPulseWidthCheckSeqIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPulseWidthCheckSeqIterator *arg1 = (MinPulseWidthCheckSeqIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::MinPulseWidthCheckSeqIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeqIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MinPulseWidthCheckSeqIterator_next" "', argument " "1"" of type '" "MinPulseWidthCheckSeqIterator *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeqIterator * >(argp1);
  {
    try {
      result = (MinPulseWidthCheck *)MinPulseWidthCheckSeqIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheck, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_MinPulseWidthCheckSeqIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPulseWidthCheckSeqIterator *arg1 = (MinPulseWidthCheckSeqIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::MinPulseWidthCheckSeqIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeqIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MinPulseWidthCheckSeqIterator_finish" "', argument " "1"" of type '" "MinPulseWidthCheckSeqIterator *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeqIterator * >(argp1);
  {
    try {
      MinPulseWidthCheckSeqIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_MinPulseWidthCheckSeqIterator_methods[] = {
    {"has_next", _wrap_MinPulseWidthCheckSeqIterator_has_next}, 
    {"next", _wrap_MinPulseWidthCheckSeqIterator_next}, 
    {"finish", _wrap_MinPulseWidthCheckSeqIterator_finish}, 
    {0,0}
};
static swig_attribute swig_MinPulseWidthCheckSeqIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_MinPulseWidthCheckSeqIterator_bases[] = {0};
static const char * swig_MinPulseWidthCheckSeqIterator_base_names[] = {0};
static swig_class _wrap_class_MinPulseWidthCheckSeqIterator = { "MinPulseWidthCheckSeqIterator", &SWIGTYPE_p_MinPulseWidthCheckSeqIterator,0,0, swig_MinPulseWidthCheckSeqIterator_methods, swig_MinPulseWidthCheckSeqIterator_attributes, swig_MinPulseWidthCheckSeqIterator_bases,swig_MinPulseWidthCheckSeqIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Corner_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Corner_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Corner_name" "', argument " "1"" of type '" "Corner *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (char *)Corner_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Corner_methods[] = {
    {"name", _wrap_Corner_name}, 
    {0,0}
};
static swig_attribute swig_Corner_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Corner_bases[] = {0};
static const char * swig_Corner_base_names[] = {0};
static swig_class _wrap_class_Corner = { "Corner", &SWIGTYPE_p_Corner,0,0, swig_Corner_methods, swig_Corner_attributes, swig_Corner_bases,swig_Corner_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN const char *_wrap_group_path_count_max_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2, int flags) {
  Tcl_Obj *value = 0;
  
  value = SWIG_From_int(static_cast< int >(group_path_count_max));
  if (value) {
    Tcl_SetVar2(interp,name1,name2,Tcl_GetString(value), flags);
    Tcl_DecrRefCount(value);
  }
  return NULL;
}


SWIGINTERN const char *_wrap_group_path_count_max_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2 SWIGUNUSED, int flags) {
  Tcl_Obj *value = 0;
  Tcl_Obj *name1o = 0;
  
  name1o = Tcl_NewStringObj(name1,-1);
  value = Tcl_ObjGetVar2(interp, name1o, 0, flags);
  Tcl_DecrRefCount(name1o);
  if (!value) SWIG_fail;
  {
    int val;
    int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(value, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""group_path_count_max""' of type '""int""'");
    }
    group_path_count_max = static_cast< int >(val);
  }
  return NULL;
fail:
  return "group_path_count_max";
}


SWIGINTERN int
_wrap_init_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::init_sta ") == TCL_ERROR) SWIG_fail;
  {
    try {
      init_sta(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clear_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::clear_sta ") == TCL_ERROR) SWIG_fail;
  {
    try {
      clear_sta(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Tcl_Interp *arg1 = (Tcl_Interp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::make_sta interp ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Tcl_Interp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_sta" "', argument " "1"" of type '" "Tcl_Interp *""'"); 
  }
  arg1 = reinterpret_cast< Tcl_Interp * >(argp1);
  {
    try {
      make_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_tcl_interp(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Tcl_Interp *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::tcl_interp ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Tcl_Interp *)tcl_interp(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Tcl_Interp,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clear_network(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::clear_network ") == TCL_ERROR) SWIG_fail;
  {
    try {
      clear_network(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_all_memory(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::delete_all_memory ") == TCL_ERROR) SWIG_fail;
  {
    try {
      delete_all_memory(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_timing_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_timing_cmd full ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "find_timing_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      find_timing_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_arrivals_invalid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::arrivals_invalid ") == TCL_ERROR) SWIG_fail;
  {
    try {
      arrivals_invalid(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_startpoints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::startpoints ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = startpoints(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_endpoints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::endpoints ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = endpoints(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_endpoint_path_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  size_t result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::endpoint_path_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = endpoint_path_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_size_t(static_cast< size_t >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_requireds(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::find_requireds ") == TCL_ERROR) SWIG_fail;
  {
    try {
      find_requireds(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_total_negative_slack_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::total_negative_slack_cmd min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = total_negative_slack_cmd((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_total_negative_slack_corner_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::total_negative_slack_corner_cmd corner min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "total_negative_slack_corner_cmd" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = total_negative_slack_corner_cmd((Corner const *)arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_slack_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::worst_slack_cmd min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = worst_slack_cmd((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_slack_vertex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::worst_slack_vertex min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (Vertex *)worst_slack_vertex((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_slack_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::worst_slack_corner corner min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "worst_slack_corner" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = worst_slack_corner((Corner const *)arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_vertex_worst_arrival_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::vertex_worst_arrival_path vertex min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vertex_worst_arrival_path" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PathRef *)vertex_worst_arrival_path(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_vertex_worst_arrival_path_rf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::vertex_worst_arrival_path_rf vertex rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vertex_worst_arrival_path_rf" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *rf = RiseFall::find(arg);
    if (rf == nullptr) {
      tclArgError(interp, 2151, "Unknown rise/fall edge '%s'.", arg);
      return TCL_ERROR;
    }
    arg2 = rf;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PathRef *)vertex_worst_arrival_path_rf(arg1,(RiseFall const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_vertex_worst_slack_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::vertex_worst_slack_path vertex min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vertex_worst_slack_path" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PathRef *)vertex_worst_slack_path(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_tag_group_path_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::tag_group_path_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)tag_group_path_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_tag_groups(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_tag_groups ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_tag_groups(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_tag_arrivals_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_tag_arrivals_cmd vertex ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_tag_arrivals_cmd" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      report_tag_arrivals_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_arrival_count_histogram(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_arrival_count_histogram ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_arrival_count_histogram(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_tag_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::tag_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)tag_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_tags(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_tags ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_tags(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_clk_infos(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_clk_infos ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_clk_infos(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clk_info_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::clk_info_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)clk_info_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_arrival_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::arrival_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)arrival_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_required_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::required_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)required_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_endpoint_violation_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::endpoint_violation_count min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (int)endpoint_violation_count((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_loops(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_loops ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_loops(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_sim_logic_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_sim_logic_value pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_sim_logic_value" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char)pin_sim_logic_value((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_char(static_cast< char >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_slow_drivers(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  InstanceSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::slow_drivers count ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "slow_drivers" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      result = slow_drivers(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<InstanceSeq, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_path_ends(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  bool arg4 ;
  Corner *arg5 = (Corner *) 0 ;
  MinMaxAll *arg6 = (MinMaxAll *) 0 ;
  int arg7 ;
  int arg8 ;
  bool arg9 ;
  float arg10 ;
  float arg11 ;
  bool arg12 ;
  PathGroupNameSet *arg13 = (PathGroupNameSet *) 0 ;
  bool arg14 ;
  bool arg15 ;
  bool arg16 ;
  bool arg17 ;
  bool arg18 ;
  bool arg19 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  float val10 ;
  int ecode10 = 0 ;
  float val11 ;
  int ecode11 = 0 ;
  bool val12 ;
  int ecode12 = 0 ;
  bool val14 ;
  int ecode14 = 0 ;
  bool val15 ;
  int ecode15 = 0 ;
  bool val16 ;
  int ecode16 = 0 ;
  bool val17 ;
  int ecode17 = 0 ;
  bool val18 ;
  int ecode18 = 0 ;
  bool val19 ;
  int ecode19 = 0 ;
  PathEndSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooooooooooooooo:sta::find_path_ends from thrus to unconstrained corner delay_min_max group_path_count endpoint_path_count unique_pins slack_min slack_max sort_by_slack groups setup hold recovery removal clk_gating_setup clk_gating_hold ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_path_ends" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeqPtr<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "find_path_ends" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_path_ends" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "find_path_ends" "', argument " "5"" of type '" "Corner *""'"); 
  }
  arg5 = reinterpret_cast< Corner * >(argp5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg6 = min_max;
    else {
      tclArgError(interp, 2160, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode7 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_path_ends" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = static_cast< int >(val7);
  ecode8 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "find_path_ends" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = static_cast< int >(val8);
  ecode9 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "find_path_ends" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = static_cast< bool >(val9);
  ecode10 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "find_path_ends" "', argument " "10"" of type '" "float""'");
  } 
  arg10 = static_cast< float >(val10);
  ecode11 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[11], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "find_path_ends" "', argument " "11"" of type '" "float""'");
  } 
  arg11 = static_cast< float >(val11);
  ecode12 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[12], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "find_path_ends" "', argument " "12"" of type '" "bool""'");
  } 
  arg12 = static_cast< bool >(val12);
  {
    arg13 = tclListSetConstChar(objv[13], interp);
  }
  ecode14 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[14], &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "find_path_ends" "', argument " "14"" of type '" "bool""'");
  } 
  arg14 = static_cast< bool >(val14);
  ecode15 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[15], &val15);
  if (!SWIG_IsOK(ecode15)) {
    SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "find_path_ends" "', argument " "15"" of type '" "bool""'");
  } 
  arg15 = static_cast< bool >(val15);
  ecode16 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[16], &val16);
  if (!SWIG_IsOK(ecode16)) {
    SWIG_exception_fail(SWIG_ArgError(ecode16), "in method '" "find_path_ends" "', argument " "16"" of type '" "bool""'");
  } 
  arg16 = static_cast< bool >(val16);
  ecode17 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[17], &val17);
  if (!SWIG_IsOK(ecode17)) {
    SWIG_exception_fail(SWIG_ArgError(ecode17), "in method '" "find_path_ends" "', argument " "17"" of type '" "bool""'");
  } 
  arg17 = static_cast< bool >(val17);
  ecode18 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[18], &val18);
  if (!SWIG_IsOK(ecode18)) {
    SWIG_exception_fail(SWIG_ArgError(ecode18), "in method '" "find_path_ends" "', argument " "18"" of type '" "bool""'");
  } 
  arg18 = static_cast< bool >(val18);
  ecode19 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[19], &val19);
  if (!SWIG_IsOK(ecode19)) {
    SWIG_exception_fail(SWIG_ArgError(ecode19), "in method '" "find_path_ends" "', argument " "19"" of type '" "bool""'");
  } 
  arg19 = static_cast< bool >(val19);
  {
    try {
      result = find_path_ends(arg1,arg2,arg3,arg4,arg5,(MinMaxAll const *)arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PathEndSeq, PathEnd>(result, SWIGTYPE_p_PathEnd, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_path_end_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_path_end_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end_footer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_path_end_footer ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_path_end_footer(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_path_end end ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_path_end" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      report_path_end(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end2(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  PathEnd *arg2 = (PathEnd *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_path_end2 end prev_end last ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_path_end2" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_path_end2" "', argument " "2"" of type '" "PathEnd *""'"); 
  }
  arg2 = reinterpret_cast< PathEnd * >(argp2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_path_end2" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      report_path_end2(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_format(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ReportPathFormat arg1 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_format format ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    if (stringEq(arg, "full"))
    arg1 = ReportPathFormat::full;
    else if (stringEq(arg, "full_clock"))
    arg1 = ReportPathFormat::full_clock;
    else if (stringEq(arg, "full_clock_expanded"))
    arg1 = ReportPathFormat::full_clock_expanded;
    else if (stringEq(arg, "short"))
    arg1 = ReportPathFormat::shorter;
    else if (stringEq(arg, "end"))
    arg1 = ReportPathFormat::endpoint;
    else if (stringEq(arg, "summary"))
    arg1 = ReportPathFormat::summary;
    else if (stringEq(arg, "slack_only"))
    arg1 = ReportPathFormat::slack_only;
    else if (stringEq(arg, "json"))
    arg1 = ReportPathFormat::json;
    else {
      tclArgError(interp, 2170, "unknown path type %s.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_report_path_format(SWIG_STD_MOVE(arg1)); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_field_order(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  StringSeq *arg1 = (StringSeq *) 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_field_order field_names ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqConstChar(objv[1], interp);
  }
  {
    try {
      set_report_path_field_order(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_fields(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::set_report_path_fields report_input_pin report_hier_pins report_net report_cap report_slew report_fanout report_src_attr ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_fields" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_report_path_fields" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_report_path_fields" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_report_path_fields" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_report_path_fields" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_report_path_fields" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "set_report_path_fields" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      set_report_path_fields(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_field_properties(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  bool arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_report_path_field_properties field_name title width left_justify ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_report_path_field_properties" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_report_path_field_properties" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_report_path_field_properties" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_report_path_field_properties" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      set_report_path_field_properties((char const *)arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_field_width(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_report_path_field_width field_name width ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_report_path_field_width" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_report_path_field_width" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      set_report_path_field_width((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_digits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_digits digits ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_digits" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      set_report_path_digits(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_no_split(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_no_split no_split ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_no_split" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_report_path_no_split(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_sigmas(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_sigmas report_sigmas ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_sigmas" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_report_path_sigmas(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_path_ref(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_path_ref path ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_path_ref" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      delete_path_ref(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_path_cmd path ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_path_cmd" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      report_path_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_ends(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEndSeq *arg1 = (PathEndSeq *) 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_path_ends ends ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqPtr<PathEnd*>(objv[1], SWIGTYPE_p_PathEnd, interp);
  }
  {
    try {
      report_path_ends(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_clk_skew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ConstClockSeq arg1 ;
  Corner *arg2 = (Corner *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  bool arg4 ;
  int arg5 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::report_clk_skew clks corner setup_hold include_internal_latency digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeq<const Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_clk_skew" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, 2162, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "report_clk_skew" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "report_clk_skew" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      report_clk_skew(SWIG_STD_MOVE(arg1),(Corner const *)arg2,(SetupHold const *)arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_clk_latency(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  ConstClockSeq arg1 ;
  Corner *arg2 = (Corner *) 0 ;
  bool arg3 ;
  int arg4 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::report_clk_latency clks corner include_internal_latency digits ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeq<const Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_clk_latency" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_clk_latency" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "report_clk_latency" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  {
    try {
      report_clk_latency(SWIG_STD_MOVE(arg1),(Corner const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_clk_skew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  SetupHold *arg1 = (SetupHold *) 0 ;
  bool arg2 ;
  bool val2 ;
  int ecode2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::worst_clk_skew_cmd setup_hold include_internal_latency ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg1 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg1 = MinMax::max();
    else {
      tclArgError(interp, 2162, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "worst_clk_skew_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = (float)worst_clk_skew_cmd((SetupHold const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_violations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::min_pulse_width_violations corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "min_pulse_width_violations" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (MinPulseWidthCheckSeq *) &min_pulse_width_violations((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheckSeq, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_check_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  MinPulseWidthCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::min_pulse_width_check_pins pins corner ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqPtr<const Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "min_pulse_width_check_pins" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    try {
      result = (MinPulseWidthCheckSeq *) &min_pulse_width_check_pins(arg1,(Corner const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheckSeq, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::min_pulse_width_checks corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "min_pulse_width_checks" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (MinPulseWidthCheckSeq *) &min_pulse_width_checks((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheckSeq, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::min_pulse_width_check_slack corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "min_pulse_width_check_slack" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (MinPulseWidthCheck *)min_pulse_width_check_slack((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheck, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_mpw_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPulseWidthCheckSeq *arg1 = (MinPulseWidthCheckSeq *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_mpw_checks checks verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeq, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_mpw_checks" "', argument " "1"" of type '" "MinPulseWidthCheckSeq *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeq * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_mpw_checks" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_mpw_checks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_mpw_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPulseWidthCheck *arg1 = (MinPulseWidthCheck *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_mpw_check check verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheck, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_mpw_check" "', argument " "1"" of type '" "MinPulseWidthCheck *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheck * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_mpw_check" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_mpw_check(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_period_violations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPeriodCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::min_period_violations ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MinPeriodCheckSeq *) &min_period_violations(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MinPeriodCheckSeq,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_period_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPeriodCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::min_period_check_slack ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MinPeriodCheck *)min_period_check_slack(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MinPeriodCheck,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_min_period_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPeriodCheckSeq *arg1 = (MinPeriodCheckSeq *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_min_period_checks checks verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPeriodCheckSeq, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_min_period_checks" "', argument " "1"" of type '" "MinPeriodCheckSeq *""'"); 
  }
  arg1 = reinterpret_cast< MinPeriodCheckSeq * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_min_period_checks" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_min_period_checks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_min_period_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MinPeriodCheck *arg1 = (MinPeriodCheck *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_min_period_check check verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPeriodCheck, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_min_period_check" "', argument " "1"" of type '" "MinPeriodCheck *""'"); 
  }
  arg1 = reinterpret_cast< MinPeriodCheck * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_min_period_check" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_min_period_check(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_skew_violations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MaxSkewCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_skew_violations ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MaxSkewCheckSeq *) &max_skew_violations(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MaxSkewCheckSeq,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_skew_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MaxSkewCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_skew_check_slack ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MaxSkewCheck *)max_skew_check_slack(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MaxSkewCheck,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_max_skew_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MaxSkewCheckSeq *arg1 = (MaxSkewCheckSeq *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_max_skew_checks checks verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MaxSkewCheckSeq, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_max_skew_checks" "', argument " "1"" of type '" "MaxSkewCheckSeq *""'"); 
  }
  arg1 = reinterpret_cast< MaxSkewCheckSeq * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_max_skew_checks" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_max_skew_checks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_max_skew_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  MaxSkewCheck *arg1 = (MaxSkewCheck *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_max_skew_check check verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MaxSkewCheck, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_max_skew_check" "', argument " "1"" of type '" "MaxSkewCheck *""'"); 
  }
  arg1 = reinterpret_cast< MaxSkewCheck * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_max_skew_check" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_max_skew_check(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_clk_min_period(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::find_clk_min_period clk ignore_port_paths ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_clk_min_period" "', argument " "1"" of type '" "Clock const *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_clk_min_period" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = find_clk_min_period((Clock const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_slew_limits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::check_slew_limits net violators corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_slew_limits" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_slew_limits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "check_slew_limits" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = check_slew_limits(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_slew_violation_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  size_t result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_slew_violation_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = max_slew_violation_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_size_t(static_cast< size_t >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_slew_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_slew_check_slack ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)max_slew_check_slack(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_slew_check_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_slew_check_limit ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)max_slew_check_limit(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_slew_limit_short_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_slew_limit_short_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_slew_limit_short_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_slew_limit_short(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_slew_limit_short pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_slew_limit_short" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_slew_limit_short" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_slew_limit_short(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_slew_limit_verbose(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_slew_limit_verbose pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_slew_limit_verbose" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_slew_limit_verbose" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_slew_limit_verbose(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_fanout_limits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::check_fanout_limits net violators min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_fanout_limits" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_fanout_limits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = check_fanout_limits(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_fanout_violation_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  size_t result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_fanout_violation_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = max_fanout_violation_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_size_t(static_cast< size_t >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_fanout_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_fanout_check_slack ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)max_fanout_check_slack(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_fanout_check_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_fanout_check_limit ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)max_fanout_check_limit(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_fanout_limit_short_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_fanout_limit_short_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_fanout_limit_short_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_fanout_limit_short(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_fanout_limit_short pin min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_fanout_limit_short" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_fanout_limit_short(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_fanout_limit_verbose(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_fanout_limit_verbose pin min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_fanout_limit_verbose" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_fanout_limit_verbose(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_capacitance_limits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PinSeq result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::check_capacitance_limits net violators corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_capacitance_limits" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_capacitance_limits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "check_capacitance_limits" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = check_capacitance_limits(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    seqTclList<PinSeq, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_capacitance_violation_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  size_t result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_capacitance_violation_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = max_capacitance_violation_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_size_t(static_cast< size_t >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_capacitance_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_capacitance_check_slack ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)max_capacitance_check_slack(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_capacitance_check_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_capacitance_check_limit ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)max_capacitance_check_limit(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_capacitance_limit_short_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_capacitance_limit_short_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_capacitance_limit_short_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_capacitance_limit_short(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_capacitance_limit_short pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_capacitance_limit_short" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_capacitance_limit_short" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_capacitance_limit_short(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_capacitance_limit_verbose(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_capacitance_limit_verbose pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_capacitance_limit_verbose" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_capacitance_limit_verbose" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, 2159, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_capacitance_limit_verbose(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_timing_model_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  Corner *arg4 = (Corner *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::write_timing_model_cmd lib_name cell_name filename corner ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_timing_model_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write_timing_model_cmd" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "write_timing_model_cmd" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "write_timing_model_cmd" "', argument " "4"" of type '" "Corner const *""'"); 
  }
  arg4 = reinterpret_cast< Corner * >(argp4);
  {
    try {
      write_timing_model_cmd((char const *)arg1,(char const *)arg2,(char const *)arg3,(Corner const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_define_corners_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  StringSet *arg1 = (StringSet *) 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::define_corners_cmd corner_names ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetConstChar(objv[1], interp);
  }
  {
    try {
      define_corners_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cmd_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::cmd_corner ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Corner *)cmd_corner(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Corner, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_cmd_corner corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_corner" "', argument " "1"" of type '" "Corner *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      set_cmd_corner(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Corner *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_corner corner_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_corner" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Corner *)find_corner((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Corner, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_corners(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Corners *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::corners ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Corners *)corners(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    Corners *corners = result;
    for (Corner *corner : *corners) {
      Tcl_Obj *obj = SWIG_NewInstanceObj(corner, SWIGTYPE_p_Corner, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_multi_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::multi_corner ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)multi_corner(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_timing_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  CheckErrorSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::check_timing_cmd no_input_delay no_output_delay reg_multiple_clks reg_no_clks unconstrained_endpoints loops generated_clks ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "check_timing_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_timing_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "check_timing_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "check_timing_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "check_timing_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "check_timing_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "check_timing_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = (CheckErrorSeq *) &check_timing_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *error_list = Tcl_NewListObj(0, nullptr);
    CheckErrorSeq *check_errors = result;
    CheckErrorSeq::Iterator check_iter(check_errors);
    while (check_iter.hasNext()) {
      CheckError *error = check_iter.next();
      Tcl_Obj *string_list = Tcl_NewListObj(0, nullptr);
      CheckError::Iterator string_iter(error);
      while (string_iter.hasNext()) {
        const char *str = string_iter.next();
        size_t str_len = strlen(str);
        Tcl_Obj *obj = Tcl_NewStringObj(const_cast<char*>(str),
          static_cast<int>(str_len));
        Tcl_ListObjAppendElement(interp, string_list, obj);
      }
      Tcl_ListObjAppendElement(interp, error_list, string_list);
    }
    Tcl_SetObjResult(interp, error_list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanin_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanin_pins to flat startpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqPtr<const Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanin_pins" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanin_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanin_pins" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanin_pins" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanin_pins" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanin_pins" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = find_fanin_pins(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanin_insts(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  InstanceSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanin_insts to flat startpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqPtr<const Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanin_insts" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanin_insts" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanin_insts" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanin_insts" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanin_insts" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanin_insts" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = find_fanin_insts(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<InstanceSet, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanout_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  PinSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanout_pins from flat endpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqPtr<const Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanout_pins" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanout_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanout_pins" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanout_pins" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanout_pins" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanout_pins" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = find_fanout_pins(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<PinSet, Pin>(result, SWIGTYPE_p_Pin, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanout_insts(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  InstanceSet result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanout_insts from flat endpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqPtr<const Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanout_insts" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanout_insts" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanout_insts" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanout_insts" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanout_insts" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanout_insts" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = find_fanout_insts(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    setTclList<InstanceSet, Instance>(result, SWIGTYPE_p_Instance, interp);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_crpr_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::crpr_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)crpr_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_crpr_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_crpr_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_crpr_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_crpr_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_crpr_mode(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::crpr_mode ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)crpr_mode(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_crpr_mode(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_crpr_mode mode ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_crpr_mode" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_crpr_mode((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pocv_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::pocv_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)pocv_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pocv_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_pocv_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_pocv_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_pocv_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pocv_sigma_factor(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::pocv_sigma_factor ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)pocv_sigma_factor(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pocv_sigma_factor(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float arg1 ;
  float val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_pocv_sigma_factor factor ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_pocv_sigma_factor" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  {
    try {
      set_pocv_sigma_factor(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_propagate_gated_clock_enable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::propagate_gated_clock_enable ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)propagate_gated_clock_enable(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagate_gated_clock_enable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagate_gated_clock_enable enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_propagate_gated_clock_enable" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_propagate_gated_clock_enable(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_preset_clr_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::preset_clr_arcs_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)preset_clr_arcs_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_preset_clr_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_preset_clr_arcs_enabled enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_preset_clr_arcs_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_preset_clr_arcs_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cond_default_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::cond_default_arcs_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)cond_default_arcs_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cond_default_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_cond_default_arcs_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_cond_default_arcs_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_cond_default_arcs_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_bidirect_inst_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::bidirect_inst_paths_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)bidirect_inst_paths_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_bidirect_inst_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_bidirect_inst_paths_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_bidirect_inst_paths_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_bidirect_inst_paths_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_bidirect_net_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::bidirect_net_paths_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)bidirect_net_paths_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_bidirect_net_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_bidirect_net_paths_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_bidirect_net_paths_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_bidirect_net_paths_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_recovery_removal_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::recovery_removal_checks_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)recovery_removal_checks_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_recovery_removal_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_recovery_removal_checks_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_recovery_removal_checks_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_recovery_removal_checks_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_gated_clk_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::gated_clk_checks_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)gated_clk_checks_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_gated_clk_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_gated_clk_checks_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_gated_clk_checks_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_gated_clk_checks_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dynamic_loop_breaking(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::dynamic_loop_breaking ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)dynamic_loop_breaking(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_dynamic_loop_breaking(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_dynamic_loop_breaking enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_dynamic_loop_breaking" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_dynamic_loop_breaking(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_use_default_arrival_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::use_default_arrival_clock ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)use_default_arrival_clock(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_use_default_arrival_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_use_default_arrival_clock enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_use_default_arrival_clock" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_use_default_arrival_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::pin_property pin property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_property" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pin_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = pin_property((Pin const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_instance_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::instance_property inst property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "instance_property" "', argument " "1"" of type '" "Instance const *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "instance_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = instance_property((Instance const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Net *arg1 = (Net *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::net_property net property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_property" "', argument " "1"" of type '" "Net const *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "net_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = net_property((Net const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Port *arg1 = (Port *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::port_property port property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_property" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "port_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = port_property((Port const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_cell_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::liberty_cell_property cell property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_cell_property" "', argument " "1"" of type '" "LibertyCell const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "liberty_cell_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = liberty_cell_property((LibertyCell const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cell_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::cell_property cell property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cell_property" "', argument " "1"" of type '" "Cell const *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cell_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = cell_property((Cell const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_port_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::liberty_port_property port property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_port_property" "', argument " "1"" of type '" "LibertyPort const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "liberty_port_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = liberty_port_property((LibertyPort const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_library_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Library *arg1 = (Library *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::library_property lib property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "library_property" "', argument " "1"" of type '" "Library const *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "library_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = library_property((Library const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_library_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::liberty_library_property lib property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_library_property" "', argument " "1"" of type '" "LibertyLibrary const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "liberty_library_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = liberty_library_property((LibertyLibrary const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_edge_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::edge_property edge property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "edge_property" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "edge_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = edge_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clock_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::clock_property clk property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clock_property" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "clock_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = clock_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_path_end_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::path_end_property end property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "path_end_property" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "path_end_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = path_end_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_path_ref_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::path_ref_property path property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "path_ref_property" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "path_ref_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = path_ref_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_timing_arc_set_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::timing_arc_set_property arc_set property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "timing_arc_set_property" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "timing_arc_set_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = timing_arc_set_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        const Unit *unit = value.unit();
        const char *float_string = unit->asString(value.floatValue(), 6);
        Tcl_SetResult(interp, const_cast<char*>(float_string), TCL_VOLATILE);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Library*>(value.library()),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Cell*>(value.cell()),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Port*>(value.port()),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyLibrary*>(value.libertyLibrary()),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyCell*>(value.libertyCell()),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<LibertyPort*>(value.libertyPort()),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Instance*>(value.instance()),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(value.pin()),
          SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          const Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Pin*>(pin), SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Net*>(value.net()),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(const_cast<Clock*>(value.clock()),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        for (PathRef &path : *value.pathRefs()) {
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.density());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN const char *_wrap_float_inf_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2, int flags) {
  Tcl_Obj *value = 0;
  
  value = SWIG_From_float(static_cast< float >(float_inf));
  if (value) {
    Tcl_SetVar2(interp,name1,name2,Tcl_GetString(value), flags);
    Tcl_DecrRefCount(value);
  }
  return NULL;
}


SWIGINTERN const char *_wrap_float_inf_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2 SWIGUNUSED, int flags) {
  Tcl_Obj *value = 0;
  Tcl_Obj *name1o = 0;
  
  name1o = Tcl_NewStringObj(name1,-1);
  value = Tcl_ObjGetVar2(interp, name1o, 0, flags);
  Tcl_DecrRefCount(name1o);
  if (!value) SWIG_fail;
  {
    float val;
    int res = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(value, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""float_inf""' of type '""float""'");
    }
    float_inf = static_cast< float >(val);
  }
  return NULL;
fail:
  return "float_inf";
}


SWIGINTERN int
_wrap_version(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::version ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)version(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_git_sha1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::git_sha1 ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)git_sha1(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_elapsed_run_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::elapsed_run_time ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (double)elapsed_run_time(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_user_run_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::user_run_time ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (double)user_run_time(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cputime(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  unsigned long result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::cputime ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (unsigned long)cputime(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_memory_usage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  unsigned long result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::memory_usage ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (unsigned long)memory_usage(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_processor_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::processor_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)processor_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_thread_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::thread_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)thread_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_thread_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_thread_count count ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_thread_count" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      set_thread_count(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_error(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_error id msg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_error" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_error" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      report_error(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_file_error(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::report_file_error id filename line msg ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_file_error" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_file_error" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_file_error" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "report_file_error" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  {
    try {
      report_file_error(arg1,(char const *)arg2,arg3,(char const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_warn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_warn id msg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_warn" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_warn" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      report_warn(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_file_warn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::report_file_warn id filename line msg ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_file_warn" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_file_warn" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_file_warn" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "report_file_warn" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  {
    try {
      report_file_warn(arg1,(char const *)arg2,arg3,(char const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_line(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_line msg ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_line" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      report_line((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_suppress_msg_id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::suppress_msg_id id ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "suppress_msg_id" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      suppress_msg_id(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unsuppress_msg_id(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unsuppress_msg_id id ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "unsuppress_msg_id" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      unsuppress_msg_id(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_suppressed(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_suppressed id ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "is_suppressed" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      result = (int)is_suppressed(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_fflush(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::fflush ") == TCL_ERROR) SWIG_fail;
  {
    try {
      fflush(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_file_begin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::redirect_file_begin filename ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "redirect_file_begin" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      redirect_file_begin((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_file_append_begin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::redirect_file_append_begin filename ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "redirect_file_append_begin" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      redirect_file_append_begin((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_file_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::redirect_file_end ") == TCL_ERROR) SWIG_fail;
  {
    try {
      redirect_file_end(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_string_begin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::redirect_string_begin ") == TCL_ERROR) SWIG_fail;
  {
    try {
      redirect_string_begin(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_string_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::redirect_string_end ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)redirect_string_end(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_log_begin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::log_begin_cmd filename ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "log_begin_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      log_begin_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_log_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::log_end ") == TCL_ERROR) SWIG_fail;
  {
    try {
      log_end(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_debug(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_debug what level ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_debug" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_debug" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      set_debug((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_object(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_object obj ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_object" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)is_object((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_object_type(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::object_type obj ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "object_type" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (char *)object_type((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_object_list(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::is_object_list list type ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_object_list" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "is_object_list" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (bool)is_object_list((char const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_time_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::time_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "time_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)time_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_time_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::time_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "time_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)time_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_capacitance_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::capacitance_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "capacitance_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)capacitance_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_capacitance_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::capacitance_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "capacitance_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)capacitance_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_resistance_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::resistance_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "resistance_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)resistance_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_resistance_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::resistance_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "resistance_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)resistance_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_voltage_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::voltage_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "voltage_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)voltage_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_voltage_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::voltage_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "voltage_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)voltage_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_current_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::current_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "current_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)current_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_current_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::current_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "current_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)current_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_power_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::power_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "power_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)power_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_power_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::power_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "power_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)power_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_distance_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::distance_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "distance_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)distance_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_distance_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::distance_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "distance_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)distance_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_area_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::area_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "area_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)area_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_area_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::area_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "area_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)area_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_unit_scale(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  float arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_cmd_unit_scale unit_name scale ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_unit_scale" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_cmd_unit_scale" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_cmd_unit_scale((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_unit_digits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_cmd_unit_digits unit_name digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_unit_digits" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_cmd_unit_digits" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      set_cmd_unit_digits((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_unit_suffix(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_cmd_unit_suffix unit_name suffix ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_unit_suffix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_cmd_unit_suffix" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      set_cmd_unit_suffix((char const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unit_scale_abbreviation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unit_scale_abbreviation unit_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unit_scale_abbreviation" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (char *)unit_scale_abbreviation((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unit_suffix(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unit_suffix unit_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unit_suffix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (char *)unit_suffix((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unit_scaled_suffix(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unit_scaled_suffix unit_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unit_scaled_suffix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (char *)unit_scaled_suffix((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unit_scale(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unit_scale unit_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unit_scale" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (float)unit_scale((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_time value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_time" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_time" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_time((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_capacitance value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_capacitance" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_capacitance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_capacitance((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_resistance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_resistance value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_resistance" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_resistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_resistance((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_voltage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_voltage value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_voltage" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_voltage" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_voltage((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_current(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_current value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_current" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_current" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_current((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_power value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_power" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_power" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_power((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_distance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_distance value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_distance" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_distance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_distance((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_area(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_area value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_area" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_area" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_area((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_rise_short_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::rise_short_name ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)rise_short_name(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_fall_short_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::fall_short_name ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)fall_short_name(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_fuzzy_equal(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::fuzzy_equal value1 value2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fuzzy_equal" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fuzzy_equal" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      result = (bool)fuzzy_equal(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_path_spice_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  char *arg6 = (char *) 0 ;
  char *arg7 = (char *) 0 ;
  CircuitSim arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooo:sta::write_path_spice_cmd path spice_filename subckt_filename lib_subckt_filename model_filename power_name gnd_name ckt_sim ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_path_spice_cmd" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write_path_spice_cmd" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "write_path_spice_cmd" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "write_path_spice_cmd" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  res5 = SWIG_AsCharPtrAndSize(objv[5], &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "write_path_spice_cmd" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = reinterpret_cast< char * >(buf5);
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "write_path_spice_cmd" "', argument " "6"" of type '" "char const *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "write_path_spice_cmd" "', argument " "7"" of type '" "char const *""'");
  }
  arg7 = reinterpret_cast< char * >(buf7);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[8], &length);
    if (stringEq(arg, "hspice"))
    arg8 = CircuitSim::hspice;
    else if (stringEq(arg, "ngspice"))
    arg8 = CircuitSim::ngspice;
    else if (stringEq(arg, "xyce"))
    arg8 = CircuitSim::xyce;
    else {
      tclArgError(interp, 2171, "unknown circuit simulator %s.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      write_path_spice_cmd(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,SWIG_STD_MOVE(arg8)); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_verilog_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::read_verilog_cmd filename ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_verilog_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)read_verilog_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_verilog_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  CellSeq *arg4 = (CellSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::write_verilog_cmd filename sort include_pwr_gnd remove_cells ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_verilog_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "write_verilog_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "write_verilog_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    arg4 = tclListSeqPtr<Cell*>(objv[4], SWIGTYPE_p_Cell, interp);
  }
  {
    try {
      write_verilog_cmd((char const *)arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.\n");
      exit(1);
    }
    catch (ExceptionMsg &excp) {
      if (!excp.suppressed()) {
        Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      }
      return TCL_ERROR;
    }
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, "Error: ", excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}



static swig_command_info swig_commands[] = {
    { SWIG_prefix "delay_calc_names", (swig_wrapper_func) _wrap_delay_calc_names, NULL},
    { SWIG_prefix "is_delay_calc_name", (swig_wrapper_func) _wrap_is_delay_calc_name, NULL},
    { SWIG_prefix "set_delay_calculator_cmd", (swig_wrapper_func) _wrap_set_delay_calculator_cmd, NULL},
    { SWIG_prefix "set_delay_calc_incremental_tolerance", (swig_wrapper_func) _wrap_set_delay_calc_incremental_tolerance, NULL},
    { SWIG_prefix "report_delay_calc_cmd", (swig_wrapper_func) _wrap_report_delay_calc_cmd, NULL},
    { SWIG_prefix "set_prima_reduce_order", (swig_wrapper_func) _wrap_set_prima_reduce_order, NULL},
    { SWIG_prefix "find_delays", (swig_wrapper_func) _wrap_find_delays, NULL},
    { SWIG_prefix "delays_invalid", (swig_wrapper_func) _wrap_delays_invalid, NULL},
    { SWIG_prefix "Vertex_pin", (swig_wrapper_func) _wrap_Vertex_pin, NULL},
    { SWIG_prefix "Vertex_is_bidirect_driver", (swig_wrapper_func) _wrap_Vertex_is_bidirect_driver, NULL},
    { SWIG_prefix "Vertex_level", (swig_wrapper_func) _wrap_Vertex_level, NULL},
    { SWIG_prefix "Vertex_tag_group_index", (swig_wrapper_func) _wrap_Vertex_tag_group_index, NULL},
    { SWIG_prefix "Vertex_slew", (swig_wrapper_func) _wrap_Vertex_slew, NULL},
    { SWIG_prefix "Vertex_slew_corner", (swig_wrapper_func) _wrap_Vertex_slew_corner, NULL},
    { SWIG_prefix "Vertex_out_edge_iterator", (swig_wrapper_func) _wrap_Vertex_out_edge_iterator, NULL},
    { SWIG_prefix "Vertex_in_edge_iterator", (swig_wrapper_func) _wrap_Vertex_in_edge_iterator, NULL},
    { SWIG_prefix "Vertex_arrivals_clk", (swig_wrapper_func) _wrap_Vertex_arrivals_clk, NULL},
    { SWIG_prefix "Vertex_arrivals_clk_delays", (swig_wrapper_func) _wrap_Vertex_arrivals_clk_delays, NULL},
    { SWIG_prefix "Vertex_requireds_clk", (swig_wrapper_func) _wrap_Vertex_requireds_clk, NULL},
    { SWIG_prefix "Vertex_requireds_clk_delays", (swig_wrapper_func) _wrap_Vertex_requireds_clk_delays, NULL},
    { SWIG_prefix "Vertex_slack", (swig_wrapper_func) _wrap_Vertex_slack, NULL},
    { SWIG_prefix "Vertex_slacks", (swig_wrapper_func) _wrap_Vertex_slacks, NULL},
    { SWIG_prefix "Vertex_slacks_clk", (swig_wrapper_func) _wrap_Vertex_slacks_clk, NULL},
    { SWIG_prefix "Vertex_slacks_clk_delays", (swig_wrapper_func) _wrap_Vertex_slacks_clk_delays, NULL},
    { SWIG_prefix "Vertex_path_iterator", (swig_wrapper_func) _wrap_Vertex_path_iterator, NULL},
    { SWIG_prefix "Vertex_has_downstream_clk_pin", (swig_wrapper_func) _wrap_Vertex_has_downstream_clk_pin, NULL},
    { SWIG_prefix "Vertex_is_clock", (swig_wrapper_func) _wrap_Vertex_is_clock, NULL},
    { SWIG_prefix "Vertex_is_disabled_constraint", (swig_wrapper_func) _wrap_Vertex_is_disabled_constraint, NULL},
    { SWIG_prefix "Vertex", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Vertex},
    { SWIG_prefix "Edge_from", (swig_wrapper_func) _wrap_Edge_from, NULL},
    { SWIG_prefix "Edge_to", (swig_wrapper_func) _wrap_Edge_to, NULL},
    { SWIG_prefix "Edge_from_pin", (swig_wrapper_func) _wrap_Edge_from_pin, NULL},
    { SWIG_prefix "Edge_to_pin", (swig_wrapper_func) _wrap_Edge_to_pin, NULL},
    { SWIG_prefix "Edge_role", (swig_wrapper_func) _wrap_Edge_role, NULL},
    { SWIG_prefix "Edge_sense", (swig_wrapper_func) _wrap_Edge_sense, NULL},
    { SWIG_prefix "Edge_timing_arcs", (swig_wrapper_func) _wrap_Edge_timing_arcs, NULL},
    { SWIG_prefix "Edge_is_disabled_loop", (swig_wrapper_func) _wrap_Edge_is_disabled_loop, NULL},
    { SWIG_prefix "Edge_is_disabled_constraint", (swig_wrapper_func) _wrap_Edge_is_disabled_constraint, NULL},
    { SWIG_prefix "Edge_is_disabled_constant", (swig_wrapper_func) _wrap_Edge_is_disabled_constant, NULL},
    { SWIG_prefix "Edge_is_disabled_cond_default", (swig_wrapper_func) _wrap_Edge_is_disabled_cond_default, NULL},
    { SWIG_prefix "Edge_disabled_constant_pins", (swig_wrapper_func) _wrap_Edge_disabled_constant_pins, NULL},
    { SWIG_prefix "Edge_is_disabled_bidirect_inst_path", (swig_wrapper_func) _wrap_Edge_is_disabled_bidirect_inst_path, NULL},
    { SWIG_prefix "Edge_is_disabled_bidirect_net_path", (swig_wrapper_func) _wrap_Edge_is_disabled_bidirect_net_path, NULL},
    { SWIG_prefix "Edge_is_disabled_preset_clear", (swig_wrapper_func) _wrap_Edge_is_disabled_preset_clear, NULL},
    { SWIG_prefix "Edge_sim_timing_sense", (swig_wrapper_func) _wrap_Edge_sim_timing_sense, NULL},
    { SWIG_prefix "Edge_arc_delays", (swig_wrapper_func) _wrap_Edge_arc_delays, NULL},
    { SWIG_prefix "Edge_arc_delay_strings", (swig_wrapper_func) _wrap_Edge_arc_delay_strings, NULL},
    { SWIG_prefix "Edge_delay_annotated", (swig_wrapper_func) _wrap_Edge_delay_annotated, NULL},
    { SWIG_prefix "Edge_arc_delay", (swig_wrapper_func) _wrap_Edge_arc_delay, NULL},
    { SWIG_prefix "Edge_cond", (swig_wrapper_func) _wrap_Edge_cond, NULL},
    { SWIG_prefix "Edge_mode_name", (swig_wrapper_func) _wrap_Edge_mode_name, NULL},
    { SWIG_prefix "Edge_mode_value", (swig_wrapper_func) _wrap_Edge_mode_value, NULL},
    { SWIG_prefix "Edge_latch_d_to_q_en", (swig_wrapper_func) _wrap_Edge_latch_d_to_q_en, NULL},
    { SWIG_prefix "Edge", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Edge},
    { SWIG_prefix "VertexIterator_has_next", (swig_wrapper_func) _wrap_VertexIterator_has_next, NULL},
    { SWIG_prefix "VertexIterator_next", (swig_wrapper_func) _wrap_VertexIterator_next, NULL},
    { SWIG_prefix "VertexIterator_finish", (swig_wrapper_func) _wrap_VertexIterator_finish, NULL},
    { SWIG_prefix "VertexIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexIterator},
    { SWIG_prefix "VertexInEdgeIterator_has_next", (swig_wrapper_func) _wrap_VertexInEdgeIterator_has_next, NULL},
    { SWIG_prefix "VertexInEdgeIterator_next", (swig_wrapper_func) _wrap_VertexInEdgeIterator_next, NULL},
    { SWIG_prefix "VertexInEdgeIterator_finish", (swig_wrapper_func) _wrap_VertexInEdgeIterator_finish, NULL},
    { SWIG_prefix "VertexInEdgeIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexInEdgeIterator},
    { SWIG_prefix "VertexOutEdgeIterator_has_next", (swig_wrapper_func) _wrap_VertexOutEdgeIterator_has_next, NULL},
    { SWIG_prefix "VertexOutEdgeIterator_next", (swig_wrapper_func) _wrap_VertexOutEdgeIterator_next, NULL},
    { SWIG_prefix "VertexOutEdgeIterator_finish", (swig_wrapper_func) _wrap_VertexOutEdgeIterator_finish, NULL},
    { SWIG_prefix "VertexOutEdgeIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexOutEdgeIterator},
    { SWIG_prefix "vertex_iterator", (swig_wrapper_func) _wrap_vertex_iterator, NULL},
    { SWIG_prefix "set_arc_delay", (swig_wrapper_func) _wrap_set_arc_delay, NULL},
    { SWIG_prefix "set_annotated_slew", (swig_wrapper_func) _wrap_set_annotated_slew, NULL},
    { SWIG_prefix "remove_delay_slew_annotations", (swig_wrapper_func) _wrap_remove_delay_slew_annotations, NULL},
    { SWIG_prefix "LibertyLibrary_name", (swig_wrapper_func) _wrap_LibertyLibrary_name, NULL},
    { SWIG_prefix "LibertyLibrary_find_liberty_cell", (swig_wrapper_func) _wrap_LibertyLibrary_find_liberty_cell, NULL},
    { SWIG_prefix "LibertyLibrary_find_liberty_cells_matching", (swig_wrapper_func) _wrap_LibertyLibrary_find_liberty_cells_matching, NULL},
    { SWIG_prefix "LibertyLibrary_find_wireload", (swig_wrapper_func) _wrap_LibertyLibrary_find_wireload, NULL},
    { SWIG_prefix "LibertyLibrary_find_wireload_selection", (swig_wrapper_func) _wrap_LibertyLibrary_find_wireload_selection, NULL},
    { SWIG_prefix "LibertyLibrary_find_operating_conditions", (swig_wrapper_func) _wrap_LibertyLibrary_find_operating_conditions, NULL},
    { SWIG_prefix "LibertyLibrary_default_operating_conditions", (swig_wrapper_func) _wrap_LibertyLibrary_default_operating_conditions, NULL},
    { SWIG_prefix "LibertyLibrary", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyLibrary},
    { SWIG_prefix "LibertyLibraryIterator_has_next", (swig_wrapper_func) _wrap_LibertyLibraryIterator_has_next, NULL},
    { SWIG_prefix "LibertyLibraryIterator_next", (swig_wrapper_func) _wrap_LibertyLibraryIterator_next, NULL},
    { SWIG_prefix "LibertyLibraryIterator_finish", (swig_wrapper_func) _wrap_LibertyLibraryIterator_finish, NULL},
    { SWIG_prefix "LibertyLibraryIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyLibraryIterator},
    { SWIG_prefix "LibertyCell_name", (swig_wrapper_func) _wrap_LibertyCell_name, NULL},
    { SWIG_prefix "LibertyCell_is_leaf", (swig_wrapper_func) _wrap_LibertyCell_is_leaf, NULL},
    { SWIG_prefix "LibertyCell_is_buffer", (swig_wrapper_func) _wrap_LibertyCell_is_buffer, NULL},
    { SWIG_prefix "LibertyCell_is_inverter", (swig_wrapper_func) _wrap_LibertyCell_is_inverter, NULL},
    { SWIG_prefix "LibertyCell_liberty_library", (swig_wrapper_func) _wrap_LibertyCell_liberty_library, NULL},
    { SWIG_prefix "LibertyCell_cell", (swig_wrapper_func) _wrap_LibertyCell_cell, NULL},
    { SWIG_prefix "LibertyCell_find_liberty_port", (swig_wrapper_func) _wrap_LibertyCell_find_liberty_port, NULL},
    { SWIG_prefix "LibertyCell_find_liberty_ports_matching", (swig_wrapper_func) _wrap_LibertyCell_find_liberty_ports_matching, NULL},
    { SWIG_prefix "LibertyCell_liberty_port_iterator", (swig_wrapper_func) _wrap_LibertyCell_liberty_port_iterator, NULL},
    { SWIG_prefix "LibertyCell_timing_arc_sets", (swig_wrapper_func) _wrap_LibertyCell_timing_arc_sets, NULL},
    { SWIG_prefix "LibertyCell_ensure_voltage_waveforms", (swig_wrapper_func) _wrap_LibertyCell_ensure_voltage_waveforms, NULL},
    { SWIG_prefix "LibertyCell_test_cell", (swig_wrapper_func) _wrap_LibertyCell_test_cell, NULL},
    { SWIG_prefix "LibertyCell", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyCell},
    { SWIG_prefix "LibertyPort_bus_name", (swig_wrapper_func) _wrap_LibertyPort_bus_name, NULL},
    { SWIG_prefix "LibertyPort_cell", (swig_wrapper_func) _wrap_LibertyPort_cell, NULL},
    { SWIG_prefix "LibertyPort_is_bus", (swig_wrapper_func) _wrap_LibertyPort_is_bus, NULL},
    { SWIG_prefix "LibertyPort_member_iterator", (swig_wrapper_func) _wrap_LibertyPort_member_iterator, NULL},
    { SWIG_prefix "LibertyPort_function", (swig_wrapper_func) _wrap_LibertyPort_function, NULL},
    { SWIG_prefix "LibertyPort_tristate_enable", (swig_wrapper_func) _wrap_LibertyPort_tristate_enable, NULL},
    { SWIG_prefix "LibertyPort_capacitance", (swig_wrapper_func) _wrap_LibertyPort_capacitance, NULL},
    { SWIG_prefix "LibertyPort_set_direction", (swig_wrapper_func) _wrap_LibertyPort_set_direction, NULL},
    { SWIG_prefix "LibertyPort_scan_signal_type", (swig_wrapper_func) _wrap_LibertyPort_scan_signal_type, NULL},
    { SWIG_prefix "LibertyPort", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyPort},
    { SWIG_prefix "LibertyCellPortIterator_has_next", (swig_wrapper_func) _wrap_LibertyCellPortIterator_has_next, NULL},
    { SWIG_prefix "LibertyCellPortIterator_next", (swig_wrapper_func) _wrap_LibertyCellPortIterator_next, NULL},
    { SWIG_prefix "LibertyCellPortIterator_finish", (swig_wrapper_func) _wrap_LibertyCellPortIterator_finish, NULL},
    { SWIG_prefix "LibertyCellPortIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyCellPortIterator},
    { SWIG_prefix "LibertyPortMemberIterator_has_next", (swig_wrapper_func) _wrap_LibertyPortMemberIterator_has_next, NULL},
    { SWIG_prefix "LibertyPortMemberIterator_next", (swig_wrapper_func) _wrap_LibertyPortMemberIterator_next, NULL},
    { SWIG_prefix "LibertyPortMemberIterator_finish", (swig_wrapper_func) _wrap_LibertyPortMemberIterator_finish, NULL},
    { SWIG_prefix "LibertyPortMemberIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyPortMemberIterator},
    { SWIG_prefix "TimingArcSet_from", (swig_wrapper_func) _wrap_TimingArcSet_from, NULL},
    { SWIG_prefix "TimingArcSet_to", (swig_wrapper_func) _wrap_TimingArcSet_to, NULL},
    { SWIG_prefix "TimingArcSet_role", (swig_wrapper_func) _wrap_TimingArcSet_role, NULL},
    { SWIG_prefix "TimingArcSet_sdf_cond", (swig_wrapper_func) _wrap_TimingArcSet_sdf_cond, NULL},
    { SWIG_prefix "TimingArcSet_full_name", (swig_wrapper_func) _wrap_TimingArcSet_full_name, NULL},
    { SWIG_prefix "TimingArcSet_timing_arcs", (swig_wrapper_func) _wrap_TimingArcSet_timing_arcs, NULL},
    { SWIG_prefix "TimingArcSet", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_TimingArcSet},
    { SWIG_prefix "TimingArc_from", (swig_wrapper_func) _wrap_TimingArc_from, NULL},
    { SWIG_prefix "TimingArc_to", (swig_wrapper_func) _wrap_TimingArc_to, NULL},
    { SWIG_prefix "TimingArc_from_edge", (swig_wrapper_func) _wrap_TimingArc_from_edge, NULL},
    { SWIG_prefix "TimingArc_from_edge_name", (swig_wrapper_func) _wrap_TimingArc_from_edge_name, NULL},
    { SWIG_prefix "TimingArc_to_edge", (swig_wrapper_func) _wrap_TimingArc_to_edge, NULL},
    { SWIG_prefix "TimingArc_to_edge_name", (swig_wrapper_func) _wrap_TimingArc_to_edge_name, NULL},
    { SWIG_prefix "TimingArc_role", (swig_wrapper_func) _wrap_TimingArc_role, NULL},
    { SWIG_prefix "TimingArc_time_voltage", (swig_wrapper_func) _wrap_TimingArc_time_voltage, NULL},
    { SWIG_prefix "TimingArc_time_current", (swig_wrapper_func) _wrap_TimingArc_time_current, NULL},
    { SWIG_prefix "TimingArc_voltage_current", (swig_wrapper_func) _wrap_TimingArc_voltage_current, NULL},
    { SWIG_prefix "TimingArc_voltage_time", (swig_wrapper_func) _wrap_TimingArc_voltage_time, NULL},
    { SWIG_prefix "TimingArc_voltage_waveform", (swig_wrapper_func) _wrap_TimingArc_voltage_waveform, NULL},
    { SWIG_prefix "TimingArc_voltage_waveform_raw", (swig_wrapper_func) _wrap_TimingArc_voltage_waveform_raw, NULL},
    { SWIG_prefix "TimingArc_current_waveform", (swig_wrapper_func) _wrap_TimingArc_current_waveform, NULL},
    { SWIG_prefix "TimingArc_current_waveform_raw", (swig_wrapper_func) _wrap_TimingArc_current_waveform_raw, NULL},
    { SWIG_prefix "TimingArc_voltage_current_waveform", (swig_wrapper_func) _wrap_TimingArc_voltage_current_waveform, NULL},
    { SWIG_prefix "TimingArc_final_resistance", (swig_wrapper_func) _wrap_TimingArc_final_resistance, NULL},
    { SWIG_prefix "TimingArc", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_TimingArc},
    { SWIG_prefix "Wireload", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Wireload},
    { SWIG_prefix "WireloadSelection", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_WireloadSelection},
    { SWIG_prefix "read_liberty_cmd", (swig_wrapper_func) _wrap_read_liberty_cmd, NULL},
    { SWIG_prefix "write_liberty_cmd", (swig_wrapper_func) _wrap_write_liberty_cmd, NULL},
    { SWIG_prefix "make_equiv_cells", (swig_wrapper_func) _wrap_make_equiv_cells, NULL},
    { SWIG_prefix "find_equiv_cells", (swig_wrapper_func) _wrap_find_equiv_cells, NULL},
    { SWIG_prefix "equiv_cells", (swig_wrapper_func) _wrap_equiv_cells, NULL},
    { SWIG_prefix "equiv_cell_ports", (swig_wrapper_func) _wrap_equiv_cell_ports, NULL},
    { SWIG_prefix "equiv_cell_timing_arcs", (swig_wrapper_func) _wrap_equiv_cell_timing_arcs, NULL},
    { SWIG_prefix "find_library_buffers", (swig_wrapper_func) _wrap_find_library_buffers, NULL},
    { SWIG_prefix "liberty_port_direction", (swig_wrapper_func) _wrap_liberty_port_direction, NULL},
    { SWIG_prefix "liberty_supply_exists", (swig_wrapper_func) _wrap_liberty_supply_exists, NULL},
    { SWIG_prefix "liberty_library_iterator", (swig_wrapper_func) _wrap_liberty_library_iterator, NULL},
    { SWIG_prefix "find_liberty", (swig_wrapper_func) _wrap_find_liberty, NULL},
    { SWIG_prefix "find_liberty_cell", (swig_wrapper_func) _wrap_find_liberty_cell, NULL},
    { SWIG_prefix "timing_role_is_check", (swig_wrapper_func) _wrap_timing_role_is_check, NULL},
    { SWIG_prefix "Library_name", (swig_wrapper_func) _wrap_Library_name, NULL},
    { SWIG_prefix "Library_find_cell", (swig_wrapper_func) _wrap_Library_find_cell, NULL},
    { SWIG_prefix "Library_find_cells_matching", (swig_wrapper_func) _wrap_Library_find_cells_matching, NULL},
    { SWIG_prefix "Library", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Library},
    { SWIG_prefix "LibraryIterator_has_next", (swig_wrapper_func) _wrap_LibraryIterator_has_next, NULL},
    { SWIG_prefix "LibraryIterator_next", (swig_wrapper_func) _wrap_LibraryIterator_next, NULL},
    { SWIG_prefix "LibraryIterator_finish", (swig_wrapper_func) _wrap_LibraryIterator_finish, NULL},
    { SWIG_prefix "LibraryIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibraryIterator},
    { SWIG_prefix "Cell_name", (swig_wrapper_func) _wrap_Cell_name, NULL},
    { SWIG_prefix "Cell_library", (swig_wrapper_func) _wrap_Cell_library, NULL},
    { SWIG_prefix "Cell_liberty_cell", (swig_wrapper_func) _wrap_Cell_liberty_cell, NULL},
    { SWIG_prefix "Cell_is_leaf", (swig_wrapper_func) _wrap_Cell_is_leaf, NULL},
    { SWIG_prefix "Cell_port_iterator", (swig_wrapper_func) _wrap_Cell_port_iterator, NULL},
    { SWIG_prefix "Cell_get_attribute", (swig_wrapper_func) _wrap_Cell_get_attribute, NULL},
    { SWIG_prefix "Cell_find_port", (swig_wrapper_func) _wrap_Cell_find_port, NULL},
    { SWIG_prefix "Cell_find_ports_matching", (swig_wrapper_func) _wrap_Cell_find_ports_matching, NULL},
    { SWIG_prefix "Cell", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Cell},
    { SWIG_prefix "CellPortIterator_has_next", (swig_wrapper_func) _wrap_CellPortIterator_has_next, NULL},
    { SWIG_prefix "CellPortIterator_next", (swig_wrapper_func) _wrap_CellPortIterator_next, NULL},
    { SWIG_prefix "CellPortIterator_finish", (swig_wrapper_func) _wrap_CellPortIterator_finish, NULL},
    { SWIG_prefix "CellPortIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_CellPortIterator},
    { SWIG_prefix "Port_bus_name", (swig_wrapper_func) _wrap_Port_bus_name, NULL},
    { SWIG_prefix "Port_cell", (swig_wrapper_func) _wrap_Port_cell, NULL},
    { SWIG_prefix "Port_liberty_port", (swig_wrapper_func) _wrap_Port_liberty_port, NULL},
    { SWIG_prefix "Port_is_bus", (swig_wrapper_func) _wrap_Port_is_bus, NULL},
    { SWIG_prefix "Port_member_iterator", (swig_wrapper_func) _wrap_Port_member_iterator, NULL},
    { SWIG_prefix "Port", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Port},
    { SWIG_prefix "PortMemberIterator_has_next", (swig_wrapper_func) _wrap_PortMemberIterator_has_next, NULL},
    { SWIG_prefix "PortMemberIterator_next", (swig_wrapper_func) _wrap_PortMemberIterator_next, NULL},
    { SWIG_prefix "PortMemberIterator_finish", (swig_wrapper_func) _wrap_PortMemberIterator_finish, NULL},
    { SWIG_prefix "PortMemberIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PortMemberIterator},
    { SWIG_prefix "Instance_parent", (swig_wrapper_func) _wrap_Instance_parent, NULL},
    { SWIG_prefix "Instance_cell", (swig_wrapper_func) _wrap_Instance_cell, NULL},
    { SWIG_prefix "Instance_liberty_cell", (swig_wrapper_func) _wrap_Instance_liberty_cell, NULL},
    { SWIG_prefix "Instance_is_leaf", (swig_wrapper_func) _wrap_Instance_is_leaf, NULL},
    { SWIG_prefix "Instance_child_iterator", (swig_wrapper_func) _wrap_Instance_child_iterator, NULL},
    { SWIG_prefix "Instance_pin_iterator", (swig_wrapper_func) _wrap_Instance_pin_iterator, NULL},
    { SWIG_prefix "Instance_net_iterator", (swig_wrapper_func) _wrap_Instance_net_iterator, NULL},
    { SWIG_prefix "Instance_find_pin", (swig_wrapper_func) _wrap_Instance_find_pin, NULL},
    { SWIG_prefix "Instance_get_attribute", (swig_wrapper_func) _wrap_Instance_get_attribute, NULL},
    { SWIG_prefix "Instance", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Instance},
    { SWIG_prefix "Pin_port_name", (swig_wrapper_func) _wrap_Pin_port_name, NULL},
    { SWIG_prefix "Pin_instance", (swig_wrapper_func) _wrap_Pin_instance, NULL},
    { SWIG_prefix "Pin_net", (swig_wrapper_func) _wrap_Pin_net, NULL},
    { SWIG_prefix "Pin_port", (swig_wrapper_func) _wrap_Pin_port, NULL},
    { SWIG_prefix "Pin_term", (swig_wrapper_func) _wrap_Pin_term, NULL},
    { SWIG_prefix "Pin_liberty_port", (swig_wrapper_func) _wrap_Pin_liberty_port, NULL},
    { SWIG_prefix "Pin_is_driver", (swig_wrapper_func) _wrap_Pin_is_driver, NULL},
    { SWIG_prefix "Pin_is_load", (swig_wrapper_func) _wrap_Pin_is_load, NULL},
    { SWIG_prefix "Pin_is_leaf", (swig_wrapper_func) _wrap_Pin_is_leaf, NULL},
    { SWIG_prefix "Pin_is_hierarchical", (swig_wrapper_func) _wrap_Pin_is_hierarchical, NULL},
    { SWIG_prefix "Pin_is_top_level_port", (swig_wrapper_func) _wrap_Pin_is_top_level_port, NULL},
    { SWIG_prefix "Pin_connected_pin_iterator", (swig_wrapper_func) _wrap_Pin_connected_pin_iterator, NULL},
    { SWIG_prefix "Pin_vertices", (swig_wrapper_func) _wrap_Pin_vertices, NULL},
    { SWIG_prefix "Pin", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Pin},
    { SWIG_prefix "Term_net", (swig_wrapper_func) _wrap_Term_net, NULL},
    { SWIG_prefix "Term_pin", (swig_wrapper_func) _wrap_Term_pin, NULL},
    { SWIG_prefix "Term", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Term},
    { SWIG_prefix "InstanceChildIterator_has_next", (swig_wrapper_func) _wrap_InstanceChildIterator_has_next, NULL},
    { SWIG_prefix "InstanceChildIterator_next", (swig_wrapper_func) _wrap_InstanceChildIterator_next, NULL},
    { SWIG_prefix "InstanceChildIterator_finish", (swig_wrapper_func) _wrap_InstanceChildIterator_finish, NULL},
    { SWIG_prefix "InstanceChildIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_InstanceChildIterator},
    { SWIG_prefix "InstancePinIterator_has_next", (swig_wrapper_func) _wrap_InstancePinIterator_has_next, NULL},
    { SWIG_prefix "InstancePinIterator_next", (swig_wrapper_func) _wrap_InstancePinIterator_next, NULL},
    { SWIG_prefix "InstancePinIterator_finish", (swig_wrapper_func) _wrap_InstancePinIterator_finish, NULL},
    { SWIG_prefix "InstancePinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_InstancePinIterator},
    { SWIG_prefix "InstanceNetIterator_has_next", (swig_wrapper_func) _wrap_InstanceNetIterator_has_next, NULL},
    { SWIG_prefix "InstanceNetIterator_next", (swig_wrapper_func) _wrap_InstanceNetIterator_next, NULL},
    { SWIG_prefix "InstanceNetIterator_finish", (swig_wrapper_func) _wrap_InstanceNetIterator_finish, NULL},
    { SWIG_prefix "InstanceNetIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_InstanceNetIterator},
    { SWIG_prefix "LeafInstanceIterator_has_next", (swig_wrapper_func) _wrap_LeafInstanceIterator_has_next, NULL},
    { SWIG_prefix "LeafInstanceIterator_next", (swig_wrapper_func) _wrap_LeafInstanceIterator_next, NULL},
    { SWIG_prefix "LeafInstanceIterator_finish", (swig_wrapper_func) _wrap_LeafInstanceIterator_finish, NULL},
    { SWIG_prefix "LeafInstanceIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LeafInstanceIterator},
    { SWIG_prefix "Net_instance", (swig_wrapper_func) _wrap_Net_instance, NULL},
    { SWIG_prefix "Net_highest_connected_net", (swig_wrapper_func) _wrap_Net_highest_connected_net, NULL},
    { SWIG_prefix "Net_pin_iterator", (swig_wrapper_func) _wrap_Net_pin_iterator, NULL},
    { SWIG_prefix "Net_term_iterator", (swig_wrapper_func) _wrap_Net_term_iterator, NULL},
    { SWIG_prefix "Net_connected_pin_iterator", (swig_wrapper_func) _wrap_Net_connected_pin_iterator, NULL},
    { SWIG_prefix "Net_is_power", (swig_wrapper_func) _wrap_Net_is_power, NULL},
    { SWIG_prefix "Net_is_ground", (swig_wrapper_func) _wrap_Net_is_ground, NULL},
    { SWIG_prefix "Net_capacitance", (swig_wrapper_func) _wrap_Net_capacitance, NULL},
    { SWIG_prefix "Net_pin_capacitance", (swig_wrapper_func) _wrap_Net_pin_capacitance, NULL},
    { SWIG_prefix "Net_wire_capacitance", (swig_wrapper_func) _wrap_Net_wire_capacitance, NULL},
    { SWIG_prefix "Net_ports", (swig_wrapper_func) _wrap_Net_ports, NULL},
    { SWIG_prefix "Net", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Net},
    { SWIG_prefix "NetPinIterator_has_next", (swig_wrapper_func) _wrap_NetPinIterator_has_next, NULL},
    { SWIG_prefix "NetPinIterator_next", (swig_wrapper_func) _wrap_NetPinIterator_next, NULL},
    { SWIG_prefix "NetPinIterator_finish", (swig_wrapper_func) _wrap_NetPinIterator_finish, NULL},
    { SWIG_prefix "NetPinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_NetPinIterator},
    { SWIG_prefix "NetTermIterator_has_next", (swig_wrapper_func) _wrap_NetTermIterator_has_next, NULL},
    { SWIG_prefix "NetTermIterator_next", (swig_wrapper_func) _wrap_NetTermIterator_next, NULL},
    { SWIG_prefix "NetTermIterator_finish", (swig_wrapper_func) _wrap_NetTermIterator_finish, NULL},
    { SWIG_prefix "NetTermIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_NetTermIterator},
    { SWIG_prefix "NetConnectedPinIterator_has_next", (swig_wrapper_func) _wrap_NetConnectedPinIterator_has_next, NULL},
    { SWIG_prefix "NetConnectedPinIterator_next", (swig_wrapper_func) _wrap_NetConnectedPinIterator_next, NULL},
    { SWIG_prefix "NetConnectedPinIterator_finish", (swig_wrapper_func) _wrap_NetConnectedPinIterator_finish, NULL},
    { SWIG_prefix "NetConnectedPinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_NetConnectedPinIterator},
    { SWIG_prefix "PinConnectedPinIterator_has_next", (swig_wrapper_func) _wrap_PinConnectedPinIterator_has_next, NULL},
    { SWIG_prefix "PinConnectedPinIterator_next", (swig_wrapper_func) _wrap_PinConnectedPinIterator_next, NULL},
    { SWIG_prefix "PinConnectedPinIterator_finish", (swig_wrapper_func) _wrap_PinConnectedPinIterator_finish, NULL},
    { SWIG_prefix "PinConnectedPinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PinConnectedPinIterator},
    { SWIG_prefix "network_is_linked", (swig_wrapper_func) _wrap_network_is_linked, NULL},
    { SWIG_prefix "set_path_divider", (swig_wrapper_func) _wrap_set_path_divider, NULL},
    { SWIG_prefix "set_current_instance", (swig_wrapper_func) _wrap_set_current_instance, NULL},
    { SWIG_prefix "network_instance_count", (swig_wrapper_func) _wrap_network_instance_count, NULL},
    { SWIG_prefix "network_pin_count", (swig_wrapper_func) _wrap_network_pin_count, NULL},
    { SWIG_prefix "network_net_count", (swig_wrapper_func) _wrap_network_net_count, NULL},
    { SWIG_prefix "network_leaf_instance_count", (swig_wrapper_func) _wrap_network_leaf_instance_count, NULL},
    { SWIG_prefix "network_leaf_pin_count", (swig_wrapper_func) _wrap_network_leaf_pin_count, NULL},
    { SWIG_prefix "find_library", (swig_wrapper_func) _wrap_find_library, NULL},
    { SWIG_prefix "library_iterator", (swig_wrapper_func) _wrap_library_iterator, NULL},
    { SWIG_prefix "find_cells_matching", (swig_wrapper_func) _wrap_find_cells_matching, NULL},
    { SWIG_prefix "set_cmd_namespace_cmd", (swig_wrapper_func) _wrap_set_cmd_namespace_cmd, NULL},
    { SWIG_prefix "link_design_cmd", (swig_wrapper_func) _wrap_link_design_cmd, NULL},
    { SWIG_prefix "top_instance", (swig_wrapper_func) _wrap_top_instance, NULL},
    { SWIG_prefix "leaf_instance_iterator", (swig_wrapper_func) _wrap_leaf_instance_iterator, NULL},
    { SWIG_prefix "port_direction", (swig_wrapper_func) _wrap_port_direction, NULL},
    { SWIG_prefix "pin_direction", (swig_wrapper_func) _wrap_pin_direction, NULL},
    { SWIG_prefix "find_ports_matching", (swig_wrapper_func) _wrap_find_ports_matching, NULL},
    { SWIG_prefix "find_port_pins_matching", (swig_wrapper_func) _wrap_find_port_pins_matching, NULL},
    { SWIG_prefix "find_pin", (swig_wrapper_func) _wrap_find_pin, NULL},
    { SWIG_prefix "get_port_pin", (swig_wrapper_func) _wrap_get_port_pin, NULL},
    { SWIG_prefix "find_pins_matching", (swig_wrapper_func) _wrap_find_pins_matching, NULL},
    { SWIG_prefix "find_pins_hier_matching", (swig_wrapper_func) _wrap_find_pins_hier_matching, NULL},
    { SWIG_prefix "find_instance", (swig_wrapper_func) _wrap_find_instance, NULL},
    { SWIG_prefix "network_leaf_instances", (swig_wrapper_func) _wrap_network_leaf_instances, NULL},
    { SWIG_prefix "find_instances_matching", (swig_wrapper_func) _wrap_find_instances_matching, NULL},
    { SWIG_prefix "find_instances_hier_matching", (swig_wrapper_func) _wrap_find_instances_hier_matching, NULL},
    { SWIG_prefix "find_register_instances", (swig_wrapper_func) _wrap_find_register_instances, NULL},
    { SWIG_prefix "find_register_data_pins", (swig_wrapper_func) _wrap_find_register_data_pins, NULL},
    { SWIG_prefix "find_register_clk_pins", (swig_wrapper_func) _wrap_find_register_clk_pins, NULL},
    { SWIG_prefix "find_register_async_pins", (swig_wrapper_func) _wrap_find_register_async_pins, NULL},
    { SWIG_prefix "find_register_output_pins", (swig_wrapper_func) _wrap_find_register_output_pins, NULL},
    { SWIG_prefix "find_net", (swig_wrapper_func) _wrap_find_net, NULL},
    { SWIG_prefix "find_nets_matching", (swig_wrapper_func) _wrap_find_nets_matching, NULL},
    { SWIG_prefix "find_nets_hier_matching", (swig_wrapper_func) _wrap_find_nets_hier_matching, NULL},
    { SWIG_prefix "net_driver_pins", (swig_wrapper_func) _wrap_net_driver_pins, NULL},
    { SWIG_prefix "net_load_pins", (swig_wrapper_func) _wrap_net_load_pins, NULL},
    { SWIG_prefix "pin_location", (swig_wrapper_func) _wrap_pin_location, NULL},
    { SWIG_prefix "port_location", (swig_wrapper_func) _wrap_port_location, NULL},
    { SWIG_prefix "make_instance_cmd", (swig_wrapper_func) _wrap_make_instance_cmd, NULL},
    { SWIG_prefix "delete_instance_cmd", (swig_wrapper_func) _wrap_delete_instance_cmd, NULL},
    { SWIG_prefix "replace_cell_cmd", (swig_wrapper_func) _wrap_replace_cell_cmd, NULL},
    { SWIG_prefix "make_net_cmd", (swig_wrapper_func) _wrap_make_net_cmd, NULL},
    { SWIG_prefix "make_port_pin_cmd", (swig_wrapper_func) _wrap_make_port_pin_cmd, NULL},
    { SWIG_prefix "delete_net_cmd", (swig_wrapper_func) _wrap_delete_net_cmd, NULL},
    { SWIG_prefix "connect_pin_cmd", (swig_wrapper_func) _wrap_connect_pin_cmd, NULL},
    { SWIG_prefix "disconnect_pin_cmd", (swig_wrapper_func) _wrap_disconnect_pin_cmd, NULL},
    { SWIG_prefix "network_changed", (swig_wrapper_func) _wrap_network_changed, NULL},
    { SWIG_prefix "read_spef_cmd", (swig_wrapper_func) _wrap_read_spef_cmd, NULL},
    { SWIG_prefix "report_parasitic_annotation_cmd", (swig_wrapper_func) _wrap_report_parasitic_annotation_cmd, NULL},
    { SWIG_prefix "find_pi_elmore", (swig_wrapper_func) _wrap_find_pi_elmore, NULL},
    { SWIG_prefix "find_elmore", (swig_wrapper_func) _wrap_find_elmore, NULL},
    { SWIG_prefix "set_pi_model_cmd", (swig_wrapper_func) _wrap_set_pi_model_cmd, NULL},
    { SWIG_prefix "set_elmore_cmd", (swig_wrapper_func) _wrap_set_elmore_cmd, NULL},
    { SWIG_prefix "pushPowerResultFloats", (swig_wrapper_func) _wrap_pushPowerResultFloats, NULL},
    { SWIG_prefix "design_power", (swig_wrapper_func) _wrap_design_power, NULL},
    { SWIG_prefix "instance_power", (swig_wrapper_func) _wrap_instance_power, NULL},
    { SWIG_prefix "set_power_global_activity", (swig_wrapper_func) _wrap_set_power_global_activity, NULL},
    { SWIG_prefix "set_power_input_activity", (swig_wrapper_func) _wrap_set_power_input_activity, NULL},
    { SWIG_prefix "set_power_input_port_activity", (swig_wrapper_func) _wrap_set_power_input_port_activity, NULL},
    { SWIG_prefix "set_power_pin_activity", (swig_wrapper_func) _wrap_set_power_pin_activity, NULL},
    { SWIG_prefix "clock_min_period", (swig_wrapper_func) _wrap_clock_min_period, NULL},
    { SWIG_prefix "highest_power_instances", (swig_wrapper_func) _wrap_highest_power_instances, NULL},
    { SWIG_prefix "read_vcd_file", (swig_wrapper_func) _wrap_read_vcd_file, NULL},
    { SWIG_prefix "read_saif_file", (swig_wrapper_func) _wrap_read_saif_file, NULL},
    { SWIG_prefix "report_activity_annotation_cmd", (swig_wrapper_func) _wrap_report_activity_annotation_cmd, NULL},
    { SWIG_prefix "Clock_period", (swig_wrapper_func) _wrap_Clock_period, NULL},
    { SWIG_prefix "Clock_waveform", (swig_wrapper_func) _wrap_Clock_waveform, NULL},
    { SWIG_prefix "Clock_time", (swig_wrapper_func) _wrap_Clock_time, NULL},
    { SWIG_prefix "Clock_is_generated", (swig_wrapper_func) _wrap_Clock_is_generated, NULL},
    { SWIG_prefix "Clock_waveform_valid", (swig_wrapper_func) _wrap_Clock_waveform_valid, NULL},
    { SWIG_prefix "Clock_is_virtual", (swig_wrapper_func) _wrap_Clock_is_virtual, NULL},
    { SWIG_prefix "Clock_is_propagated", (swig_wrapper_func) _wrap_Clock_is_propagated, NULL},
    { SWIG_prefix "Clock_sources", (swig_wrapper_func) _wrap_Clock_sources, NULL},
    { SWIG_prefix "Clock_slew", (swig_wrapper_func) _wrap_Clock_slew, NULL},
    { SWIG_prefix "Clock", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Clock},
    { SWIG_prefix "ClockEdge_clock", (swig_wrapper_func) _wrap_ClockEdge_clock, NULL},
    { SWIG_prefix "ClockEdge_transition", (swig_wrapper_func) _wrap_ClockEdge_transition, NULL},
    { SWIG_prefix "ClockEdge_time", (swig_wrapper_func) _wrap_ClockEdge_time, NULL},
    { SWIG_prefix "ClockEdge", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ClockEdge},
    { SWIG_prefix "ExceptionFrom", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ExceptionFrom},
    { SWIG_prefix "ExceptionThru", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ExceptionThru},
    { SWIG_prefix "ExceptionTo", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ExceptionTo},
    { SWIG_prefix "OperatingConditions_process", (swig_wrapper_func) _wrap_OperatingConditions_process, NULL},
    { SWIG_prefix "OperatingConditions_voltage", (swig_wrapper_func) _wrap_OperatingConditions_voltage, NULL},
    { SWIG_prefix "OperatingConditions_temperature", (swig_wrapper_func) _wrap_OperatingConditions_temperature, NULL},
    { SWIG_prefix "OperatingConditions", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OperatingConditions},
    { SWIG_prefix "write_sdc_cmd", (swig_wrapper_func) _wrap_write_sdc_cmd, NULL},
    { SWIG_prefix "set_analysis_type_cmd", (swig_wrapper_func) _wrap_set_analysis_type_cmd, NULL},
    { SWIG_prefix "operating_conditions", (swig_wrapper_func) _wrap_operating_conditions, NULL},
    { SWIG_prefix "set_operating_conditions_cmd", (swig_wrapper_func) _wrap_set_operating_conditions_cmd, NULL},
    { SWIG_prefix "operating_condition_analysis_type", (swig_wrapper_func) _wrap_operating_condition_analysis_type, NULL},
    { SWIG_prefix "set_instance_pvt", (swig_wrapper_func) _wrap_set_instance_pvt, NULL},
    { SWIG_prefix "port_ext_pin_cap", (swig_wrapper_func) _wrap_port_ext_pin_cap, NULL},
    { SWIG_prefix "set_port_ext_pin_cap", (swig_wrapper_func) _wrap_set_port_ext_pin_cap, NULL},
    { SWIG_prefix "port_ext_wire_cap", (swig_wrapper_func) _wrap_port_ext_wire_cap, NULL},
    { SWIG_prefix "set_port_ext_wire_cap", (swig_wrapper_func) _wrap_set_port_ext_wire_cap, NULL},
    { SWIG_prefix "set_port_ext_fanout_cmd", (swig_wrapper_func) _wrap_set_port_ext_fanout_cmd, NULL},
    { SWIG_prefix "port_ext_fanout", (swig_wrapper_func) _wrap_port_ext_fanout, NULL},
    { SWIG_prefix "set_net_wire_cap", (swig_wrapper_func) _wrap_set_net_wire_cap, NULL},
    { SWIG_prefix "set_wire_load_mode_cmd", (swig_wrapper_func) _wrap_set_wire_load_mode_cmd, NULL},
    { SWIG_prefix "set_net_resistance", (swig_wrapper_func) _wrap_set_net_resistance, NULL},
    { SWIG_prefix "set_wire_load_cmd", (swig_wrapper_func) _wrap_set_wire_load_cmd, NULL},
    { SWIG_prefix "set_wire_load_selection_group_cmd", (swig_wrapper_func) _wrap_set_wire_load_selection_group_cmd, NULL},
    { SWIG_prefix "make_clock", (swig_wrapper_func) _wrap_make_clock, NULL},
    { SWIG_prefix "make_generated_clock", (swig_wrapper_func) _wrap_make_generated_clock, NULL},
    { SWIG_prefix "remove_clock_cmd", (swig_wrapper_func) _wrap_remove_clock_cmd, NULL},
    { SWIG_prefix "set_propagated_clock_cmd", (swig_wrapper_func) _wrap_set_propagated_clock_cmd, NULL},
    { SWIG_prefix "set_propagated_clock_pin_cmd", (swig_wrapper_func) _wrap_set_propagated_clock_pin_cmd, NULL},
    { SWIG_prefix "unset_propagated_clock_cmd", (swig_wrapper_func) _wrap_unset_propagated_clock_cmd, NULL},
    { SWIG_prefix "unset_propagated_clock_pin_cmd", (swig_wrapper_func) _wrap_unset_propagated_clock_pin_cmd, NULL},
    { SWIG_prefix "set_clock_slew_cmd", (swig_wrapper_func) _wrap_set_clock_slew_cmd, NULL},
    { SWIG_prefix "unset_clock_slew_cmd", (swig_wrapper_func) _wrap_unset_clock_slew_cmd, NULL},
    { SWIG_prefix "set_clock_latency_cmd", (swig_wrapper_func) _wrap_set_clock_latency_cmd, NULL},
    { SWIG_prefix "set_clock_insertion_cmd", (swig_wrapper_func) _wrap_set_clock_insertion_cmd, NULL},
    { SWIG_prefix "unset_clock_latency_cmd", (swig_wrapper_func) _wrap_unset_clock_latency_cmd, NULL},
    { SWIG_prefix "unset_clock_insertion_cmd", (swig_wrapper_func) _wrap_unset_clock_insertion_cmd, NULL},
    { SWIG_prefix "set_clock_uncertainty_clk", (swig_wrapper_func) _wrap_set_clock_uncertainty_clk, NULL},
    { SWIG_prefix "unset_clock_uncertainty_clk", (swig_wrapper_func) _wrap_unset_clock_uncertainty_clk, NULL},
    { SWIG_prefix "set_clock_uncertainty_pin", (swig_wrapper_func) _wrap_set_clock_uncertainty_pin, NULL},
    { SWIG_prefix "unset_clock_uncertainty_pin", (swig_wrapper_func) _wrap_unset_clock_uncertainty_pin, NULL},
    { SWIG_prefix "set_inter_clock_uncertainty", (swig_wrapper_func) _wrap_set_inter_clock_uncertainty, NULL},
    { SWIG_prefix "unset_inter_clock_uncertainty", (swig_wrapper_func) _wrap_unset_inter_clock_uncertainty, NULL},
    { SWIG_prefix "set_clock_gating_check_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_cmd, NULL},
    { SWIG_prefix "set_clock_gating_check_clk_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_clk_cmd, NULL},
    { SWIG_prefix "set_clock_gating_check_pin_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_pin_cmd, NULL},
    { SWIG_prefix "set_clock_gating_check_instance_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_instance_cmd, NULL},
    { SWIG_prefix "set_data_check_cmd", (swig_wrapper_func) _wrap_set_data_check_cmd, NULL},
    { SWIG_prefix "unset_data_check_cmd", (swig_wrapper_func) _wrap_unset_data_check_cmd, NULL},
    { SWIG_prefix "set_input_delay_cmd", (swig_wrapper_func) _wrap_set_input_delay_cmd, NULL},
    { SWIG_prefix "unset_input_delay_cmd", (swig_wrapper_func) _wrap_unset_input_delay_cmd, NULL},
    { SWIG_prefix "set_output_delay_cmd", (swig_wrapper_func) _wrap_set_output_delay_cmd, NULL},
    { SWIG_prefix "unset_output_delay_cmd", (swig_wrapper_func) _wrap_unset_output_delay_cmd, NULL},
    { SWIG_prefix "disable_cell", (swig_wrapper_func) _wrap_disable_cell, NULL},
    { SWIG_prefix "unset_disable_cell", (swig_wrapper_func) _wrap_unset_disable_cell, NULL},
    { SWIG_prefix "disable_lib_port", (swig_wrapper_func) _wrap_disable_lib_port, NULL},
    { SWIG_prefix "unset_disable_lib_port", (swig_wrapper_func) _wrap_unset_disable_lib_port, NULL},
    { SWIG_prefix "disable_port", (swig_wrapper_func) _wrap_disable_port, NULL},
    { SWIG_prefix "unset_disable_port", (swig_wrapper_func) _wrap_unset_disable_port, NULL},
    { SWIG_prefix "disable_instance", (swig_wrapper_func) _wrap_disable_instance, NULL},
    { SWIG_prefix "unset_disable_instance", (swig_wrapper_func) _wrap_unset_disable_instance, NULL},
    { SWIG_prefix "disable_pin", (swig_wrapper_func) _wrap_disable_pin, NULL},
    { SWIG_prefix "unset_disable_pin", (swig_wrapper_func) _wrap_unset_disable_pin, NULL},
    { SWIG_prefix "disable_edge", (swig_wrapper_func) _wrap_disable_edge, NULL},
    { SWIG_prefix "unset_disable_edge", (swig_wrapper_func) _wrap_unset_disable_edge, NULL},
    { SWIG_prefix "disable_timing_arc_set", (swig_wrapper_func) _wrap_disable_timing_arc_set, NULL},
    { SWIG_prefix "unset_disable_timing_arc_set", (swig_wrapper_func) _wrap_unset_disable_timing_arc_set, NULL},
    { SWIG_prefix "disable_clock_gating_check_inst", (swig_wrapper_func) _wrap_disable_clock_gating_check_inst, NULL},
    { SWIG_prefix "disable_clock_gating_check_pin", (swig_wrapper_func) _wrap_disable_clock_gating_check_pin, NULL},
    { SWIG_prefix "unset_disable_clock_gating_check_inst", (swig_wrapper_func) _wrap_unset_disable_clock_gating_check_inst, NULL},
    { SWIG_prefix "unset_disable_clock_gating_check_pin", (swig_wrapper_func) _wrap_unset_disable_clock_gating_check_pin, NULL},
    { SWIG_prefix "disabled_edges_sorted", (swig_wrapper_func) _wrap_disabled_edges_sorted, NULL},
    { SWIG_prefix "timing_arc_disabled", (swig_wrapper_func) _wrap_timing_arc_disabled, NULL},
    { SWIG_prefix "make_false_path", (swig_wrapper_func) _wrap_make_false_path, NULL},
    { SWIG_prefix "make_multicycle_path", (swig_wrapper_func) _wrap_make_multicycle_path, NULL},
    { SWIG_prefix "make_path_delay", (swig_wrapper_func) _wrap_make_path_delay, NULL},
    { SWIG_prefix "reset_path_cmd", (swig_wrapper_func) _wrap_reset_path_cmd, NULL},
    { SWIG_prefix "make_group_path", (swig_wrapper_func) _wrap_make_group_path, NULL},
    { SWIG_prefix "is_path_group_name", (swig_wrapper_func) _wrap_is_path_group_name, NULL},
    { SWIG_prefix "make_exception_from", (swig_wrapper_func) _wrap_make_exception_from, NULL},
    { SWIG_prefix "delete_exception_from", (swig_wrapper_func) _wrap_delete_exception_from, NULL},
    { SWIG_prefix "check_exception_from_pins", (swig_wrapper_func) _wrap_check_exception_from_pins, NULL},
    { SWIG_prefix "make_exception_thru", (swig_wrapper_func) _wrap_make_exception_thru, NULL},
    { SWIG_prefix "delete_exception_thru", (swig_wrapper_func) _wrap_delete_exception_thru, NULL},
    { SWIG_prefix "make_exception_to", (swig_wrapper_func) _wrap_make_exception_to, NULL},
    { SWIG_prefix "delete_exception_to", (swig_wrapper_func) _wrap_delete_exception_to, NULL},
    { SWIG_prefix "check_exception_to_pins", (swig_wrapper_func) _wrap_check_exception_to_pins, NULL},
    { SWIG_prefix "make_clock_groups", (swig_wrapper_func) _wrap_make_clock_groups, NULL},
    { SWIG_prefix "clock_groups_make_group", (swig_wrapper_func) _wrap_clock_groups_make_group, NULL},
    { SWIG_prefix "unset_clock_groups_logically_exclusive", (swig_wrapper_func) _wrap_unset_clock_groups_logically_exclusive, NULL},
    { SWIG_prefix "unset_clock_groups_physically_exclusive", (swig_wrapper_func) _wrap_unset_clock_groups_physically_exclusive, NULL},
    { SWIG_prefix "unset_clock_groups_asynchronous", (swig_wrapper_func) _wrap_unset_clock_groups_asynchronous, NULL},
    { SWIG_prefix "same_clk_group", (swig_wrapper_func) _wrap_same_clk_group, NULL},
    { SWIG_prefix "set_clock_sense_cmd", (swig_wrapper_func) _wrap_set_clock_sense_cmd, NULL},
    { SWIG_prefix "set_input_slew_cmd", (swig_wrapper_func) _wrap_set_input_slew_cmd, NULL},
    { SWIG_prefix "set_drive_cell_cmd", (swig_wrapper_func) _wrap_set_drive_cell_cmd, NULL},
    { SWIG_prefix "set_drive_resistance_cmd", (swig_wrapper_func) _wrap_set_drive_resistance_cmd, NULL},
    { SWIG_prefix "set_slew_limit_clk", (swig_wrapper_func) _wrap_set_slew_limit_clk, NULL},
    { SWIG_prefix "set_slew_limit_port", (swig_wrapper_func) _wrap_set_slew_limit_port, NULL},
    { SWIG_prefix "set_slew_limit_cell", (swig_wrapper_func) _wrap_set_slew_limit_cell, NULL},
    { SWIG_prefix "set_port_capacitance_limit", (swig_wrapper_func) _wrap_set_port_capacitance_limit, NULL},
    { SWIG_prefix "set_pin_capacitance_limit", (swig_wrapper_func) _wrap_set_pin_capacitance_limit, NULL},
    { SWIG_prefix "set_cell_capacitance_limit", (swig_wrapper_func) _wrap_set_cell_capacitance_limit, NULL},
    { SWIG_prefix "set_latch_borrow_limit_pin", (swig_wrapper_func) _wrap_set_latch_borrow_limit_pin, NULL},
    { SWIG_prefix "set_latch_borrow_limit_inst", (swig_wrapper_func) _wrap_set_latch_borrow_limit_inst, NULL},
    { SWIG_prefix "set_latch_borrow_limit_clk", (swig_wrapper_func) _wrap_set_latch_borrow_limit_clk, NULL},
    { SWIG_prefix "set_min_pulse_width_global", (swig_wrapper_func) _wrap_set_min_pulse_width_global, NULL},
    { SWIG_prefix "set_min_pulse_width_pin", (swig_wrapper_func) _wrap_set_min_pulse_width_pin, NULL},
    { SWIG_prefix "set_min_pulse_width_clk", (swig_wrapper_func) _wrap_set_min_pulse_width_clk, NULL},
    { SWIG_prefix "set_min_pulse_width_inst", (swig_wrapper_func) _wrap_set_min_pulse_width_inst, NULL},
    { SWIG_prefix "set_max_area_cmd", (swig_wrapper_func) _wrap_set_max_area_cmd, NULL},
    { SWIG_prefix "set_port_fanout_limit", (swig_wrapper_func) _wrap_set_port_fanout_limit, NULL},
    { SWIG_prefix "set_cell_fanout_limit", (swig_wrapper_func) _wrap_set_cell_fanout_limit, NULL},
    { SWIG_prefix "set_logic_value_cmd", (swig_wrapper_func) _wrap_set_logic_value_cmd, NULL},
    { SWIG_prefix "set_case_analysis_cmd", (swig_wrapper_func) _wrap_set_case_analysis_cmd, NULL},
    { SWIG_prefix "unset_case_analysis_cmd", (swig_wrapper_func) _wrap_unset_case_analysis_cmd, NULL},
    { SWIG_prefix "set_timing_derate_cmd", (swig_wrapper_func) _wrap_set_timing_derate_cmd, NULL},
    { SWIG_prefix "set_timing_derate_net_cmd", (swig_wrapper_func) _wrap_set_timing_derate_net_cmd, NULL},
    { SWIG_prefix "set_timing_derate_inst_cmd", (swig_wrapper_func) _wrap_set_timing_derate_inst_cmd, NULL},
    { SWIG_prefix "set_timing_derate_cell_cmd", (swig_wrapper_func) _wrap_set_timing_derate_cell_cmd, NULL},
    { SWIG_prefix "unset_timing_derate_cmd", (swig_wrapper_func) _wrap_unset_timing_derate_cmd, NULL},
    { SWIG_prefix "find_clock", (swig_wrapper_func) _wrap_find_clock, NULL},
    { SWIG_prefix "is_clock_src", (swig_wrapper_func) _wrap_is_clock_src, NULL},
    { SWIG_prefix "default_arrival_clock", (swig_wrapper_func) _wrap_default_arrival_clock, NULL},
    { SWIG_prefix "find_clocks_matching", (swig_wrapper_func) _wrap_find_clocks_matching, NULL},
    { SWIG_prefix "update_generated_clks", (swig_wrapper_func) _wrap_update_generated_clks, NULL},
    { SWIG_prefix "is_clock", (swig_wrapper_func) _wrap_is_clock, NULL},
    { SWIG_prefix "is_ideal_clock", (swig_wrapper_func) _wrap_is_ideal_clock, NULL},
    { SWIG_prefix "is_clock_search", (swig_wrapper_func) _wrap_is_clock_search, NULL},
    { SWIG_prefix "is_genclk_src", (swig_wrapper_func) _wrap_is_genclk_src, NULL},
    { SWIG_prefix "pin_is_constrained", (swig_wrapper_func) _wrap_pin_is_constrained, NULL},
    { SWIG_prefix "instance_is_constrained", (swig_wrapper_func) _wrap_instance_is_constrained, NULL},
    { SWIG_prefix "net_is_constrained", (swig_wrapper_func) _wrap_net_is_constrained, NULL},
    { SWIG_prefix "clk_thru_tristate_enabled", (swig_wrapper_func) _wrap_clk_thru_tristate_enabled, NULL},
    { SWIG_prefix "set_clk_thru_tristate_enabled", (swig_wrapper_func) _wrap_set_clk_thru_tristate_enabled, NULL},
    { SWIG_prefix "remove_constraints", (swig_wrapper_func) _wrap_remove_constraints, NULL},
    { SWIG_prefix "all_inputs_cmd", (swig_wrapper_func) _wrap_all_inputs_cmd, NULL},
    { SWIG_prefix "all_outputs_cmd", (swig_wrapper_func) _wrap_all_outputs_cmd, NULL},
    { SWIG_prefix "filter_ports", (swig_wrapper_func) _wrap_filter_ports, NULL},
    { SWIG_prefix "filter_insts", (swig_wrapper_func) _wrap_filter_insts, NULL},
    { SWIG_prefix "filter_pins", (swig_wrapper_func) _wrap_filter_pins, NULL},
    { SWIG_prefix "filter_clocks", (swig_wrapper_func) _wrap_filter_clocks, NULL},
    { SWIG_prefix "filter_lib_cells", (swig_wrapper_func) _wrap_filter_lib_cells, NULL},
    { SWIG_prefix "filter_lib_pins", (swig_wrapper_func) _wrap_filter_lib_pins, NULL},
    { SWIG_prefix "filter_liberty_libraries", (swig_wrapper_func) _wrap_filter_liberty_libraries, NULL},
    { SWIG_prefix "filter_nets", (swig_wrapper_func) _wrap_filter_nets, NULL},
    { SWIG_prefix "filter_timing_arcs", (swig_wrapper_func) _wrap_filter_timing_arcs, NULL},
    { SWIG_prefix "path_group_names", (swig_wrapper_func) _wrap_path_group_names, NULL},
    { SWIG_prefix "set_voltage_global", (swig_wrapper_func) _wrap_set_voltage_global, NULL},
    { SWIG_prefix "set_voltage_net", (swig_wrapper_func) _wrap_set_voltage_net, NULL},
    { SWIG_prefix "group_path_pins", (swig_wrapper_func) _wrap_group_path_pins, NULL},
    { SWIG_prefix "pin_case_logic_value", (swig_wrapper_func) _wrap_pin_case_logic_value, NULL},
    { SWIG_prefix "pin_logic_value", (swig_wrapper_func) _wrap_pin_logic_value, NULL},
    { SWIG_prefix "propagate_all_clocks", (swig_wrapper_func) _wrap_propagate_all_clocks, NULL},
    { SWIG_prefix "set_propagate_all_clocks", (swig_wrapper_func) _wrap_set_propagate_all_clocks, NULL},
    { SWIG_prefix "read_sdf_file", (swig_wrapper_func) _wrap_read_sdf_file, NULL},
    { SWIG_prefix "report_annotated_delay_cmd", (swig_wrapper_func) _wrap_report_annotated_delay_cmd, NULL},
    { SWIG_prefix "report_annotated_check_cmd", (swig_wrapper_func) _wrap_report_annotated_check_cmd, NULL},
    { SWIG_prefix "write_sdf_cmd", (swig_wrapper_func) _wrap_write_sdf_cmd, NULL},
    { SWIG_prefix "VertexPathIterator_has_next", (swig_wrapper_func) _wrap_VertexPathIterator_has_next, NULL},
    { SWIG_prefix "VertexPathIterator_next", (swig_wrapper_func) _wrap_VertexPathIterator_next, NULL},
    { SWIG_prefix "VertexPathIterator_finish", (swig_wrapper_func) _wrap_VertexPathIterator_finish, NULL},
    { SWIG_prefix "VertexPathIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexPathIterator},
    { SWIG_prefix "PathRef_arrival", (swig_wrapper_func) _wrap_PathRef_arrival, NULL},
    { SWIG_prefix "PathRef_required", (swig_wrapper_func) _wrap_PathRef_required, NULL},
    { SWIG_prefix "PathRef_slack", (swig_wrapper_func) _wrap_PathRef_slack, NULL},
    { SWIG_prefix "PathRef_pin", (swig_wrapper_func) _wrap_PathRef_pin, NULL},
    { SWIG_prefix "PathRef_tag", (swig_wrapper_func) _wrap_PathRef_tag, NULL},
    { SWIG_prefix "PathRef_pins", (swig_wrapper_func) _wrap_PathRef_pins, NULL},
    { SWIG_prefix "PathRef", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PathRef},
    { SWIG_prefix "PathEnd_is_unconstrained", (swig_wrapper_func) _wrap_PathEnd_is_unconstrained, NULL},
    { SWIG_prefix "PathEnd_is_check", (swig_wrapper_func) _wrap_PathEnd_is_check, NULL},
    { SWIG_prefix "PathEnd_is_latch_check", (swig_wrapper_func) _wrap_PathEnd_is_latch_check, NULL},
    { SWIG_prefix "PathEnd_is_data_check", (swig_wrapper_func) _wrap_PathEnd_is_data_check, NULL},
    { SWIG_prefix "PathEnd_is_output_delay", (swig_wrapper_func) _wrap_PathEnd_is_output_delay, NULL},
    { SWIG_prefix "PathEnd_is_path_delay", (swig_wrapper_func) _wrap_PathEnd_is_path_delay, NULL},
    { SWIG_prefix "PathEnd_is_gated_clock", (swig_wrapper_func) _wrap_PathEnd_is_gated_clock, NULL},
    { SWIG_prefix "PathEnd_vertex", (swig_wrapper_func) _wrap_PathEnd_vertex, NULL},
    { SWIG_prefix "PathEnd_path", (swig_wrapper_func) _wrap_PathEnd_path, NULL},
    { SWIG_prefix "PathEnd_end_transition", (swig_wrapper_func) _wrap_PathEnd_end_transition, NULL},
    { SWIG_prefix "PathEnd_slack", (swig_wrapper_func) _wrap_PathEnd_slack, NULL},
    { SWIG_prefix "PathEnd_margin", (swig_wrapper_func) _wrap_PathEnd_margin, NULL},
    { SWIG_prefix "PathEnd_data_required_time", (swig_wrapper_func) _wrap_PathEnd_data_required_time, NULL},
    { SWIG_prefix "PathEnd_data_arrival_time", (swig_wrapper_func) _wrap_PathEnd_data_arrival_time, NULL},
    { SWIG_prefix "PathEnd_check_role", (swig_wrapper_func) _wrap_PathEnd_check_role, NULL},
    { SWIG_prefix "PathEnd_min_max", (swig_wrapper_func) _wrap_PathEnd_min_max, NULL},
    { SWIG_prefix "PathEnd_source_clk_offset", (swig_wrapper_func) _wrap_PathEnd_source_clk_offset, NULL},
    { SWIG_prefix "PathEnd_source_clk_latency", (swig_wrapper_func) _wrap_PathEnd_source_clk_latency, NULL},
    { SWIG_prefix "PathEnd_source_clk_insertion_delay", (swig_wrapper_func) _wrap_PathEnd_source_clk_insertion_delay, NULL},
    { SWIG_prefix "PathEnd_target_clk", (swig_wrapper_func) _wrap_PathEnd_target_clk, NULL},
    { SWIG_prefix "PathEnd_target_clk_edge", (swig_wrapper_func) _wrap_PathEnd_target_clk_edge, NULL},
    { SWIG_prefix "PathEnd_target_clk_path", (swig_wrapper_func) _wrap_PathEnd_target_clk_path, NULL},
    { SWIG_prefix "PathEnd_target_clk_time", (swig_wrapper_func) _wrap_PathEnd_target_clk_time, NULL},
    { SWIG_prefix "PathEnd_target_clk_offset", (swig_wrapper_func) _wrap_PathEnd_target_clk_offset, NULL},
    { SWIG_prefix "PathEnd_target_clk_mcp_adjustment", (swig_wrapper_func) _wrap_PathEnd_target_clk_mcp_adjustment, NULL},
    { SWIG_prefix "PathEnd_target_clk_delay", (swig_wrapper_func) _wrap_PathEnd_target_clk_delay, NULL},
    { SWIG_prefix "PathEnd_target_clk_insertion_delay", (swig_wrapper_func) _wrap_PathEnd_target_clk_insertion_delay, NULL},
    { SWIG_prefix "PathEnd_target_clk_uncertainty", (swig_wrapper_func) _wrap_PathEnd_target_clk_uncertainty, NULL},
    { SWIG_prefix "PathEnd_inter_clk_uncertainty", (swig_wrapper_func) _wrap_PathEnd_inter_clk_uncertainty, NULL},
    { SWIG_prefix "PathEnd_target_clk_arrival", (swig_wrapper_func) _wrap_PathEnd_target_clk_arrival, NULL},
    { SWIG_prefix "PathEnd_path_delay_margin_is_external", (swig_wrapper_func) _wrap_PathEnd_path_delay_margin_is_external, NULL},
    { SWIG_prefix "PathEnd_check_crpr", (swig_wrapper_func) _wrap_PathEnd_check_crpr, NULL},
    { SWIG_prefix "PathEnd_target_clk_end_trans", (swig_wrapper_func) _wrap_PathEnd_target_clk_end_trans, NULL},
    { SWIG_prefix "PathEnd_clk_skew", (swig_wrapper_func) _wrap_PathEnd_clk_skew, NULL},
    { SWIG_prefix "PathEnd", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PathEnd},
    { SWIG_prefix "MinPulseWidthCheck", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_MinPulseWidthCheck},
    { SWIG_prefix "MinPulseWidthCheckSeq", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_MinPulseWidthCheckSeq},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator_has_next", (swig_wrapper_func) _wrap_MinPulseWidthCheckSeqIterator_has_next, NULL},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator_next", (swig_wrapper_func) _wrap_MinPulseWidthCheckSeqIterator_next, NULL},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator_finish", (swig_wrapper_func) _wrap_MinPulseWidthCheckSeqIterator_finish, NULL},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_MinPulseWidthCheckSeqIterator},
    { SWIG_prefix "Corner_name", (swig_wrapper_func) _wrap_Corner_name, NULL},
    { SWIG_prefix "Corner", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Corner},
    { SWIG_prefix "init_sta", (swig_wrapper_func) _wrap_init_sta, NULL},
    { SWIG_prefix "clear_sta", (swig_wrapper_func) _wrap_clear_sta, NULL},
    { SWIG_prefix "make_sta", (swig_wrapper_func) _wrap_make_sta, NULL},
    { SWIG_prefix "tcl_interp", (swig_wrapper_func) _wrap_tcl_interp, NULL},
    { SWIG_prefix "clear_network", (swig_wrapper_func) _wrap_clear_network, NULL},
    { SWIG_prefix "delete_all_memory", (swig_wrapper_func) _wrap_delete_all_memory, NULL},
    { SWIG_prefix "find_timing_cmd", (swig_wrapper_func) _wrap_find_timing_cmd, NULL},
    { SWIG_prefix "arrivals_invalid", (swig_wrapper_func) _wrap_arrivals_invalid, NULL},
    { SWIG_prefix "startpoints", (swig_wrapper_func) _wrap_startpoints, NULL},
    { SWIG_prefix "endpoints", (swig_wrapper_func) _wrap_endpoints, NULL},
    { SWIG_prefix "endpoint_path_count", (swig_wrapper_func) _wrap_endpoint_path_count, NULL},
    { SWIG_prefix "find_requireds", (swig_wrapper_func) _wrap_find_requireds, NULL},
    { SWIG_prefix "total_negative_slack_cmd", (swig_wrapper_func) _wrap_total_negative_slack_cmd, NULL},
    { SWIG_prefix "total_negative_slack_corner_cmd", (swig_wrapper_func) _wrap_total_negative_slack_corner_cmd, NULL},
    { SWIG_prefix "worst_slack_cmd", (swig_wrapper_func) _wrap_worst_slack_cmd, NULL},
    { SWIG_prefix "worst_slack_vertex", (swig_wrapper_func) _wrap_worst_slack_vertex, NULL},
    { SWIG_prefix "worst_slack_corner", (swig_wrapper_func) _wrap_worst_slack_corner, NULL},
    { SWIG_prefix "vertex_worst_arrival_path", (swig_wrapper_func) _wrap_vertex_worst_arrival_path, NULL},
    { SWIG_prefix "vertex_worst_arrival_path_rf", (swig_wrapper_func) _wrap_vertex_worst_arrival_path_rf, NULL},
    { SWIG_prefix "vertex_worst_slack_path", (swig_wrapper_func) _wrap_vertex_worst_slack_path, NULL},
    { SWIG_prefix "tag_group_path_count", (swig_wrapper_func) _wrap_tag_group_path_count, NULL},
    { SWIG_prefix "report_tag_groups", (swig_wrapper_func) _wrap_report_tag_groups, NULL},
    { SWIG_prefix "report_tag_arrivals_cmd", (swig_wrapper_func) _wrap_report_tag_arrivals_cmd, NULL},
    { SWIG_prefix "report_arrival_count_histogram", (swig_wrapper_func) _wrap_report_arrival_count_histogram, NULL},
    { SWIG_prefix "tag_count", (swig_wrapper_func) _wrap_tag_count, NULL},
    { SWIG_prefix "report_tags", (swig_wrapper_func) _wrap_report_tags, NULL},
    { SWIG_prefix "report_clk_infos", (swig_wrapper_func) _wrap_report_clk_infos, NULL},
    { SWIG_prefix "clk_info_count", (swig_wrapper_func) _wrap_clk_info_count, NULL},
    { SWIG_prefix "arrival_count", (swig_wrapper_func) _wrap_arrival_count, NULL},
    { SWIG_prefix "required_count", (swig_wrapper_func) _wrap_required_count, NULL},
    { SWIG_prefix "endpoint_violation_count", (swig_wrapper_func) _wrap_endpoint_violation_count, NULL},
    { SWIG_prefix "report_loops", (swig_wrapper_func) _wrap_report_loops, NULL},
    { SWIG_prefix "pin_sim_logic_value", (swig_wrapper_func) _wrap_pin_sim_logic_value, NULL},
    { SWIG_prefix "slow_drivers", (swig_wrapper_func) _wrap_slow_drivers, NULL},
    { SWIG_prefix "find_path_ends", (swig_wrapper_func) _wrap_find_path_ends, NULL},
    { SWIG_prefix "report_path_end_header", (swig_wrapper_func) _wrap_report_path_end_header, NULL},
    { SWIG_prefix "report_path_end_footer", (swig_wrapper_func) _wrap_report_path_end_footer, NULL},
    { SWIG_prefix "report_path_end", (swig_wrapper_func) _wrap_report_path_end, NULL},
    { SWIG_prefix "report_path_end2", (swig_wrapper_func) _wrap_report_path_end2, NULL},
    { SWIG_prefix "set_report_path_format", (swig_wrapper_func) _wrap_set_report_path_format, NULL},
    { SWIG_prefix "set_report_path_field_order", (swig_wrapper_func) _wrap_set_report_path_field_order, NULL},
    { SWIG_prefix "set_report_path_fields", (swig_wrapper_func) _wrap_set_report_path_fields, NULL},
    { SWIG_prefix "set_report_path_field_properties", (swig_wrapper_func) _wrap_set_report_path_field_properties, NULL},
    { SWIG_prefix "set_report_path_field_width", (swig_wrapper_func) _wrap_set_report_path_field_width, NULL},
    { SWIG_prefix "set_report_path_digits", (swig_wrapper_func) _wrap_set_report_path_digits, NULL},
    { SWIG_prefix "set_report_path_no_split", (swig_wrapper_func) _wrap_set_report_path_no_split, NULL},
    { SWIG_prefix "set_report_path_sigmas", (swig_wrapper_func) _wrap_set_report_path_sigmas, NULL},
    { SWIG_prefix "delete_path_ref", (swig_wrapper_func) _wrap_delete_path_ref, NULL},
    { SWIG_prefix "report_path_cmd", (swig_wrapper_func) _wrap_report_path_cmd, NULL},
    { SWIG_prefix "report_path_ends", (swig_wrapper_func) _wrap_report_path_ends, NULL},
    { SWIG_prefix "report_clk_skew", (swig_wrapper_func) _wrap_report_clk_skew, NULL},
    { SWIG_prefix "report_clk_latency", (swig_wrapper_func) _wrap_report_clk_latency, NULL},
    { SWIG_prefix "worst_clk_skew_cmd", (swig_wrapper_func) _wrap_worst_clk_skew_cmd, NULL},
    { SWIG_prefix "min_pulse_width_violations", (swig_wrapper_func) _wrap_min_pulse_width_violations, NULL},
    { SWIG_prefix "min_pulse_width_check_pins", (swig_wrapper_func) _wrap_min_pulse_width_check_pins, NULL},
    { SWIG_prefix "min_pulse_width_checks", (swig_wrapper_func) _wrap_min_pulse_width_checks, NULL},
    { SWIG_prefix "min_pulse_width_check_slack", (swig_wrapper_func) _wrap_min_pulse_width_check_slack, NULL},
    { SWIG_prefix "report_mpw_checks", (swig_wrapper_func) _wrap_report_mpw_checks, NULL},
    { SWIG_prefix "report_mpw_check", (swig_wrapper_func) _wrap_report_mpw_check, NULL},
    { SWIG_prefix "min_period_violations", (swig_wrapper_func) _wrap_min_period_violations, NULL},
    { SWIG_prefix "min_period_check_slack", (swig_wrapper_func) _wrap_min_period_check_slack, NULL},
    { SWIG_prefix "report_min_period_checks", (swig_wrapper_func) _wrap_report_min_period_checks, NULL},
    { SWIG_prefix "report_min_period_check", (swig_wrapper_func) _wrap_report_min_period_check, NULL},
    { SWIG_prefix "max_skew_violations", (swig_wrapper_func) _wrap_max_skew_violations, NULL},
    { SWIG_prefix "max_skew_check_slack", (swig_wrapper_func) _wrap_max_skew_check_slack, NULL},
    { SWIG_prefix "report_max_skew_checks", (swig_wrapper_func) _wrap_report_max_skew_checks, NULL},
    { SWIG_prefix "report_max_skew_check", (swig_wrapper_func) _wrap_report_max_skew_check, NULL},
    { SWIG_prefix "find_clk_min_period", (swig_wrapper_func) _wrap_find_clk_min_period, NULL},
    { SWIG_prefix "check_slew_limits", (swig_wrapper_func) _wrap_check_slew_limits, NULL},
    { SWIG_prefix "max_slew_violation_count", (swig_wrapper_func) _wrap_max_slew_violation_count, NULL},
    { SWIG_prefix "max_slew_check_slack", (swig_wrapper_func) _wrap_max_slew_check_slack, NULL},
    { SWIG_prefix "max_slew_check_limit", (swig_wrapper_func) _wrap_max_slew_check_limit, NULL},
    { SWIG_prefix "report_slew_limit_short_header", (swig_wrapper_func) _wrap_report_slew_limit_short_header, NULL},
    { SWIG_prefix "report_slew_limit_short", (swig_wrapper_func) _wrap_report_slew_limit_short, NULL},
    { SWIG_prefix "report_slew_limit_verbose", (swig_wrapper_func) _wrap_report_slew_limit_verbose, NULL},
    { SWIG_prefix "check_fanout_limits", (swig_wrapper_func) _wrap_check_fanout_limits, NULL},
    { SWIG_prefix "max_fanout_violation_count", (swig_wrapper_func) _wrap_max_fanout_violation_count, NULL},
    { SWIG_prefix "max_fanout_check_slack", (swig_wrapper_func) _wrap_max_fanout_check_slack, NULL},
    { SWIG_prefix "max_fanout_check_limit", (swig_wrapper_func) _wrap_max_fanout_check_limit, NULL},
    { SWIG_prefix "report_fanout_limit_short_header", (swig_wrapper_func) _wrap_report_fanout_limit_short_header, NULL},
    { SWIG_prefix "report_fanout_limit_short", (swig_wrapper_func) _wrap_report_fanout_limit_short, NULL},
    { SWIG_prefix "report_fanout_limit_verbose", (swig_wrapper_func) _wrap_report_fanout_limit_verbose, NULL},
    { SWIG_prefix "check_capacitance_limits", (swig_wrapper_func) _wrap_check_capacitance_limits, NULL},
    { SWIG_prefix "max_capacitance_violation_count", (swig_wrapper_func) _wrap_max_capacitance_violation_count, NULL},
    { SWIG_prefix "max_capacitance_check_slack", (swig_wrapper_func) _wrap_max_capacitance_check_slack, NULL},
    { SWIG_prefix "max_capacitance_check_limit", (swig_wrapper_func) _wrap_max_capacitance_check_limit, NULL},
    { SWIG_prefix "report_capacitance_limit_short_header", (swig_wrapper_func) _wrap_report_capacitance_limit_short_header, NULL},
    { SWIG_prefix "report_capacitance_limit_short", (swig_wrapper_func) _wrap_report_capacitance_limit_short, NULL},
    { SWIG_prefix "report_capacitance_limit_verbose", (swig_wrapper_func) _wrap_report_capacitance_limit_verbose, NULL},
    { SWIG_prefix "write_timing_model_cmd", (swig_wrapper_func) _wrap_write_timing_model_cmd, NULL},
    { SWIG_prefix "define_corners_cmd", (swig_wrapper_func) _wrap_define_corners_cmd, NULL},
    { SWIG_prefix "cmd_corner", (swig_wrapper_func) _wrap_cmd_corner, NULL},
    { SWIG_prefix "set_cmd_corner", (swig_wrapper_func) _wrap_set_cmd_corner, NULL},
    { SWIG_prefix "find_corner", (swig_wrapper_func) _wrap_find_corner, NULL},
    { SWIG_prefix "corners", (swig_wrapper_func) _wrap_corners, NULL},
    { SWIG_prefix "multi_corner", (swig_wrapper_func) _wrap_multi_corner, NULL},
    { SWIG_prefix "check_timing_cmd", (swig_wrapper_func) _wrap_check_timing_cmd, NULL},
    { SWIG_prefix "find_fanin_pins", (swig_wrapper_func) _wrap_find_fanin_pins, NULL},
    { SWIG_prefix "find_fanin_insts", (swig_wrapper_func) _wrap_find_fanin_insts, NULL},
    { SWIG_prefix "find_fanout_pins", (swig_wrapper_func) _wrap_find_fanout_pins, NULL},
    { SWIG_prefix "find_fanout_insts", (swig_wrapper_func) _wrap_find_fanout_insts, NULL},
    { SWIG_prefix "crpr_enabled", (swig_wrapper_func) _wrap_crpr_enabled, NULL},
    { SWIG_prefix "set_crpr_enabled", (swig_wrapper_func) _wrap_set_crpr_enabled, NULL},
    { SWIG_prefix "crpr_mode", (swig_wrapper_func) _wrap_crpr_mode, NULL},
    { SWIG_prefix "set_crpr_mode", (swig_wrapper_func) _wrap_set_crpr_mode, NULL},
    { SWIG_prefix "pocv_enabled", (swig_wrapper_func) _wrap_pocv_enabled, NULL},
    { SWIG_prefix "set_pocv_enabled", (swig_wrapper_func) _wrap_set_pocv_enabled, NULL},
    { SWIG_prefix "pocv_sigma_factor", (swig_wrapper_func) _wrap_pocv_sigma_factor, NULL},
    { SWIG_prefix "set_pocv_sigma_factor", (swig_wrapper_func) _wrap_set_pocv_sigma_factor, NULL},
    { SWIG_prefix "propagate_gated_clock_enable", (swig_wrapper_func) _wrap_propagate_gated_clock_enable, NULL},
    { SWIG_prefix "set_propagate_gated_clock_enable", (swig_wrapper_func) _wrap_set_propagate_gated_clock_enable, NULL},
    { SWIG_prefix "preset_clr_arcs_enabled", (swig_wrapper_func) _wrap_preset_clr_arcs_enabled, NULL},
    { SWIG_prefix "set_preset_clr_arcs_enabled", (swig_wrapper_func) _wrap_set_preset_clr_arcs_enabled, NULL},
    { SWIG_prefix "cond_default_arcs_enabled", (swig_wrapper_func) _wrap_cond_default_arcs_enabled, NULL},
    { SWIG_prefix "set_cond_default_arcs_enabled", (swig_wrapper_func) _wrap_set_cond_default_arcs_enabled, NULL},
    { SWIG_prefix "bidirect_inst_paths_enabled", (swig_wrapper_func) _wrap_bidirect_inst_paths_enabled, NULL},
    { SWIG_prefix "set_bidirect_inst_paths_enabled", (swig_wrapper_func) _wrap_set_bidirect_inst_paths_enabled, NULL},
    { SWIG_prefix "bidirect_net_paths_enabled", (swig_wrapper_func) _wrap_bidirect_net_paths_enabled, NULL},
    { SWIG_prefix "set_bidirect_net_paths_enabled", (swig_wrapper_func) _wrap_set_bidirect_net_paths_enabled, NULL},
    { SWIG_prefix "recovery_removal_checks_enabled", (swig_wrapper_func) _wrap_recovery_removal_checks_enabled, NULL},
    { SWIG_prefix "set_recovery_removal_checks_enabled", (swig_wrapper_func) _wrap_set_recovery_removal_checks_enabled, NULL},
    { SWIG_prefix "gated_clk_checks_enabled", (swig_wrapper_func) _wrap_gated_clk_checks_enabled, NULL},
    { SWIG_prefix "set_gated_clk_checks_enabled", (swig_wrapper_func) _wrap_set_gated_clk_checks_enabled, NULL},
    { SWIG_prefix "dynamic_loop_breaking", (swig_wrapper_func) _wrap_dynamic_loop_breaking, NULL},
    { SWIG_prefix "set_dynamic_loop_breaking", (swig_wrapper_func) _wrap_set_dynamic_loop_breaking, NULL},
    { SWIG_prefix "use_default_arrival_clock", (swig_wrapper_func) _wrap_use_default_arrival_clock, NULL},
    { SWIG_prefix "set_use_default_arrival_clock", (swig_wrapper_func) _wrap_set_use_default_arrival_clock, NULL},
    { SWIG_prefix "pin_property", (swig_wrapper_func) _wrap_pin_property, NULL},
    { SWIG_prefix "instance_property", (swig_wrapper_func) _wrap_instance_property, NULL},
    { SWIG_prefix "net_property", (swig_wrapper_func) _wrap_net_property, NULL},
    { SWIG_prefix "port_property", (swig_wrapper_func) _wrap_port_property, NULL},
    { SWIG_prefix "liberty_cell_property", (swig_wrapper_func) _wrap_liberty_cell_property, NULL},
    { SWIG_prefix "cell_property", (swig_wrapper_func) _wrap_cell_property, NULL},
    { SWIG_prefix "liberty_port_property", (swig_wrapper_func) _wrap_liberty_port_property, NULL},
    { SWIG_prefix "library_property", (swig_wrapper_func) _wrap_library_property, NULL},
    { SWIG_prefix "liberty_library_property", (swig_wrapper_func) _wrap_liberty_library_property, NULL},
    { SWIG_prefix "edge_property", (swig_wrapper_func) _wrap_edge_property, NULL},
    { SWIG_prefix "clock_property", (swig_wrapper_func) _wrap_clock_property, NULL},
    { SWIG_prefix "path_end_property", (swig_wrapper_func) _wrap_path_end_property, NULL},
    { SWIG_prefix "path_ref_property", (swig_wrapper_func) _wrap_path_ref_property, NULL},
    { SWIG_prefix "timing_arc_set_property", (swig_wrapper_func) _wrap_timing_arc_set_property, NULL},
    { SWIG_prefix "version", (swig_wrapper_func) _wrap_version, NULL},
    { SWIG_prefix "git_sha1", (swig_wrapper_func) _wrap_git_sha1, NULL},
    { SWIG_prefix "elapsed_run_time", (swig_wrapper_func) _wrap_elapsed_run_time, NULL},
    { SWIG_prefix "user_run_time", (swig_wrapper_func) _wrap_user_run_time, NULL},
    { SWIG_prefix "cputime", (swig_wrapper_func) _wrap_cputime, NULL},
    { SWIG_prefix "memory_usage", (swig_wrapper_func) _wrap_memory_usage, NULL},
    { SWIG_prefix "processor_count", (swig_wrapper_func) _wrap_processor_count, NULL},
    { SWIG_prefix "thread_count", (swig_wrapper_func) _wrap_thread_count, NULL},
    { SWIG_prefix "set_thread_count", (swig_wrapper_func) _wrap_set_thread_count, NULL},
    { SWIG_prefix "report_error", (swig_wrapper_func) _wrap_report_error, NULL},
    { SWIG_prefix "report_file_error", (swig_wrapper_func) _wrap_report_file_error, NULL},
    { SWIG_prefix "report_warn", (swig_wrapper_func) _wrap_report_warn, NULL},
    { SWIG_prefix "report_file_warn", (swig_wrapper_func) _wrap_report_file_warn, NULL},
    { SWIG_prefix "report_line", (swig_wrapper_func) _wrap_report_line, NULL},
    { SWIG_prefix "suppress_msg_id", (swig_wrapper_func) _wrap_suppress_msg_id, NULL},
    { SWIG_prefix "unsuppress_msg_id", (swig_wrapper_func) _wrap_unsuppress_msg_id, NULL},
    { SWIG_prefix "is_suppressed", (swig_wrapper_func) _wrap_is_suppressed, NULL},
    { SWIG_prefix "fflush", (swig_wrapper_func) _wrap_fflush, NULL},
    { SWIG_prefix "redirect_file_begin", (swig_wrapper_func) _wrap_redirect_file_begin, NULL},
    { SWIG_prefix "redirect_file_append_begin", (swig_wrapper_func) _wrap_redirect_file_append_begin, NULL},
    { SWIG_prefix "redirect_file_end", (swig_wrapper_func) _wrap_redirect_file_end, NULL},
    { SWIG_prefix "redirect_string_begin", (swig_wrapper_func) _wrap_redirect_string_begin, NULL},
    { SWIG_prefix "redirect_string_end", (swig_wrapper_func) _wrap_redirect_string_end, NULL},
    { SWIG_prefix "log_begin_cmd", (swig_wrapper_func) _wrap_log_begin_cmd, NULL},
    { SWIG_prefix "log_end", (swig_wrapper_func) _wrap_log_end, NULL},
    { SWIG_prefix "set_debug", (swig_wrapper_func) _wrap_set_debug, NULL},
    { SWIG_prefix "is_object", (swig_wrapper_func) _wrap_is_object, NULL},
    { SWIG_prefix "object_type", (swig_wrapper_func) _wrap_object_type, NULL},
    { SWIG_prefix "is_object_list", (swig_wrapper_func) _wrap_is_object_list, NULL},
    { SWIG_prefix "time_ui_sta", (swig_wrapper_func) _wrap_time_ui_sta, NULL},
    { SWIG_prefix "time_sta_ui", (swig_wrapper_func) _wrap_time_sta_ui, NULL},
    { SWIG_prefix "capacitance_ui_sta", (swig_wrapper_func) _wrap_capacitance_ui_sta, NULL},
    { SWIG_prefix "capacitance_sta_ui", (swig_wrapper_func) _wrap_capacitance_sta_ui, NULL},
    { SWIG_prefix "resistance_ui_sta", (swig_wrapper_func) _wrap_resistance_ui_sta, NULL},
    { SWIG_prefix "resistance_sta_ui", (swig_wrapper_func) _wrap_resistance_sta_ui, NULL},
    { SWIG_prefix "voltage_ui_sta", (swig_wrapper_func) _wrap_voltage_ui_sta, NULL},
    { SWIG_prefix "voltage_sta_ui", (swig_wrapper_func) _wrap_voltage_sta_ui, NULL},
    { SWIG_prefix "current_ui_sta", (swig_wrapper_func) _wrap_current_ui_sta, NULL},
    { SWIG_prefix "current_sta_ui", (swig_wrapper_func) _wrap_current_sta_ui, NULL},
    { SWIG_prefix "power_ui_sta", (swig_wrapper_func) _wrap_power_ui_sta, NULL},
    { SWIG_prefix "power_sta_ui", (swig_wrapper_func) _wrap_power_sta_ui, NULL},
    { SWIG_prefix "distance_ui_sta", (swig_wrapper_func) _wrap_distance_ui_sta, NULL},
    { SWIG_prefix "distance_sta_ui", (swig_wrapper_func) _wrap_distance_sta_ui, NULL},
    { SWIG_prefix "area_ui_sta", (swig_wrapper_func) _wrap_area_ui_sta, NULL},
    { SWIG_prefix "area_sta_ui", (swig_wrapper_func) _wrap_area_sta_ui, NULL},
    { SWIG_prefix "set_cmd_unit_scale", (swig_wrapper_func) _wrap_set_cmd_unit_scale, NULL},
    { SWIG_prefix "set_cmd_unit_digits", (swig_wrapper_func) _wrap_set_cmd_unit_digits, NULL},
    { SWIG_prefix "set_cmd_unit_suffix", (swig_wrapper_func) _wrap_set_cmd_unit_suffix, NULL},
    { SWIG_prefix "unit_scale_abbreviation", (swig_wrapper_func) _wrap_unit_scale_abbreviation, NULL},
    { SWIG_prefix "unit_suffix", (swig_wrapper_func) _wrap_unit_suffix, NULL},
    { SWIG_prefix "unit_scaled_suffix", (swig_wrapper_func) _wrap_unit_scaled_suffix, NULL},
    { SWIG_prefix "unit_scale", (swig_wrapper_func) _wrap_unit_scale, NULL},
    { SWIG_prefix "format_time", (swig_wrapper_func) _wrap_format_time, NULL},
    { SWIG_prefix "format_capacitance", (swig_wrapper_func) _wrap_format_capacitance, NULL},
    { SWIG_prefix "format_resistance", (swig_wrapper_func) _wrap_format_resistance, NULL},
    { SWIG_prefix "format_voltage", (swig_wrapper_func) _wrap_format_voltage, NULL},
    { SWIG_prefix "format_current", (swig_wrapper_func) _wrap_format_current, NULL},
    { SWIG_prefix "format_power", (swig_wrapper_func) _wrap_format_power, NULL},
    { SWIG_prefix "format_distance", (swig_wrapper_func) _wrap_format_distance, NULL},
    { SWIG_prefix "format_area", (swig_wrapper_func) _wrap_format_area, NULL},
    { SWIG_prefix "rise_short_name", (swig_wrapper_func) _wrap_rise_short_name, NULL},
    { SWIG_prefix "fall_short_name", (swig_wrapper_func) _wrap_fall_short_name, NULL},
    { SWIG_prefix "fuzzy_equal", (swig_wrapper_func) _wrap_fuzzy_equal, NULL},
    { SWIG_prefix "write_path_spice_cmd", (swig_wrapper_func) _wrap_write_path_spice_cmd, NULL},
    { SWIG_prefix "read_verilog_cmd", (swig_wrapper_func) _wrap_read_verilog_cmd, NULL},
    { SWIG_prefix "write_verilog_cmd", (swig_wrapper_func) _wrap_write_verilog_cmd, NULL},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    { SWIG_prefix "group_path_count_max", 0, (swig_variable_func) _wrap_group_path_count_max_get,(swig_variable_func) _wrap_group_path_count_max_set},
    { SWIG_prefix "float_inf", 0, (swig_variable_func) _wrap_float_inf_get,(swig_variable_func) _wrap_float_inf_set},
    {0,0,0,0}
};

static swig_const_info swig_constants[] = {
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Cell = {"_p_Cell", "Cell *", 0, 0, (void*)&_wrap_class_Cell, 0};
static swig_type_info _swigt__p_CellPortIterator = {"_p_CellPortIterator", "CellPortIterator *", 0, 0, (void*)&_wrap_class_CellPortIterator, 0};
static swig_type_info _swigt__p_CellSeq = {"_p_CellSeq", "CellSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CircuitSim = {"_p_CircuitSim", "CircuitSim *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Clock = {"_p_Clock", "Clock *", 0, 0, (void*)&_wrap_class_Clock, 0};
static swig_type_info _swigt__p_ClockEdge = {"_p_ClockEdge", "ClockEdge *", 0, 0, (void*)&_wrap_class_ClockEdge, 0};
static swig_type_info _swigt__p_ClockGroups = {"_p_ClockGroups", "ClockGroups *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ClockSeq = {"_p_ClockSeq", "ClockSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ClockSet = {"_p_ClockSet", "ClockSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ConstClockSeq = {"_p_ConstClockSeq", "ConstClockSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Corner = {"_p_Corner", "Corner *", 0, 0, (void*)&_wrap_class_Corner, 0};
static swig_type_info _swigt__p_EarlyLate = {"_p_EarlyLate", "EarlyLate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EarlyLateAll = {"_p_EarlyLateAll", "EarlyLateAll *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Edge = {"_p_Edge", "Edge *", 0, 0, (void*)&_wrap_class_Edge, 0};
static swig_type_info _swigt__p_EdgeSeq = {"_p_EdgeSeq", "EdgeSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExceptionFrom = {"_p_ExceptionFrom", "ExceptionFrom *", 0, 0, (void*)&_wrap_class_ExceptionFrom, 0};
static swig_type_info _swigt__p_ExceptionThru = {"_p_ExceptionThru", "ExceptionThru *", 0, 0, (void*)&_wrap_class_ExceptionThru, 0};
static swig_type_info _swigt__p_ExceptionThruSeq = {"_p_ExceptionThruSeq", "ExceptionThruSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExceptionTo = {"_p_ExceptionTo", "ExceptionTo *", 0, 0, (void*)&_wrap_class_ExceptionTo, 0};
static swig_type_info _swigt__p_FloatSeq = {"_p_FloatSeq", "FloatSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Instance = {"_p_Instance", "Instance *", 0, 0, (void*)&_wrap_class_Instance, 0};
static swig_type_info _swigt__p_InstanceChildIterator = {"_p_InstanceChildIterator", "InstanceChildIterator *", 0, 0, (void*)&_wrap_class_InstanceChildIterator, 0};
static swig_type_info _swigt__p_InstanceNetIterator = {"_p_InstanceNetIterator", "InstanceNetIterator *", 0, 0, (void*)&_wrap_class_InstanceNetIterator, 0};
static swig_type_info _swigt__p_InstancePinIterator = {"_p_InstancePinIterator", "InstancePinIterator *", 0, 0, (void*)&_wrap_class_InstancePinIterator, 0};
static swig_type_info _swigt__p_InstanceSeq = {"_p_InstanceSeq", "InstanceSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_InstanceSet = {"_p_InstanceSet", "InstanceSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IntSeq = {"_p_IntSeq", "IntSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LeafInstanceIterator = {"_p_LeafInstanceIterator", "LeafInstanceIterator *", 0, 0, (void*)&_wrap_class_LeafInstanceIterator, 0};
static swig_type_info _swigt__p_LibertyCell = {"_p_LibertyCell", "LibertyCell *", 0, 0, (void*)&_wrap_class_LibertyCell, 0};
static swig_type_info _swigt__p_LibertyCellPortIterator = {"_p_LibertyCellPortIterator", "LibertyCellPortIterator *", 0, 0, (void*)&_wrap_class_LibertyCellPortIterator, 0};
static swig_type_info _swigt__p_LibertyCellSeq = {"_p_LibertyCellSeq", "LibertyCellSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LibertyLibrary = {"_p_LibertyLibrary", "LibertyLibrary *", 0, 0, (void*)&_wrap_class_LibertyLibrary, 0};
static swig_type_info _swigt__p_LibertyLibraryIterator = {"_p_LibertyLibraryIterator", "LibertyLibraryIterator *", 0, 0, (void*)&_wrap_class_LibertyLibraryIterator, 0};
static swig_type_info _swigt__p_LibertyLibrarySeq = {"_p_LibertyLibrarySeq", "LibertyLibrarySeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LibertyPort = {"_p_LibertyPort", "LibertyPort *", 0, 0, (void*)&_wrap_class_LibertyPort, 0};
static swig_type_info _swigt__p_LibertyPortMemberIterator = {"_p_LibertyPortMemberIterator", "LibertyPortMemberIterator *", 0, 0, (void*)&_wrap_class_LibertyPortMemberIterator, 0};
static swig_type_info _swigt__p_LibertyPortSeq = {"_p_LibertyPortSeq", "LibertyPortSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Library = {"_p_Library", "Library *", 0, 0, (void*)&_wrap_class_Library, 0};
static swig_type_info _swigt__p_LibraryIterator = {"_p_LibraryIterator", "LibraryIterator *", 0, 0, (void*)&_wrap_class_LibraryIterator, 0};
static swig_type_info _swigt__p_LogicValue = {"_p_LogicValue", "LogicValue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MaxSkewCheck = {"_p_MaxSkewCheck", "MaxSkewCheck *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MaxSkewCheckSeq = {"_p_MaxSkewCheckSeq", "MaxSkewCheckSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinMax = {"_p_MinMax", "MinMax *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinMaxAll = {"_p_MinMaxAll", "MinMaxAll *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinMaxAllNull = {"_p_MinMaxAllNull", "MinMaxAllNull *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinPeriodCheck = {"_p_MinPeriodCheck", "MinPeriodCheck *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinPeriodCheckSeq = {"_p_MinPeriodCheckSeq", "MinPeriodCheckSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinPulseWidthCheck = {"_p_MinPulseWidthCheck", "MinPulseWidthCheck *", 0, 0, (void*)&_wrap_class_MinPulseWidthCheck, 0};
static swig_type_info _swigt__p_MinPulseWidthCheckSeq = {"_p_MinPulseWidthCheckSeq", "MinPulseWidthCheckSeq *", 0, 0, (void*)&_wrap_class_MinPulseWidthCheckSeq, 0};
static swig_type_info _swigt__p_MinPulseWidthCheckSeqIterator = {"_p_MinPulseWidthCheckSeqIterator", "MinPulseWidthCheckSeqIterator *", 0, 0, (void*)&_wrap_class_MinPulseWidthCheckSeqIterator, 0};
static swig_type_info _swigt__p_Net = {"_p_Net", "Net *", 0, 0, (void*)&_wrap_class_Net, 0};
static swig_type_info _swigt__p_NetConnectedPinIterator = {"_p_NetConnectedPinIterator", "NetConnectedPinIterator *", 0, 0, (void*)&_wrap_class_NetConnectedPinIterator, 0};
static swig_type_info _swigt__p_NetPinIterator = {"_p_NetPinIterator", "NetPinIterator *", 0, 0, (void*)&_wrap_class_NetPinIterator, 0};
static swig_type_info _swigt__p_NetSeq = {"_p_NetSeq", "NetSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NetSet = {"_p_NetSet", "NetSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NetTermIterator = {"_p_NetTermIterator", "NetTermIterator *", 0, 0, (void*)&_wrap_class_NetTermIterator, 0};
static swig_type_info _swigt__p_OperatingConditions = {"_p_OperatingConditions", "OperatingConditions *", 0, 0, (void*)&_wrap_class_OperatingConditions, 0};
static swig_type_info _swigt__p_Path = {"_p_Path", "Path *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PathClkOrData = {"_p_PathClkOrData", "PathClkOrData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PathEnd = {"_p_PathEnd", "PathEnd *", 0, 0, (void*)&_wrap_class_PathEnd, 0};
static swig_type_info _swigt__p_PathEndSeq = {"_p_PathEndSeq", "PathEndSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PathGroupNameSet = {"_p_PathGroupNameSet", "PathGroupNameSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PathRef = {"_p_PathRef", "PathRef *", 0, 0, (void*)&_wrap_class_PathRef, 0};
static swig_type_info _swigt__p_Pin = {"_p_Pin", "Pin *", 0, 0, (void*)&_wrap_class_Pin, 0};
static swig_type_info _swigt__p_PinConnectedPinIterator = {"_p_PinConnectedPinIterator", "PinConnectedPinIterator *", 0, 0, (void*)&_wrap_class_PinConnectedPinIterator, 0};
static swig_type_info _swigt__p_PinSeq = {"_p_PinSeq", "PinSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PinSet = {"_p_PinSet", "PinSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Port = {"_p_Port", "Port *", 0, 0, (void*)&_wrap_class_Port, 0};
static swig_type_info _swigt__p_PortDirection = {"_p_PortDirection", "PortDirection *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PortMemberIterator = {"_p_PortMemberIterator", "PortMemberIterator *", 0, 0, (void*)&_wrap_class_PortMemberIterator, 0};
static swig_type_info _swigt__p_PortSeq = {"_p_PortSeq", "PortSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PowerResult = {"_p_PowerResult", "PowerResult *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ReportPathFormat = {"_p_ReportPathFormat", "ReportPathFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RiseFall = {"_p_RiseFall", "RiseFall *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RiseFallBoth = {"_p_RiseFallBoth", "RiseFallBoth *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SetupHold = {"_p_SetupHold", "SetupHold *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SetupHoldAll = {"_p_SetupHoldAll", "SetupHoldAll *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StringSeq = {"_p_StringSeq", "StringSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StringSet = {"_p_StringSet", "StringSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Tcl_Interp = {"_p_Tcl_Interp", "Tcl_Interp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Term = {"_p_Term", "Term *", 0, 0, (void*)&_wrap_class_Term, 0};
static swig_type_info _swigt__p_TimingArc = {"_p_TimingArc", "TimingArc *", 0, 0, (void*)&_wrap_class_TimingArc, 0};
static swig_type_info _swigt__p_TimingArcSet = {"_p_TimingArcSet", "TimingArcSet *", 0, 0, (void*)&_wrap_class_TimingArcSet, 0};
static swig_type_info _swigt__p_TimingDerateCellType = {"_p_TimingDerateCellType", "TimingDerateCellType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TimingDerateType = {"_p_TimingDerateType", "TimingDerateType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TimingRole = {"_p_TimingRole", "TimingRole *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Vertex = {"_p_Vertex", "Vertex *", 0, 0, (void*)&_wrap_class_Vertex, 0};
static swig_type_info _swigt__p_VertexInEdgeIterator = {"_p_VertexInEdgeIterator", "VertexInEdgeIterator *", 0, 0, (void*)&_wrap_class_VertexInEdgeIterator, 0};
static swig_type_info _swigt__p_VertexIterator = {"_p_VertexIterator", "VertexIterator *", 0, 0, (void*)&_wrap_class_VertexIterator, 0};
static swig_type_info _swigt__p_VertexOutEdgeIterator = {"_p_VertexOutEdgeIterator", "VertexOutEdgeIterator *", 0, 0, (void*)&_wrap_class_VertexOutEdgeIterator, 0};
static swig_type_info _swigt__p_VertexPathIterator = {"_p_VertexPathIterator", "VertexPathIterator *", 0, 0, (void*)&_wrap_class_VertexPathIterator, 0};
static swig_type_info _swigt__p_Wireload = {"_p_Wireload", "Wireload *", 0, 0, (void*)&_wrap_class_Wireload, 0};
static swig_type_info _swigt__p_WireloadSelection = {"_p_WireloadSelection", "WireloadSelection *", 0, 0, (void*)&_wrap_class_WireloadSelection, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Cell,
  &_swigt__p_CellPortIterator,
  &_swigt__p_CellSeq,
  &_swigt__p_CircuitSim,
  &_swigt__p_Clock,
  &_swigt__p_ClockEdge,
  &_swigt__p_ClockGroups,
  &_swigt__p_ClockSeq,
  &_swigt__p_ClockSet,
  &_swigt__p_ConstClockSeq,
  &_swigt__p_Corner,
  &_swigt__p_EarlyLate,
  &_swigt__p_EarlyLateAll,
  &_swigt__p_Edge,
  &_swigt__p_EdgeSeq,
  &_swigt__p_ExceptionFrom,
  &_swigt__p_ExceptionThru,
  &_swigt__p_ExceptionThruSeq,
  &_swigt__p_ExceptionTo,
  &_swigt__p_FloatSeq,
  &_swigt__p_Instance,
  &_swigt__p_InstanceChildIterator,
  &_swigt__p_InstanceNetIterator,
  &_swigt__p_InstancePinIterator,
  &_swigt__p_InstanceSeq,
  &_swigt__p_InstanceSet,
  &_swigt__p_IntSeq,
  &_swigt__p_LeafInstanceIterator,
  &_swigt__p_LibertyCell,
  &_swigt__p_LibertyCellPortIterator,
  &_swigt__p_LibertyCellSeq,
  &_swigt__p_LibertyLibrary,
  &_swigt__p_LibertyLibraryIterator,
  &_swigt__p_LibertyLibrarySeq,
  &_swigt__p_LibertyPort,
  &_swigt__p_LibertyPortMemberIterator,
  &_swigt__p_LibertyPortSeq,
  &_swigt__p_Library,
  &_swigt__p_LibraryIterator,
  &_swigt__p_LogicValue,
  &_swigt__p_MaxSkewCheck,
  &_swigt__p_MaxSkewCheckSeq,
  &_swigt__p_MinMax,
  &_swigt__p_MinMaxAll,
  &_swigt__p_MinMaxAllNull,
  &_swigt__p_MinPeriodCheck,
  &_swigt__p_MinPeriodCheckSeq,
  &_swigt__p_MinPulseWidthCheck,
  &_swigt__p_MinPulseWidthCheckSeq,
  &_swigt__p_MinPulseWidthCheckSeqIterator,
  &_swigt__p_Net,
  &_swigt__p_NetConnectedPinIterator,
  &_swigt__p_NetPinIterator,
  &_swigt__p_NetSeq,
  &_swigt__p_NetSet,
  &_swigt__p_NetTermIterator,
  &_swigt__p_OperatingConditions,
  &_swigt__p_Path,
  &_swigt__p_PathClkOrData,
  &_swigt__p_PathEnd,
  &_swigt__p_PathEndSeq,
  &_swigt__p_PathGroupNameSet,
  &_swigt__p_PathRef,
  &_swigt__p_Pin,
  &_swigt__p_PinConnectedPinIterator,
  &_swigt__p_PinSeq,
  &_swigt__p_PinSet,
  &_swigt__p_Port,
  &_swigt__p_PortDirection,
  &_swigt__p_PortMemberIterator,
  &_swigt__p_PortSeq,
  &_swigt__p_PowerResult,
  &_swigt__p_ReportPathFormat,
  &_swigt__p_RiseFall,
  &_swigt__p_RiseFallBoth,
  &_swigt__p_SetupHold,
  &_swigt__p_SetupHoldAll,
  &_swigt__p_StringSeq,
  &_swigt__p_StringSet,
  &_swigt__p_Tcl_Interp,
  &_swigt__p_Term,
  &_swigt__p_TimingArc,
  &_swigt__p_TimingArcSet,
  &_swigt__p_TimingDerateCellType,
  &_swigt__p_TimingDerateType,
  &_swigt__p_TimingRole,
  &_swigt__p_Vertex,
  &_swigt__p_VertexInEdgeIterator,
  &_swigt__p_VertexIterator,
  &_swigt__p_VertexOutEdgeIterator,
  &_swigt__p_VertexPathIterator,
  &_swigt__p_Wireload,
  &_swigt__p_WireloadSelection,
  &_swigt__p_char,
};

static swig_cast_info _swigc__p_Cell[] = {  {&_swigt__p_Cell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CellPortIterator[] = {  {&_swigt__p_CellPortIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CellSeq[] = {  {&_swigt__p_CellSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CircuitSim[] = {  {&_swigt__p_CircuitSim, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Clock[] = {  {&_swigt__p_Clock, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockEdge[] = {  {&_swigt__p_ClockEdge, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockGroups[] = {  {&_swigt__p_ClockGroups, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockSeq[] = {  {&_swigt__p_ClockSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockSet[] = {  {&_swigt__p_ClockSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ConstClockSeq[] = {  {&_swigt__p_ConstClockSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Corner[] = {  {&_swigt__p_Corner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EarlyLate[] = {  {&_swigt__p_EarlyLate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EarlyLateAll[] = {  {&_swigt__p_EarlyLateAll, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Edge[] = {  {&_swigt__p_Edge, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EdgeSeq[] = {  {&_swigt__p_EdgeSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionFrom[] = {  {&_swigt__p_ExceptionFrom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionThru[] = {  {&_swigt__p_ExceptionThru, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionThruSeq[] = {  {&_swigt__p_ExceptionThruSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionTo[] = {  {&_swigt__p_ExceptionTo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FloatSeq[] = {  {&_swigt__p_FloatSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Instance[] = {  {&_swigt__p_Instance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceChildIterator[] = {  {&_swigt__p_InstanceChildIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceNetIterator[] = {  {&_swigt__p_InstanceNetIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstancePinIterator[] = {  {&_swigt__p_InstancePinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceSeq[] = {  {&_swigt__p_InstanceSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceSet[] = {  {&_swigt__p_InstanceSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IntSeq[] = {  {&_swigt__p_IntSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LeafInstanceIterator[] = {  {&_swigt__p_LeafInstanceIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyCell[] = {  {&_swigt__p_LibertyCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyCellPortIterator[] = {  {&_swigt__p_LibertyCellPortIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyCellSeq[] = {  {&_swigt__p_LibertyCellSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyLibrary[] = {  {&_swigt__p_LibertyLibrary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyLibraryIterator[] = {  {&_swigt__p_LibertyLibraryIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyLibrarySeq[] = {  {&_swigt__p_LibertyLibrarySeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyPort[] = {  {&_swigt__p_LibertyPort, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyPortMemberIterator[] = {  {&_swigt__p_LibertyPortMemberIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyPortSeq[] = {  {&_swigt__p_LibertyPortSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Library[] = {  {&_swigt__p_Library, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibraryIterator[] = {  {&_swigt__p_LibraryIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LogicValue[] = {  {&_swigt__p_LogicValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MaxSkewCheck[] = {  {&_swigt__p_MaxSkewCheck, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MaxSkewCheckSeq[] = {  {&_swigt__p_MaxSkewCheckSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinMax[] = {  {&_swigt__p_MinMax, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinMaxAll[] = {  {&_swigt__p_MinMaxAll, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinMaxAllNull[] = {  {&_swigt__p_MinMaxAllNull, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPeriodCheck[] = {  {&_swigt__p_MinPeriodCheck, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPeriodCheckSeq[] = {  {&_swigt__p_MinPeriodCheckSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPulseWidthCheck[] = {  {&_swigt__p_MinPulseWidthCheck, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPulseWidthCheckSeq[] = {  {&_swigt__p_MinPulseWidthCheckSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPulseWidthCheckSeqIterator[] = {  {&_swigt__p_MinPulseWidthCheckSeqIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Net[] = {  {&_swigt__p_Net, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetConnectedPinIterator[] = {  {&_swigt__p_NetConnectedPinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetPinIterator[] = {  {&_swigt__p_NetPinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetSeq[] = {  {&_swigt__p_NetSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetSet[] = {  {&_swigt__p_NetSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetTermIterator[] = {  {&_swigt__p_NetTermIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OperatingConditions[] = {  {&_swigt__p_OperatingConditions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Path[] = {  {&_swigt__p_Path, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathClkOrData[] = {  {&_swigt__p_PathClkOrData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathEnd[] = {  {&_swigt__p_PathEnd, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathEndSeq[] = {  {&_swigt__p_PathEndSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathGroupNameSet[] = {  {&_swigt__p_PathGroupNameSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathRef[] = {  {&_swigt__p_PathRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Pin[] = {  {&_swigt__p_Pin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PinConnectedPinIterator[] = {  {&_swigt__p_PinConnectedPinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PinSeq[] = {  {&_swigt__p_PinSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PinSet[] = {  {&_swigt__p_PinSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Port[] = {  {&_swigt__p_Port, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PortDirection[] = {  {&_swigt__p_PortDirection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PortMemberIterator[] = {  {&_swigt__p_PortMemberIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PortSeq[] = {  {&_swigt__p_PortSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PowerResult[] = {  {&_swigt__p_PowerResult, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ReportPathFormat[] = {  {&_swigt__p_ReportPathFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RiseFall[] = {  {&_swigt__p_RiseFall, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RiseFallBoth[] = {  {&_swigt__p_RiseFallBoth, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SetupHold[] = {  {&_swigt__p_SetupHold, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SetupHoldAll[] = {  {&_swigt__p_SetupHoldAll, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StringSeq[] = {  {&_swigt__p_StringSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StringSet[] = {  {&_swigt__p_StringSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Tcl_Interp[] = {  {&_swigt__p_Tcl_Interp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Term[] = {  {&_swigt__p_Term, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingArc[] = {  {&_swigt__p_TimingArc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingArcSet[] = {  {&_swigt__p_TimingArcSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingDerateCellType[] = {  {&_swigt__p_TimingDerateCellType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingDerateType[] = {  {&_swigt__p_TimingDerateType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingRole[] = {  {&_swigt__p_TimingRole, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Vertex[] = {  {&_swigt__p_Vertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexInEdgeIterator[] = {  {&_swigt__p_VertexInEdgeIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexIterator[] = {  {&_swigt__p_VertexIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexOutEdgeIterator[] = {  {&_swigt__p_VertexOutEdgeIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexPathIterator[] = {  {&_swigt__p_VertexPathIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Wireload[] = {  {&_swigt__p_Wireload, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_WireloadSelection[] = {  {&_swigt__p_WireloadSelection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Cell,
  _swigc__p_CellPortIterator,
  _swigc__p_CellSeq,
  _swigc__p_CircuitSim,
  _swigc__p_Clock,
  _swigc__p_ClockEdge,
  _swigc__p_ClockGroups,
  _swigc__p_ClockSeq,
  _swigc__p_ClockSet,
  _swigc__p_ConstClockSeq,
  _swigc__p_Corner,
  _swigc__p_EarlyLate,
  _swigc__p_EarlyLateAll,
  _swigc__p_Edge,
  _swigc__p_EdgeSeq,
  _swigc__p_ExceptionFrom,
  _swigc__p_ExceptionThru,
  _swigc__p_ExceptionThruSeq,
  _swigc__p_ExceptionTo,
  _swigc__p_FloatSeq,
  _swigc__p_Instance,
  _swigc__p_InstanceChildIterator,
  _swigc__p_InstanceNetIterator,
  _swigc__p_InstancePinIterator,
  _swigc__p_InstanceSeq,
  _swigc__p_InstanceSet,
  _swigc__p_IntSeq,
  _swigc__p_LeafInstanceIterator,
  _swigc__p_LibertyCell,
  _swigc__p_LibertyCellPortIterator,
  _swigc__p_LibertyCellSeq,
  _swigc__p_LibertyLibrary,
  _swigc__p_LibertyLibraryIterator,
  _swigc__p_LibertyLibrarySeq,
  _swigc__p_LibertyPort,
  _swigc__p_LibertyPortMemberIterator,
  _swigc__p_LibertyPortSeq,
  _swigc__p_Library,
  _swigc__p_LibraryIterator,
  _swigc__p_LogicValue,
  _swigc__p_MaxSkewCheck,
  _swigc__p_MaxSkewCheckSeq,
  _swigc__p_MinMax,
  _swigc__p_MinMaxAll,
  _swigc__p_MinMaxAllNull,
  _swigc__p_MinPeriodCheck,
  _swigc__p_MinPeriodCheckSeq,
  _swigc__p_MinPulseWidthCheck,
  _swigc__p_MinPulseWidthCheckSeq,
  _swigc__p_MinPulseWidthCheckSeqIterator,
  _swigc__p_Net,
  _swigc__p_NetConnectedPinIterator,
  _swigc__p_NetPinIterator,
  _swigc__p_NetSeq,
  _swigc__p_NetSet,
  _swigc__p_NetTermIterator,
  _swigc__p_OperatingConditions,
  _swigc__p_Path,
  _swigc__p_PathClkOrData,
  _swigc__p_PathEnd,
  _swigc__p_PathEndSeq,
  _swigc__p_PathGroupNameSet,
  _swigc__p_PathRef,
  _swigc__p_Pin,
  _swigc__p_PinConnectedPinIterator,
  _swigc__p_PinSeq,
  _swigc__p_PinSet,
  _swigc__p_Port,
  _swigc__p_PortDirection,
  _swigc__p_PortMemberIterator,
  _swigc__p_PortSeq,
  _swigc__p_PowerResult,
  _swigc__p_ReportPathFormat,
  _swigc__p_RiseFall,
  _swigc__p_RiseFallBoth,
  _swigc__p_SetupHold,
  _swigc__p_SetupHoldAll,
  _swigc__p_StringSeq,
  _swigc__p_StringSet,
  _swigc__p_Tcl_Interp,
  _swigc__p_Term,
  _swigc__p_TimingArc,
  _swigc__p_TimingArcSet,
  _swigc__p_TimingDerateCellType,
  _swigc__p_TimingDerateType,
  _swigc__p_TimingRole,
  _swigc__p_Vertex,
  _swigc__p_VertexInEdgeIterator,
  _swigc__p_VertexIterator,
  _swigc__p_VertexOutEdgeIterator,
  _swigc__p_VertexPathIterator,
  _swigc__p_Wireload,
  _swigc__p_WireloadSelection,
  _swigc__p_char,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif

#ifndef SWIG_INIT_CLIENT_DATA_TYPE
#define SWIG_INIT_CLIENT_DATA_TYPE void *
#endif

SWIGRUNTIME void
SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  
  SWIGINTERN void
  SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
    size_t i;
    Tcl_Obj *obj;
    
    if (!swigconstTableinit) {
      Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
      swigconstTableinit = 1;
    }
    for (i = 0; constants[i].type; i++) {
      switch(constants[i].type) {
      case SWIG_TCL_POINTER:
        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_TCL_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        SWIG_Tcl_SetConstantObj(interp, constants[i].name, obj);
      }
    }
  }
  
  /* Create fast method lookup tables */
  
  SWIGINTERN void
  SWIG_Tcl_InstallMethodLookupTables(void) {
    size_t i;
    
    for (i = 0; i < swig_module.size; ++i) {
      swig_type_info *type = swig_module.type_initial[i];
      if (type->clientdata) {
        swig_class* klass = (swig_class*) type->clientdata;
        swig_method* meth;
        Tcl_InitHashTable(&(klass->hashtable), TCL_STRING_KEYS);
        for (meth = klass->methods; meth && meth->name; ++meth) {
          int newEntry;
          Tcl_HashEntry* hashentry = Tcl_CreateHashEntry(&(klass->hashtable), meth->name, &newEntry);
          Tcl_SetHashValue(hashentry, (ClientData)meth->method);
        }
      }
    }
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

SWIGEXPORT int SWIG_init(Tcl_Interp *interp) {
  size_t i;
  if (interp == 0) return TCL_ERROR;
#ifdef USE_TCL_STUBS
  if (Tcl_InitStubs(interp, SWIG_TCL_STUBS_VERSION, 0) == NULL) {
    return TCL_ERROR;
  }
#endif  
#ifdef USE_TK_STUBS
  /* (char*) cast is required to avoid compiler warning/error. */
  if (Tk_InitStubs(interp, (char*)SWIG_TCL_STUBS_VERSION, 0) == NULL) {
    return TCL_ERROR;
  }
#endif
  
  Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
  
#ifdef SWIG_namespace
  Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
#endif
  
  SWIG_InitializeModule((void *) interp);
  SWIG_PropagateClientData();
  
  for (i = 0; swig_commands[i].name; i++) {
    Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper,
      swig_commands[i].clientdata, NULL);
  }
  for (i = 0; swig_variables[i].name; i++) {
    Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, 
      (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, 
      (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
  }
  
  SWIG_Tcl_InstallConstants(interp, swig_constants);
  SWIG_Tcl_InstallMethodLookupTables();
  
  
  return TCL_OK;
}
SWIGEXPORT int Sta_SafeInit(Tcl_Interp *interp) {
  return SWIG_init(interp);
}

